{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Process Manager Documentation","text":"<p>Welcome to the Process Manager documentation. This documentation covers the design principles, implementation details, and API reference for the process management system.</p>"},{"location":"#quickstart-guides","title":"Quickstart Guides","text":"<ul> <li>Data Handling: Handle inputs, outputs, and other data resources across multiple processes.</li> </ul> <p>Todo</p> <p>Add more getting started guides and tutorials.</p>"},{"location":"#core-components","title":"Core Components","text":"<ul> <li>Named Values: Type-safe value containers with validation</li> <li>Random Variables: Statistical distribution implementations</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Data Handlers</li> </ul>"},{"location":"#design-principles","title":"Design Principles","text":"<p>The process manager is designed to be a flexible, extensible system that can handle various types of data processing tasks. It follows the following principles:</p> <ul> <li>Modularity: The system should be modular, allowing for easy addition or removal of components.</li> <li>Flexibility: The system should be flexible enough to accommodate different types of data and processing requirements.</li> <li>Extensibility: The system should be extensible, allowing for customization and integration with other systems.</li> </ul>"},{"location":"design/named_values/","title":"NamedValue Design","text":"<p>The <code>NamedValue</code> class implements a type-safe container for named values with built-in validation and serialization support. It follows several key design principles to ensure robust and flexible value handling.</p>"},{"location":"design/named_values/#core-design-principles","title":"Core Design Principles","text":""},{"location":"design/named_values/#1-type-safety","title":"1. Type Safety","text":"<p>The <code>NamedValue</code> class uses Python's generic typing system to enforce type safety at both runtime and static analysis time:</p> <pre><code># Type-safe value container\narray_value = NamedValue[np.ndarray](\"my_array\", value=np.array([1, 2, 3]))\nint_value = NamedValue[int](\"my_int\", value=42)\n</code></pre> <p>Type safety is enforced through: - Generic type parameters (<code>NamedValue[T]</code>) - Runtime type validation - Automatic type conversion when possible - Clear error messages when types don't match</p>"},{"location":"design/named_values/#2-value-immutability","title":"2. Value Immutability","text":"<p>Values are immutable by default after initial setting to prevent accidental modifications:</p> <pre><code>value = NamedValue[int](\"counter\", 1)\nvalue.value = 2  # Raises ValueError - value is frozen\nvalue.force_set_value(2)  # Explicit override when needed\n</code></pre>"},{"location":"design/named_values/#3-flexible-type-conversion","title":"3. Flexible Type Conversion","text":"<p>The system attempts to convert values to the correct type when possible:</p> <pre><code># String to int conversion\nint_value = NamedValue[int](\"count\", \"123\")  # Automatically converts to int(123)\n\n# Float to int conversion\nint_value = NamedValue[int](\"count\", 123.0)  # Automatically converts to int(123)\n</code></pre>"},{"location":"design/named_values/#4-inheritance-support","title":"4. Inheritance Support","text":"<p>Two different patterns are supported for extending <code>NamedValue</code>:</p> <ol> <li> <p>Direct generic usage: <pre><code>value = NamedValue[int](\"my_int\", 42)\n</code></pre></p> </li> <li> <p>Subclass with custom behavior: <pre><code>class IntegerValue(NamedValue[int]):\n    def __init__(self, name: str, value: int = None):\n        super().__init__(name, value)\n</code></pre></p> </li> </ol>"},{"location":"design/named_values/#error-handling-design","title":"Error Handling Design","text":"<p>The class implements a sophisticated error handling system that distinguishes between different usage patterns:</p> <ol> <li> <p>Direct Usage Errors (TypeError): <pre><code># Raises TypeError with detailed type information\nvalue = NamedValue[int](\"test\", \"not an integer\")\n</code></pre></p> </li> <li> <p>Subclass Usage Errors (ValueError): <pre><code># Raises ValueError with user-friendly message\nclass IntegerValue(NamedValue[int]):\n    pass\nvalue = IntegerValue(\"test\", \"not an integer\")\n</code></pre></p> </li> </ol>"},{"location":"design/named_values/#testing-strategy","title":"Testing Strategy","text":"<p>The design principles are verified through comprehensive testing:</p>"},{"location":"design/named_values/#1-type-safety-tests","title":"1. Type Safety Tests","text":"<pre><code>def test_type_checking(self):\n    # Test with explicit type parameter\n    class IntValue(NamedValue[int]):\n        pass\n\n    # Valid integer assignment\n    int_value = IntValue(\"test\", 42)\n    assert int_value.value == 42\n\n    # Valid string that can be cast to int\n    str_int_value = IntValue(\"test2\", \"123\")\n    assert str_int_value.value == 123\n\n    # Invalid type that can't be cast\n    with pytest.raises(TypeError):\n        IntValue(\"test3\", \"not an integer\")\n</code></pre>"},{"location":"design/named_values/#2-inheritance-tests","title":"2. Inheritance Tests","text":"<pre><code>def test_type_casting_inheritance(self):\n    class IntegerValue(NamedValue[int]):\n        def __init__(self, name: str, value: int = None):\n            super().__init__(name, value)\n\n    # Test valid assignment\n    int_value = IntegerValue(\"test\", 42)\n    assert isinstance(int_value.value, int)\n\n    # Test type hints are preserved\n    with pytest.raises(ValueError):\n        IntegerValue(\"test\", \"not an integer\")\n</code></pre>"},{"location":"design/named_values/#3-value-immutability-tests","title":"3. Value Immutability Tests","text":"<pre><code>def test_value_immutability(self):\n    value = NamedValue[int](\"test\", 42)\n\n    # Cannot change value after setting\n    with pytest.raises(ValueError):\n        value.value = 43\n\n    # Can force change value when needed\n    value.force_set_value(43)\n    assert value.value == 43\n</code></pre>"},{"location":"design/named_values/#serialization-support","title":"Serialization Support","text":"<p>The class implements JSON serialization support through pydantic:</p> <pre><code>value = NamedValue[int](\"counter\", 42)\nserialized = value.model_dump_json()\ndeserialized = NamedValue.model_validate_json(serialized)\n</code></pre>"},{"location":"design/named_values/#usage-guidelines","title":"Usage Guidelines","text":"<ol> <li> <p>Use direct generic syntax for simple value containers: <pre><code>value = NamedValue[int](\"simple_counter\", 0)\n</code></pre></p> </li> <li> <p>Create subclasses for custom validation or behavior: <pre><code>class PositiveInteger(NamedValue[int]):\n    def _validate_type(self, value: Any) -&gt; int:\n        value = super()._validate_type(value)\n        if value &lt;= 0:\n            raise ValueError(\"Value must be positive\")\n        return value\n</code></pre></p> </li> <li> <p>Use <code>force_set_value()</code> only when value mutability is explicitly needed: <pre><code>value.force_set_value(new_value)  # Use with caution\n</code></pre></p> </li> </ol>"},{"location":"design/named_values/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always specify the type parameter for clarity: <pre><code># Good\nvalue = NamedValue[int](\"count\", 42)\n\n# Avoid\nvalue = NamedValue(\"count\", 42)  # Type defaults to Any\n</code></pre></p> </li> <li> <p>Use meaningful names that describe the value's purpose: <pre><code># Good\ncount = NamedValue[int](\"iteration_count\", 0)\n\n# Avoid\nx = NamedValue[int](\"x\", 0)  # Name is not descriptive\n</code></pre></p> </li> <li> <p>Handle type conversion errors appropriately: <pre><code>try:\n    value = NamedValue[int](\"count\", user_input)\nexcept (TypeError, ValueError) as e:\n    # Handle invalid input\n    pass\n</code></pre></p> </li> </ol> <p>By following these design principles and usage patterns, <code>NamedValue</code> provides a robust and type-safe way to manage named values in your application.</p>"},{"location":"design/random_variables/","title":"Random Variable Design","text":"<p>The random variable system provides a flexible and type-safe way to define, sample, and manage random variables in simulations. It implements a hierarchical design pattern where specific distributions inherit from a base random variable class.</p>"},{"location":"design/random_variables/#core-design-principles","title":"Core Design Principles","text":""},{"location":"design/random_variables/#1-type-safety-and-validation","title":"1. Type Safety and Validation","text":"<p>The system uses Python's type hints and runtime validation to ensure distributions are configured correctly:</p> <pre><code># Type-safe parameter definitions\nclass NormalRandomVariable(RandomVariable[float]):\n    mean: float\n    std_dev: float = Field(gt=0)  # Validation that std_dev must be positive\n</code></pre>"},{"location":"design/random_variables/#2-inheritance-hierarchy","title":"2. Inheritance Hierarchy","text":"<p>A clear inheritance structure ensures consistent behavior across different distributions:</p> <pre><code>RandomVariable[T]  # Base class with generic type T\n    \u21b3 ContinuousRandomVariable  # For continuous distributions\n        \u21b3 NormalRandomVariable  # Specific normal distribution\n        \u21b3 UniformRandomVariable # Specific uniform distribution\n    \u21b3 DiscreteRandomVariable   # For discrete distributions\n        \u21b3 PoissonRandomVariable # Specific Poisson distribution\n</code></pre>"},{"location":"design/random_variables/#3-sampling-interface","title":"3. Sampling Interface","text":"<p>All random variables implement a consistent sampling interface:</p> <pre><code>class RandomVariable(Generic[T]):\n    def sample(self, size: Optional[int] = None) -&gt; T | NDArray:\n        \"\"\"Sample from the distribution.\"\"\"\n        raise NotImplementedError\n\n    def sample_to_list(self, size: int) -&gt; list[T]:\n        \"\"\"Sample multiple values into a list.\"\"\"\n        return list(self.sample(size))\n</code></pre>"},{"location":"design/random_variables/#4-parameter-validation","title":"4. Parameter Validation","text":"<p>Parameters are validated both at instantiation and runtime:</p> <pre><code>class UniformRandomVariable(ContinuousRandomVariable):\n    low: float\n    high: float\n\n    @field_validator(\"high\")\n    def validate_bounds(cls, high: float, info: ValidationInfo) -&gt; float:\n        low = info.data.get(\"low\", 0.0)\n        if high &lt;= low:\n            raise ValueError(\"high must be greater than low\")\n        return high\n</code></pre>"},{"location":"design/random_variables/#implementation-details","title":"Implementation Details","text":""},{"location":"design/random_variables/#1-normal-distribution","title":"1. Normal Distribution","text":"<pre><code>class NormalRandomVariable(ContinuousRandomVariable):\n    \"\"\"\n    Generates normally distributed random values.\n    \"\"\"\n    mean: float = 0.0\n    std_dev: float = Field(gt=0, default=1.0)\n\n    def sample(self, size: Optional[int] = None) -&gt; float | NDArray:\n        return np.random.normal(self.mean, self.std_dev, size)\n</code></pre>"},{"location":"design/random_variables/#2-uniform-distribution","title":"2. Uniform Distribution","text":"<pre><code>class UniformRandomVariable(ContinuousRandomVariable):\n    \"\"\"\n    Generates uniformly distributed random values.\n    \"\"\"\n    low: float = 0.0\n    high: float = 1.0\n\n    def sample(self, size: Optional[int] = None) -&gt; float | NDArray:\n        return np.random.uniform(self.low, self.high, size)\n</code></pre>"},{"location":"design/random_variables/#testing-strategy","title":"Testing Strategy","text":"<p>The testing approach verifies both the statistical properties and error handling of the distributions.</p>"},{"location":"design/random_variables/#1-statistical-property-tests","title":"1. Statistical Property Tests","text":"<pre><code>def test_normal_distribution_properties():\n    # Create normal distribution\n    normal = NormalRandomVariable(mean=10, std_dev=2)\n\n    # Sample large number of values\n    samples = normal.sample(10000)\n\n    # Check statistical properties\n    assert 9.8 &lt; np.mean(samples) &lt; 10.2  # Mean within range\n    assert 1.9 &lt; np.std(samples) &lt; 2.1    # Std dev within range\n</code></pre>"},{"location":"design/random_variables/#2-parameter-validation-tests","title":"2. Parameter Validation Tests","text":"<pre><code>def test_invalid_parameters():\n    # Test invalid standard deviation\n    with pytest.raises(ValidationError):\n        NormalRandomVariable(mean=0, std_dev=-1)\n\n    # Test invalid uniform bounds\n    with pytest.raises(ValidationError):\n        UniformRandomVariable(low=10, high=5)\n</code></pre>"},{"location":"design/random_variables/#3-sampling-interface-tests","title":"3. Sampling Interface Tests","text":"<pre><code>def test_sampling_interface():\n    normal = NormalRandomVariable(mean=0, std_dev=1)\n\n    # Test single sample\n    assert isinstance(normal.sample(), float)\n\n    # Test multiple samples\n    samples = normal.sample(10)\n    assert len(samples) == 10\n\n    # Test list conversion\n    sample_list = normal.sample_to_list(5)\n    assert isinstance(sample_list, list)\n    assert len(sample_list) == 5\n</code></pre>"},{"location":"design/random_variables/#usage-examples","title":"Usage Examples","text":""},{"location":"design/random_variables/#1-basic-usage","title":"1. Basic Usage","text":"<pre><code># Create a normal distribution\nnormal = NormalRandomVariable(mean=10, std_dev=2)\n\n# Single sample\nvalue = normal.sample()\n\n# Multiple samples\nvalues = normal.sample(100)\n</code></pre>"},{"location":"design/random_variables/#2-using-in-simulations","title":"2. Using in Simulations","text":"<pre><code># Define process variation\nprocess_var = NormalRandomVariable(mean=100, std_dev=5)\n\n# Simulate process\nmeasurements = process_var.sample_to_list(1000)\n</code></pre>"},{"location":"design/random_variables/#3-combining-distributions","title":"3. Combining Distributions","text":"<pre><code># Process with random failures\nbase_process = NormalRandomVariable(mean=100, std_dev=2)\nfailure_rate = PoissonRandomVariable(lambda_=0.1)\n\ndef simulate_process(n_steps: int) -&gt; list[float]:\n    measurements = base_process.sample_to_list(n_steps)\n    failures = failure_rate.sample_to_list(n_steps)\n    return [m if f == 0 else 0.0 for m, f in zip(measurements, failures)]\n</code></pre>"},{"location":"design/random_variables/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always validate distribution parameters: <pre><code># Good\nnormal = NormalRandomVariable(mean=0, std_dev=1.0)\n\n# Avoid\nnormal = NormalRandomVariable(mean=0, std_dev=-1.0)  # Will raise error\n</code></pre></p> </li> <li> <p>Use appropriate distribution types: <pre><code># Good - continuous values\nprocess_temp = NormalRandomVariable(mean=350, std_dev=5)\n\n# Good - discrete counts\ndefects = PoissonRandomVariable(lambda_=2.5)\n</code></pre></p> </li> <li> <p>Handle sampling errors appropriately: <pre><code>try:\n    samples = distribution.sample(1000)\nexcept ValueError as e:\n    # Handle sampling error\n    logger.error(f\"Sampling failed: {e}\")\n</code></pre></p> </li> <li> <p>Use type hints for clarity: <pre><code>def simulate_process(\n    distribution: RandomVariable[float],\n    n_samples: int\n) -&gt; NDArray:\n    return distribution.sample(n_samples)\n</code></pre></p> </li> </ol>"},{"location":"design/random_variables/#extended-features","title":"Extended Features","text":""},{"location":"design/random_variables/#1-distribution-composition","title":"1. Distribution Composition","text":"<p>The system supports combining distributions:</p> <pre><code>class CompositeRandomVariable(RandomVariable[float]):\n    distributions: list[RandomVariable[float]]\n    weights: list[float]\n\n    def sample(self, size: Optional[int] = None) -&gt; float | NDArray:\n        samples = [d.sample(size) for d in self.distributions]\n        return np.average(samples, weights=self.weights, axis=0)\n</code></pre>"},{"location":"design/random_variables/#2-serialization-support","title":"2. Serialization Support","text":"<p>Random variables can be serialized for storage or transmission:</p> <pre><code># Save distribution parameters\nnormal = NormalRandomVariable(mean=10, std_dev=2)\njson_data = normal.model_dump_json()\n\n# Recreate distribution\nloaded = NormalRandomVariable.model_validate_json(json_data)\n</code></pre> <p>This design provides a robust foundation for handling random variables in simulation and statistical applications while maintaining type safety and proper validation.</p>"},{"location":"for_reference/named_values_extensions/","title":"Named values extensions","text":"<p>Here's a comprehensive example showing both practical usage and potential extensions:</p> <p>First, basic usage: test_named_values.py</p> <pre><code>from process_manager.data_handlers import (\n    NamedValue,\n    NamedValueState,\n    NamedValueList,\n    NamedValueHash\n)\n\ndef test_basic_usage():\n    print(\"\\n=== Basic Usage ===\")\n\n    # Create a value and check its state\n    value = NamedValue(name=\"temperature\")\n    print(f\"Initial state: {value._state}\")\n\n    # Set the value and verify state change\n    value.value = 72.5\n    print(f\"After setting: {value._state}\")\n    print(f\"Value: {value.value}\")\n\n    # Try to modify (should fail)\n    try:\n        value.value = 73.0\n        print(\"Warning: Value was modified!\")\n    except ValueError as e:\n        print(f\"Protected: {e}\")\n\n    # Force set and verify state\n    value.force_set_value(73.0)\n    print(f\"After force set: {value._state}\")\n    print(f\"New value: {value.value}\")\n\ndef test_serialization():\n    print(\"\\n=== Serialization ===\")\n\n    # Create values in different states\n    unset = NamedValue(name=\"unset\")\n    set_value = NamedValue(name=\"set\", value=42)\n\n    # Serialize both\n    print(\"\\nUnset value serialized:\")\n    print(unset.model_dump_json(indent=2))\n\n    print(\"\\nSet value serialized:\")\n    print(set_value.model_dump_json(indent=2))\n\n    # Deserialize and verify states\n    json_str = set_value.model_dump_json()\n    restored = NamedValue.model_validate_json(json_str)\n    print(f\"\\nRestored value state: {restored._state}\")\n    print(f\"Restored value: {restored.value}\")\n\ndef test_collections():\n    print(\"\\n=== Collections Usage ===\")\n\n    # Create a list with mixed states\n    value_list = NamedValueList()\n    value_list.append(NamedValue(name=\"unset\"))\n    value_list.append(NamedValue(name=\"set\", value=\"hello\"))\n\n    # Create a hash with mixed states\n    value_hash = NamedValueHash()\n    value_hash.register_value(NamedValue(name=\"temp\", value=98.6))\n    value_hash.register_value(NamedValue(name=\"pressure\"))\n\n    # Serialize both\n    print(\"\\nList serialized:\")\n    print(value_list.model_dump_json(indent=2))\n\n    print(\"\\nHash serialized:\")\n    print(value_hash.model_dump_json(indent=2))\n\nif __name__ == \"__main__\":\n    test_basic_usage()\n    test_serialization()\n    test_collections()\n</code></pre> <p>Extended version with more complex state management:</p> <p><pre><code>from enum import Enum\nfrom typing import Any, Optional\nfrom datetime import datetime\n\nclass NamedValueState(str, Enum):\n    \"\"\"Extended state enum for NamedValue objects.\"\"\"\n    UNSET = \"unset\"\n    SET = \"set\"\n    PENDING = \"pending\"  # For async operations\n    INVALID = \"invalid\"  # For validation failures\n    EXPIRED = \"expired\"  # For time-sensitive values\n\nclass NamedValueMetadata:\n    \"\"\"Metadata for tracking value state changes.\"\"\"\n    def __init__(self):\n        self.created_at: datetime = datetime.now()\n        self.last_modified: Optional[datetime] = None\n        self.set_count: int = 0\n        self.previous_value: Any = None\n        self.validation_error: Optional[str] = None\n\nclass NamedValue(NamedObject, Generic[T]):\n    \"\"\"Enhanced NamedValue with extended state management.\"\"\"\n\n    _registry_category: ClassVar[str] = \"values\"\n\n    name: str = Field(..., description=\"Name of the value\")\n    _stored_value: T | UNSET = PrivateAttr(default=UNSET.token)\n    _state: NamedValueState = PrivateAttr(default=NamedValueState.UNSET)\n    _type: type = PrivateAttr()\n    _metadata: NamedValueMetadata = PrivateAttr()\n    _expiry: Optional[datetime] = PrivateAttr(default=None)\n\n    def __init__(self, name: str, value: T | None = None, expires_in: Optional[float] = None, **data):\n        super().__init__(name=name, **data)\n        self._type = self._extract_value_type()\n        self._metadata = NamedValueMetadata()\n\n        if expires_in is not None:\n            self._expiry = datetime.now().timestamp() + expires_in\n\n        if value is not None:\n            self.value = value\n\n    @property\n    def value(self) -&gt; T:\n        \"\"\"Get the stored value with additional state checks.\"\"\"\n        if self._state == NamedValueState.UNSET:\n            raise ValueError(f\"Value '{self.name}' has not been set yet.\")\n\n        if self._state == NamedValueState.INVALID:\n            raise ValueError(f\"Value '{self.name}' is invalid: {self._metadata.validation_error}\")\n\n        if self._state == NamedValueState.PENDING:\n            raise ValueError(f\"Value '{self.name}' is pending.\")\n\n        if self._state == NamedValueState.EXPIRED:\n            raise ValueError(f\"Value '{self.name}' has expired.\")\n\n        return self._stored_value\n\n    @value.setter\n    def value(self, new_value: T):\n        \"\"\"Set value with metadata tracking.\"\"\"\n        if self._state == NamedValueState.SET:\n            raise ValueError(\n                f\"Value '{self.name}' has already been set and is frozen. \"\n                \"Use force_set_value() if you need to override it.\"\n            )\n\n        try:\n            validated_value = self._validate_type(new_value)\n\n            # Update metadata\n            self._metadata.last_modified = datetime.now()\n            self._metadata.set_count += 1\n            self._metadata.previous_value = self._stored_value\n\n            # Set the new value\n            object.__setattr__(self, '_stored_value', validated_value)\n            object.__setattr__(self, '_state', NamedValueState.SET)\n\n        except Exception as e:\n            # Handle validation failure\n            self._metadata.validation_error = str(e)\n            object.__setattr__(self, '_state', NamedValueState.INVALID)\n            raise\n\n    def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n        \"\"\"Enhanced serialization with metadata.\"\"\"\n        data = super().model_dump(**kwargs)\n        data['state'] = self._state\n\n        if self._state == NamedValueState.SET:\n            data['stored_value'] = self._stored_value\n\n        # Include metadata\n        data['metadata'] = {\n            'created_at': self._metadata.created_at.isoformat(),\n            'last_modified': self._metadata.last_modified.isoformat() if self._metadata.last_modified else None,\n            'set_count': self._metadata.set_count,\n        }\n\n        if self._expiry:\n            data['expires_at'] = datetime.fromtimestamp(self._expiry).isoformat()\n\n        return data\n\n    def check_expiry(self) -&gt; bool:\n        \"\"\"Check if the value has expired.\"\"\"\n        if self._expiry and datetime.now().timestamp() &gt; self._expiry:\n            object.__setattr__(self, '_state', NamedValueState.EXPIRED)\n            return True\n        return False\n\n    def mark_pending(self) -&gt; None:\n        \"\"\"Mark value as pending (for async operations).\"\"\"\n        object.__setattr__(self, '_state', NamedValueState.PENDING)\n\n    @property\n    def state(self) -&gt; NamedValueState:\n        \"\"\"Get current state.\"\"\"\n        return self._state\n\n    @property\n    def metadata(self) -&gt; dict:\n        \"\"\"Get value metadata.\"\"\"\n        return {\n            'created_at': self._metadata.created_at,\n            'last_modified': self._metadata.last_modified,\n            'set_count': self._metadata.set_count,\n            'has_previous_value': self._metadata.previous_value is not None\n        }\n</code></pre> Example usage of the extended version: test_extended_values.py</p> <p><pre><code>from process_manager.data_handlers import NamedValue, NamedValueState\nfrom time import sleep\n\ndef test_extended_features():\n    print(\"\\n=== Testing Extended Features ===\")\n\n    # Test expiring value\n    print(\"\\nTesting expiring value:\")\n    temp = NamedValue(name=\"temperature\", value=98.6, expires_in=2)\n    print(f\"Initial value: {temp.value}\")\n    print(f\"Initial state: {temp.state}\")\n\n    print(\"Waiting for expiration...\")\n    sleep(2.1)\n    temp.check_expiry()\n    print(f\"State after expiry: {temp.state}\")\n\n    try:\n        print(f\"Value after expiry: {temp.value}\")\n    except ValueError as e:\n        print(f\"Expected error: {e}\")\n\n    # Test pending state\n    print(\"\\nTesting pending state:\")\n    async_value = NamedValue(name=\"async_data\")\n    async_value.mark_pending()\n    print(f\"State: {async_value.state}\")\n\n    try:\n        print(f\"Value: {async_value.value}\")\n    except ValueError as e:\n        print(f\"Expected error: {e}\")\n\n    # Test metadata\n    print(\"\\nTesting metadata:\")\n    value = NamedValue(name=\"tracked\", value=42)\n    print(\"Initial metadata:\", value.metadata)\n\n    value.force_set_value(43)\n    print(\"Metadata after update:\", value.metadata)\n\n    # Test serialization with metadata\n    print(\"\\nTesting enhanced serialization:\")\n    print(value.model_dump_json(indent=2))\n\nif __name__ == \"__main__\":\n    test_extended_features()\n</code></pre> This extended version shows:</p> <p>Additional states for more complex scenarios Metadata tracking for value changes Expiring values Pending state for async operations Enhanced error handling Rich serialization format</p>"},{"location":"for_reference/python_metaclasses/","title":"Python Metaclasses Guide","text":""},{"location":"for_reference/python_metaclasses/#core-concepts","title":"Core Concepts","text":"<ol> <li>A metaclass is a class for a class - it allows you to customize class creation</li> <li>Metaclasses are called when a class is defined, not when it's instantiated</li> <li>The metaclass can modify the class definition before it's created</li> </ol>"},{"location":"for_reference/python_metaclasses/#key-rules","title":"Key Rules","text":""},{"location":"for_reference/python_metaclasses/#1-inheritance-rules","title":"1. Inheritance Rules","text":"<ul> <li>Metaclasses are inherited by subclasses</li> <li>If a class has a metaclass, all its subclasses must be compatible with that metaclass</li> <li>When there are multiple metaclasses in the inheritance hierarchy, they must be compatible</li> </ul>"},{"location":"for_reference/python_metaclasses/#2-creation-order","title":"2. Creation Order","text":"<pre><code>class MyMetaclass(type):\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        # 1. __new__ is called first\n        return super().__new__(mcs, name, bases, namespace)\n\n    def __init__(cls, name, bases, namespace, **kwargs):\n        # 2. __init__ is called after __new__\n        super().__init__(name, bases, namespace)\n\n    def __call__(cls, *args, **kwargs):\n        # 3. __call__ is called when creating instances\n        return super().__call__(*args, **kwargs)\n</code></pre>"},{"location":"for_reference/python_metaclasses/#3-declaration-methods","title":"3. Declaration Methods","text":"<pre><code># Method 1: metaclass keyword\nclass MyClass(metaclass=MyMetaclass):\n    pass\n\n# Method 2: inheritance from a class with metaclass\nclass MyMetaclassBase(metaclass=MyMetaclass):\n    pass\nclass MyClass(MyMetaclassBase):\n    pass\n</code></pre>"},{"location":"for_reference/python_metaclasses/#4-common-use-cases","title":"4. Common Use Cases","text":"<pre><code>class RegisterMeta(type):\n    registry = {}\n\n    def __new__(mcs, name, bases, namespace):\n        # Register all classes using this metaclass\n        cls = super().__new__(mcs, name, bases, namespace)\n        mcs.registry[name] = cls\n        return cls\n\nclass ValidatorMeta(type):\n    def __new__(mcs, name, bases, namespace):\n        # Add validation to all methods\n        for key, value in namespace.items():\n            if callable(value):\n                namespace[key] = validate(value)\n        return super().__new__(mcs, name, bases, namespace)\n</code></pre>"},{"location":"for_reference/python_metaclasses/#5-working-with-other-metaclasses","title":"5. Working with Other Metaclasses","text":"<pre><code># Combining metaclasses\nclass CombinedMeta(MetaclassA, MetaclassB):\n    def __new__(mcs, name, bases, namespace):\n        # Call both metaclass's __new__\n        namespace = MetaclassA.__new__(mcs, name, bases, namespace)\n        return MetaclassB.__new__(mcs, name, bases, namespace)\n</code></pre>"},{"location":"for_reference/python_metaclasses/#recommended-references","title":"Recommended References","text":""},{"location":"for_reference/python_metaclasses/#1-official-python-documentation","title":"1. Official Python Documentation","text":"<ul> <li>Python Data Model</li> <li>Custom Metaclasses</li> </ul>"},{"location":"for_reference/python_metaclasses/#2-books","title":"2. Books","text":"<ul> <li>\"Python in a Nutshell\" by Alex Martelli (O'Reilly)</li> <li>\"Fluent Python\" by Luciano Ramalho (O'Reilly)</li> </ul>"},{"location":"for_reference/python_metaclasses/#3-real-world-example","title":"3. Real-world Example","text":"<pre><code>class RandomVariableMeta(type(BaseModel)):\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        # Automatically apply squeezable decorator\n        for method in ['sample', 'pdf', 'cdf']:\n            if method in namespace and callable(namespace[method]):\n                namespace[method] = squeezable(namespace[method])\n        return super().__new__(mcs, name, bases, namespace, **kwargs)\n</code></pre>"},{"location":"for_reference/python_metaclasses/#common-gotchas","title":"Common Gotchas","text":"<ol> <li>Multiple Inheritance: Be careful when combining classes with different metaclasses</li> <li>Order of Operations: Remember metaclass code runs during class definition</li> <li>Performance: Metaclasses can impact class creation performance</li> <li>Complexity: They can make code harder to understand if overused</li> </ol>"},{"location":"for_reference/python_metaclasses/#best-practices","title":"Best Practices","text":"<ol> <li>Use metaclasses sparingly - only when class decorators or inheritance won't suffice</li> <li>Document metaclass behavior clearly</li> <li>Keep metaclass logic simple and focused</li> <li>Consider alternatives like class decorators or descriptors first</li> </ol>"},{"location":"guides/data_handling/","title":"Data Handling Quickstart Guide","text":"<p>This guide demonstrates how to use the <code>data_handlers</code> package for handling random variables and named values.</p>"},{"location":"guides/data_handling/#basic-usage-of-named-values","title":"Basic Usage of Named Values","text":"<pre><code>from process_manager import data_handlers as dh\n\n# Create named values with automatic state management\nname = dh.NamedValue(name=\"name\", value=\"John Doe\")  # Value is set immediately\nage = dh.NamedValue(name=\"age\")  # Value is initially unset\n\n# Check and set values\nprint(name.value)  # Output: \"John Doe\"\ntry:\n    print(age.value)  # Raises ValueError: Value 'age' has not been set yet\nexcept ValueError as e:\n    print(e)\n\n# Set the value for age\nage.value = 25  # Sets and freezes the value\ntry:\n    age.value = 26  # Raises ValueError - value is frozen\nexcept ValueError as e:\n    print(e)  # Output: Value 'age' has already been set and is frozen...\n\n# Use force_set_value to change a frozen value\nage.force_set_value(26)  # Successfully changes the value\nprint(age.value)  # Output: 26\n</code></pre>"},{"location":"guides/data_handling/#managing-named-value-collections","title":"Managing Named Value Collections","text":"<pre><code># Create a hash to store named values\nnv_hash = dh.NamedValueHash()\n\n# Register named values\nnv_hash.register_value(name)\nnv_hash.register_value(age)\n\n# Access values through the hash\nprint(nv_hash.get_raw_value(\"name\"))  # Output: \"John Doe\"\nprint(nv_hash.get_raw_value(\"age\"))   # Output: 26\n\n# Create ordered lists of named values\nnv_list = dh.NamedValueList()\nnv_list.append(name)\nnv_list.append(age)\n\n# Access values by index or name\nprint(nv_list[0].value)  # Output: \"John Doe\"\nprint(nv_list.get_value(\"age\").value)  # Output: 26\n</code></pre>"},{"location":"guides/data_handling/#working-with-random-variables","title":"Working with Random Variables","text":"<pre><code>import numpy as np\n\n# Create random variable distributions\nnormal_dist = dh.NormalDistribution(name=\"height\", mu=170, sigma=10)\nuniform_dist = dh.UniformDistribution(name=\"weight\", low=60, high=90)\ncategories = np.array([\"A\", \"B\", \"C\"])\ncat_dist = dh.CategoricalDistribution(\n    name=\"blood_type\",\n    categories=categories,\n    probabilities=np.array([0.4, 0.1, 0.5])\n)\n\n# Create a hash to store random variables\nrv_hash = dh.RandomVariableHash()\n\n# Register variables and get samples\nheight = normal_dist.register_to_hash(rv_hash, size=5)\nweight = uniform_dist.register_to_hash(rv_hash, size=5)\nblood_type = cat_dist.register_to_hash(rv_hash, size=5)\n\n# View the samples\nprint(f\"Heights: {height.value}\")      # e.g., [168.3, 175.2, 162.1, 171.8, 169.5]\nprint(f\"Weights: {weight.value}\")      # e.g., [75.3, 82.1, 68.4, 71.2, 88.9]\nprint(f\"Blood Types: {blood_type.value}\")  # e.g., ['A', 'C', 'A', 'C', 'C']\n</code></pre>"},{"location":"guides/data_handling/#serialization-and-deserialization","title":"Serialization and Deserialization","text":"<pre><code># Serialize named values hash\nnv_json = nv_hash.model_dump_json(indent=2)\nprint(nv_json)\n</code></pre> <p>Example output: <pre><code>{\n  \"objects\": {\n    \"name\": {\n      \"name\": \"name\",\n      \"type\": \"NamedValue\",\n      \"state\": \"set\",\n      \"stored_value\": \"John Doe\"\n    },\n    \"age\": {\n      \"name\": \"age\",\n      \"type\": \"NamedValue\",\n      \"state\": \"set\",\n      \"stored_value\": 26\n    }\n  }\n}\n</code></pre></p> <pre><code># Serialize random variables hash\nrv_json = rv_hash.model_dump_json(indent=2)\nprint(rv_json)\n</code></pre> <p>Example output: <pre><code>{\n  \"objects\": {\n    \"height\": {\n      \"name\": \"height\",\n      \"type\": \"NormalDistribution\",\n      \"mu\": 170,\n      \"sigma\": 10,\n      \"seed\": null\n    },\n    \"weight\": {\n      \"name\": \"weight\",\n      \"type\": \"UniformDistribution\",\n      \"low\": 60,\n      \"high\": 90,\n      \"seed\": null\n    },\n    \"blood_type\": {\n      \"name\": \"blood_type\",\n      \"type\": \"CategoricalDistribution\",\n      \"categories\": [\"A\", \"B\", \"C\"],\n      \"probabilities\": [0.4, 0.1, 0.5],\n      \"seed\": null\n    }\n  }\n}\n</code></pre></p> <pre><code># Load from serialized data\nnew_nv_hash = dh.NamedValueHash.model_validate_json(nv_json)\nnew_rv_hash = dh.RandomVariableHash.model_validate_json(rv_json)\n\n# Save to and load from files\nwith open(\"nv_hash.json\", \"w\") as f:\n    f.write(nv_hash.model_dump_json(indent=2))\n\nwith open(\"nv_hash.json\", \"r\") as f:\n    loaded_nv_hash = dh.NamedValueHash.model_validate_json(f.read())\n</code></pre>"},{"location":"guides/data_handling/#advanced-named-value-features","title":"Advanced Named Value Features","text":"<pre><code># Type-safe value handling\ninteger_value = dh.NamedValue[int](name=\"count\")  # Explicitly typed as int\ninteger_value.value = 42\n\ntry:\n    integer_value.value = \"not an integer\"  # Raises TypeError\nexcept TypeError as e:\n    print(e)\n\n# Working with collections\nvalues_list = dh.NamedValueList()\ninteger_value.append_to_value_list(values_list)  # Method chaining\nvalues_list.append(dh.NamedValue(\"price\", 10.99))\n\n# Iterate over values\nfor value in values_list.get_values():\n    print(f\"{value.name}: {value.value}\")\n\n# Filter values by type\nnumber_values = values_list.get_value_by_type(int)\n</code></pre>"},{"location":"guides/data_handling/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use type hints with NamedValue for better type safety: <pre><code>temperature = dh.NamedValue[float](name=\"temp\")\nname = dh.NamedValue[str](name=\"user_name\")\n</code></pre></p> </li> <li> <p>Handle unset values appropriately: <pre><code>value = dh.NamedValue(name=\"example\")\nif value._state == dh.NamedValueState.UNSET:\n    # Handle unset value case\n    value.value = default_value\n</code></pre></p> </li> <li> <p>Use force_set_value() sparingly and only when you need to override frozen values: <pre><code># Prefer setting values once\nconfig = dh.NamedValue(name=\"config\", value=initial_config)\n\n# Only use force_set_value when absolutely necessary\nif needs_update:\n    config.force_set_value(new_config)\n</code></pre></p> </li> <li> <p>Leverage the built-in serialization for persistence: <pre><code># Save state\nsaved_state = value.model_dump_json()\n\n# Restore state\nrestored_value = dh.NamedValue.model_validate_json(saved_state)\n</code></pre></p> </li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>process_manager<ul> <li>data_handlers<ul> <li>base</li> <li>custom_serde_definitions<ul> <li>pandantic</li> </ul> </li> <li>mixins</li> <li>random_variables</li> <li>values</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/process_manager/","title":"process_manager","text":""},{"location":"reference/process_manager/#process_manager","title":"process_manager","text":"<p>Tools for managing processes and doing them in parallel</p>"},{"location":"reference/process_manager/data_handlers/","title":"data_handlers","text":""},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers","title":"data_handlers","text":"<p>Data handlers for the process manager.</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution","title":"CategoricalDistribution","text":"<p>               Bases: <code>RandomVariable[T]</code></p> <p>Categorical distribution for discrete outcomes with specified probabilities.</p> <p>A categorical distribution (also called a discrete distribution) describes the probability of obtaining one of k possible outcomes. Each outcome has a probability between 0 and 1, and all probabilities must sum to 1.</p> <p>If probabilities are not specified, defaults to equal probabilities for all categories (uniform discrete distribution).</p> Key Properties <ul> <li>Support is finite set of categories</li> <li>PMF gives probability of each category</li> <li>CDF is step function</li> </ul> <p>Attributes:</p> Name Type Description <code>categories</code> <code>ndarray</code> <p>Array of possible outcomes (any type)</p> <code>probabilities</code> <code>ndarray</code> <p>Probability for each category</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p> <code>replace</code> <code>bool</code> <p>Whether or not to allow multiple draws of the same value (allowed if True)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If probabilities don't sum to 1</p> <code>ValueError</code> <p>If lengths of categories and probabilities don't match</p> <code>ValueError</code> <p>If any probability is negative</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the cumulative distribution function.</p> <p>For categorical distributions, this is a step function that increases at each category by that category's probability.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the cumulative distribution function.\n\n    For categorical distributions, this is a step function that\n    increases at each category by that category's probability.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return np.array([\n        np.sum(self.probabilities[self.categories &lt;= val])\n        for val in x\n    ])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the probability mass function (PMF).</p> <p>For categorical distributions, this gives the probability of each category occurring.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PMF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Probability of each input value</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the probability mass function (PMF).\n\n    For categorical distributions, this gives the probability of\n    each category occurring.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PMF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Probability of each input value\n    \"\"\"\n    return np.array([\n        self.probabilities[self.categories == val].item()\n        if val in self.categories else 0.0\n        for val in x\n    ])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Generate random samples from the categorical distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate. Defaults to 1.</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> Notes <p>The squeeze parameter is added automatically by the metaclass and does not appear in the function signature, but can be passed as a keyword argument.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>NDArray[Any,T]: Array of samples from the categories</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any,T]:\n    \"\"\"Generate random samples from the categorical distribution.\n\n    Args:\n        size (int, optional): Number of samples to generate. Defaults to 1.\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Notes:\n        The squeeze parameter is added automatically by the metaclass and does not appear\n        in the function signature, but can be passed as a keyword argument.\n\n    Returns:\n        NDArray[Any,T]: Array of samples from the categories\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.choice(self.categories, size=size, p=self.probabilities, replace=self.replace)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution.validate_and_set_probabilities","title":"validate_and_set_probabilities","text":"<pre><code>validate_and_set_probabilities() -&gt; CategoricalDistribution\n</code></pre> <p>Validate probability values and set defaults if needed.</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>@model_validator(mode='after')\ndef validate_and_set_probabilities(self) -&gt; CategoricalDistribution:\n    \"\"\"Validate probability values and set defaults if needed.\"\"\"\n    if self.probabilities is None:\n        n_categories = len(self.categories)\n        self.probabilities = np.ones(n_categories) / n_categories\n        return self\n\n    if len(self.categories) != len(self.probabilities):\n        raise ValueError(\n            f\"Number of categories ({len(self.categories)}) must match \"\n            f\"number of probabilities ({len(self.probabilities)})\"\n        )\n    if not np.all(self.probabilities &gt;= 0):\n        raise ValueError(\"All probabilities must be non-negative\")\n    if not np.isclose(np.sum(self.probabilities), 1.0):\n        raise ValueError(\"Probabilities must sum to 1\")\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObject","title":"NamedObject","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for named objects with serialization support.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Name of object class type (computed field)</p> <code>name</code> <code>str</code> <p>Name of the object</p> Configuration <p>model_config (ConfigDict): Pydantic model configuration</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObject.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>Returns the name of the object type.</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObject.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(*, registry_category: str = None, **kwargs)\n</code></pre> <p>Register subclasses in appropriate registry category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init_subclass__(cls, *, registry_category: str = None, **kwargs):\n    \"\"\"Register subclasses in appropriate registry category.\"\"\"\n    super().__init_subclass__(**kwargs)\n    if registry_category:\n        cls._registry_category = registry_category\n    ObjectRegistry.register(cls._registry_category, cls)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash","title":"NamedObjectHash","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dictionary of named objects with type checking and conflict prevention.</p> <p>Attributes:</p> Name Type Description <code>objects</code> <code>dict</code> <p>Dictionary of named objects</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.deserialize_objects","title":"deserialize_objects  <code>classmethod</code>","text":"<pre><code>deserialize_objects(data: Any) -&gt; Any\n</code></pre> <p>Deserialize objects during validation.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@model_validator(mode='before')\n@classmethod\ndef deserialize_objects(cls, data: Any) -&gt; Any:\n    \"\"\"Deserialize objects during validation.\"\"\"\n    if not isinstance(data, dict):\n        return data\n\n    objects = data.get('objects', {})\n    if isinstance(objects, dict):\n        for name, obj_data in objects.items():\n            if isinstance(obj_data, dict):\n                type_name = obj_data.get('type')\n                if type_name:\n                    # Remove type as it's not part of the constructor\n                    obj_data = obj_data.copy()\n                    obj_data.pop('type')\n                    obj_type = ObjectRegistry.get(cls._registry_category, type_name)\n                    data['objects'][name] = obj_type(**obj_data)\n    return data\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.get_object","title":"get_object","text":"<pre><code>get_object(name: str) -&gt; NamedObject\n</code></pre> <p>Get object by name.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_object(self, name: str) -&gt; NamedObject:\n    \"\"\"Get object by name.\"\"\"\n    return self.objects[name]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.get_object_names","title":"get_object_names","text":"<pre><code>get_object_names() -&gt; Iterable[str]\n</code></pre> <p>Get names of all objects.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_object_names(self) -&gt; Iterable[str]:\n    \"\"\"Get names of all objects.\"\"\"\n    return self.objects.keys()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.get_objects","title":"get_objects","text":"<pre><code>get_objects() -&gt; Iterable[NamedObject]\n</code></pre> <p>Get all objects.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_objects(self) -&gt; Iterable[NamedObject]:\n    \"\"\"Get all objects.\"\"\"\n    return self.objects.values()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.register_object","title":"register_object","text":"<pre><code>register_object(obj: NamedObject) -&gt; Self\n</code></pre> <p>Register a named object. Checks for naming conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>NamedObject</code> <p>Object to register</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If object with same name exists</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def register_object(self, obj: NamedObject) -&gt; Self:\n    \"\"\"\n    Register a named object. Checks for naming conflicts.\n\n    Args:\n        obj (NamedObject): Object to register\n\n    Raises:\n        ValueError: If object with same name exists\n    \"\"\"\n    if obj.name in self.objects:\n        raise ValueError(\n            f\"Naming conflict: An object named '{obj.name}' already exists.\"\n            f\"\\n\\tExisting: \\n{self.get_object(obj.name).model_dump_json(indent=4)}\"\n            f\"\\n\\tNew: \\n{obj.model_dump_json(indent=4)}\"\n        )\n    self.objects[obj.name] = obj\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList","title":"NamedObjectList","text":"<p>               Bases: <code>BaseModel</code></p> <p>List of named objects with type checking.</p> <p>Attributes:</p> Name Type Description <code>objects</code> <code>list</code> <p>List of named objects</p> Example <pre><code>obj_list = NamedObjectList()\nobj_list.append(named_object)\nobj_list.extend([obj1, obj2, obj3])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NamedObject\n</code></pre> <p>Get object by index.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NamedObject:\n    \"\"\"Get object by index.\"\"\"\n    return self.objects[idx]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterable[NamedObject]\n</code></pre> <p>Iterate over objects in list.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __iter__(self) -&gt; Iterable[NamedObject]:\n    \"\"\"Iterate over objects in list.\"\"\"\n    return iter(self.objects)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of objects in list.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of objects in list.\"\"\"\n    return len(self.objects)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.append","title":"append","text":"<pre><code>append(obj: NamedObject) -&gt; Self\n</code></pre> <p>Append a single object to the list.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>NamedObject</code> <p>Object to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def append(self, obj: NamedObject) -&gt; Self:\n    \"\"\"\n    Append a single object to the list.\n\n    Args:\n        obj (NamedObject): Object to append\n\n    Returns:\n        Self: Returns self for chaining\n    \"\"\"\n    self.objects.append(obj)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.extend","title":"extend","text":"<pre><code>extend(objects: Iterable[NamedObject]) -&gt; Self\n</code></pre> <p>Extend list with multiple objects.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>Iterable[NamedObject]</code> <p>Objects to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def extend(self, objects: Iterable[NamedObject]) -&gt; Self:\n    \"\"\"\n    Extend list with multiple objects.\n\n    Args:\n        objects (Iterable[NamedObject]): Objects to add\n\n    Returns:\n        Self: Returns self for chaining\n    \"\"\"\n    self.objects.extend(objects)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(iterable: Iterable[NamedObject]) -&gt; Self\n</code></pre> <p>Create instance from an iterable of named objects.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[NamedObject]</code> <p>Objects to add to list</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>New instance containing the objects</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef from_iterable(cls, iterable: Iterable[NamedObject]) -&gt; Self:\n    \"\"\"\n    Create instance from an iterable of named objects.\n\n    Args:\n        iterable (Iterable[NamedObject]): Objects to add to list\n\n    Returns:\n        Self: New instance containing the objects\n    \"\"\"\n    return cls(objects=list(iterable))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue","title":"NamedValue","text":"<pre><code>NamedValue(name: str, value: T | None = None, **data)\n</code></pre> <p>               Bases: <code>NamedObject</code>, <code>Generic[T]</code></p> <p>A named value container with type safety and state management.</p> <p>NamedValue provides a type-safe way to store and manage values with built-in state tracking, serialization, and validation. Values can be frozen after initial setting to prevent accidental modification.</p> Type Parameters <p>T: The type of value to store, must be a SerializableValue</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for the value</p> <code>_stored_value</code> <code>T | NamedValueState</code> <p>The actual stored value or UNSET state</p> <code>_state</code> <code>NamedValueState</code> <p>Current state of the value</p> <code>_type</code> <code>type</code> <p>Runtime type information for validation</p> Properties <p>value (T): Access or modify the stored value</p> Example <pre><code># Create a named integer value\ncount = NamedValue[int](\"item_count\")\ncount.value = 42  # Sets and freezes the value\nprint(count.value)  # Outputs: 42\ncount.value = 50  # Raises ValueError - value is frozen\ncount.force_set_value(50)  # Allows value change\n</code></pre> <p>Initialize a new NamedValue instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for this value</p> required <code>value</code> <code>T | None</code> <p>Initial value to store. Defaults to None.</p> <code>None</code> <code>**data</code> <p>Additional keyword arguments passed to parent class</p> <code>{}</code> Note <p>If value is provided, it will be validated and set immediately. The value will be frozen after initial setting.</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __init__(self, name: str, value: T | None = None, **data):\n    \"\"\"\n    Initialize a new NamedValue instance.\n\n    Args:\n        name (str): Unique identifier for this value\n        value (T | None, optional): Initial value to store. Defaults to None.\n        **data: Additional keyword arguments passed to parent class\n\n    Note:\n        If value is provided, it will be validated and set immediately.\n        The value will be frozen after initial setting.\n    \"\"\"\n    data.pop('stored_value', None)\n    data.pop('_stored_value', None)\n\n    super().__init__(name=name, **data)\n    self._type = self._extract_value_type()\n    object.__setattr__(self, '_stored_value', NamedValueState.UNSET)  # Explicitly set initial value\n\n    if value is not None:\n        self.value = value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: T\n</code></pre> <p>Get the stored value.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The currently stored value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to access before a value has been set</p> Note <p>This property provides read access to the stored value. Once set, the value is frozen and can only be changed using force_set_value().</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> <p>Prevent direct modification of protected attributes.</p> <p>Overrides attribute setting to prevent direct modification of internal state attributes. These attributes should only be modified through appropriate methods.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the attribute to set</p> required <code>value</code> <code>Any</code> <p>Value to set</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If attempting to modify protected attributes directly</p> Example <pre><code>value = NamedValue(\"example\")\nvalue._stored_value = 42  # Raises AttributeError\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    \"\"\"\n    Prevent direct modification of protected attributes.\n\n    Overrides attribute setting to prevent direct modification of internal\n    state attributes. These attributes should only be modified through\n    appropriate methods.\n\n    Args:\n        name (str): Name of the attribute to set\n        value (Any): Value to set\n\n    Raises:\n        AttributeError: If attempting to modify protected attributes directly\n\n    Example:\n        ```python\n        value = NamedValue(\"example\")\n        value._stored_value = 42  # Raises AttributeError\n        ```\n    \"\"\"\n    if name in ('_stored_value', '_state'):\n        raise AttributeError(f\"Cannot modify {name} directly. Use appropriate methods instead.\")\n    super().__setattr__(name, value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.append_to_value_list","title":"append_to_value_list","text":"<pre><code>append_to_value_list(l: NamedValueList) -&gt; Self\n</code></pre> <p>Appends this value instance to a NamedValueList.</p> <p>Convenience method for adding this value to a list while enabling method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>NamedValueList</code> <p>The list to append this value to</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>This instance for method chaining</p> Example <pre><code>value_list = NamedValueList()\nvalue = NamedValue(\"example\", 42)\nvalue.append_to_value_list(value_list).force_set_value(43)\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def append_to_value_list(self, l: NamedValueList) -&gt; Self:\n    \"\"\"\n    Appends this value instance to a NamedValueList.\n\n    Convenience method for adding this value to a list while enabling\n    method chaining.\n\n    Args:\n        l (NamedValueList): The list to append this value to\n\n    Returns:\n        Self: This instance for method chaining\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value = NamedValue(\"example\", 42)\n        value.append_to_value_list(value_list).force_set_value(43)\n        ```\n    \"\"\"\n    l.append(self)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.force_set_value","title":"force_set_value","text":"<pre><code>force_set_value(new_value: T) -&gt; None\n</code></pre> <p>Force set the value regardless of its current state.</p> <p>This method bypasses the normal freezing mechanism and allows changing an already-set value.</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>T</code> <p>New value to store</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If value doesn't match the expected type T</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def force_set_value(self, new_value: T) -&gt; None:\n    \"\"\"\n    Force set the value regardless of its current state.\n\n    This method bypasses the normal freezing mechanism and allows\n    changing an already-set value.\n\n    Args:\n        new_value (T): New value to store\n\n    Raises:\n        TypeError: If value doesn't match the expected type T\n    \"\"\"\n    object.__setattr__(self, '_stored_value', NamedValueState.UNSET)\n    object.__setattr__(self, '_state', NamedValueState.UNSET)\n    self.value = new_value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs) -&gt; dict[str, Any]\n</code></pre> <p>Custom serialization to include value state and stored value.</p> <p>Extends the parent class serialization to include the value's state and stored value (if set) in the serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional arguments passed to parent serialization</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary containing serialized state</p> Example <pre><code>value = NamedValue(\"example\", 42)\ndata = value.model_dump()\nprint(data)  # Contains 'state' and 'stored_value'\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"\n    Custom serialization to include value state and stored value.\n\n    Extends the parent class serialization to include the value's state\n    and stored value (if set) in the serialized data.\n\n    Args:\n        **kwargs: Additional arguments passed to parent serialization\n\n    Returns:\n        dict[str, Any]: Dictionary containing serialized state\n\n    Example:\n        ```python\n        value = NamedValue(\"example\", 42)\n        data = value.model_dump()\n        print(data)  # Contains 'state' and 'stored_value'\n        ```\n    \"\"\"\n    data = super().model_dump(**kwargs)\n    data['state'] = self._state\n    if self._state == NamedValueState.SET:\n        data['stored_value'] = self._stored_value\n    return data\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(**kwargs) -&gt; str\n</code></pre> <p>Custom JSON serialization of the named value.</p> <p>Serializes the named value instance to a JSON string, including all state information and stored value.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>JSON serialization options like indent, ensure_ascii, etc.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON string representation</p> Example <pre><code>value = NamedValue(\"example\", 42)\njson_str = value.model_dump_json(indent=2)\nprint(json_str)  # Pretty-printed JSON\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Custom JSON serialization of the named value.\n\n    Serializes the named value instance to a JSON string, including\n    all state information and stored value.\n\n    Args:\n        **kwargs: JSON serialization options like indent, ensure_ascii, etc.\n\n    Returns:\n        str: JSON string representation\n\n    Example:\n        ```python\n        value = NamedValue(\"example\", 42)\n        json_str = value.model_dump_json(indent=2)\n        print(json_str)  # Pretty-printed JSON\n        ```\n    \"\"\"\n    # Separate JSON-specific kwargs from model_dump kwargs\n    json_kwargs = {k: v for k, v in kwargs.items() if k in {'indent', 'ensure_ascii', 'separators'}}\n    dump_kwargs = {k: v for k, v in kwargs.items() if k not in json_kwargs}\n\n    # Get model data with stored value\n    data = self.model_dump(**dump_kwargs)\n    return json.dumps(data, **json_kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(data: Any) -&gt; NamedValue\n</code></pre> <p>Custom deserialization to restore value state and stored value.</p> <p>Reconstructs a NamedValue instance from serialized data, properly restoring both the value state and any stored value.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Serialized data to deserialize</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>New instance with restored state</p> Example <pre><code>data = {'name': 'example', 'state': 'set', 'stored_value': 42}\nvalue = NamedValue.model_validate(data)\nprint(value.value)  # Outputs: 42\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate(cls, data: Any) -&gt; NamedValue:\n    \"\"\"\n    Custom deserialization to restore value state and stored value.\n\n    Reconstructs a NamedValue instance from serialized data, properly\n    restoring both the value state and any stored value.\n\n    Args:\n        data (Any): Serialized data to deserialize\n\n    Returns:\n        NamedValue: New instance with restored state\n\n    Example:\n        ```python\n        data = {'name': 'example', 'state': 'set', 'stored_value': 42}\n        value = NamedValue.model_validate(data)\n        print(value.value)  # Outputs: 42\n        ```\n    \"\"\"\n    if not isinstance(data, dict):\n        return super().model_validate(data)\n\n    data_copy = data.copy()\n    state = NamedValueState(data_copy.pop('state', NamedValueState.UNSET))\n    stored_value = data_copy.pop('stored_value', None)\n\n    instance = super().model_validate(data_copy)\n\n    # Only set the value if state was SET\n    if state == NamedValueState.SET and stored_value is not None:\n        instance.force_set_value(stored_value)\n\n    return instance\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str, **kwargs) -&gt; NamedValue\n</code></pre> <p>Custom JSON deserialization to NamedValue instance.</p> <p>Reconstructs a NamedValue instance from a JSON string representation, restoring all state and stored value information.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>str</code> <p>JSON string to deserialize</p> required <code>**kwargs</code> <p>Additional validation options</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>New instance with restored state</p> Example <pre><code>json_str = '{\"name\": \"example\", \"state\": \"set\", \"stored_value\": 42}'\nvalue = NamedValue.model_validate_json(json_str)\nprint(value.value)  # Outputs: 42\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate_json(cls, json_data: str, **kwargs) -&gt; NamedValue:\n    \"\"\"\n    Custom JSON deserialization to NamedValue instance.\n\n    Reconstructs a NamedValue instance from a JSON string representation,\n    restoring all state and stored value information.\n\n    Args:\n        json_data (str): JSON string to deserialize\n        **kwargs: Additional validation options\n\n    Returns:\n        NamedValue: New instance with restored state\n\n    Example:\n        ```python\n        json_str = '{\"name\": \"example\", \"state\": \"set\", \"stored_value\": 42}'\n        value = NamedValue.model_validate_json(json_str)\n        print(value.value)  # Outputs: 42\n        ```\n    \"\"\"\n    data = json.loads(json_data)\n    return cls.model_validate(data, **kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.register_to_value_hash","title":"register_to_value_hash","text":"<pre><code>register_to_value_hash(h: NamedValueHash) -&gt; Self\n</code></pre> <p>Registers this value instance in a NamedValueHash.</p> <p>Registers this value in the provided hash container. If the hash contains value overrides, this value's current value may be overridden during registration.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>NamedValueHash</code> <p>The hash to register this value in</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>This instance for method chaining</p> Example <pre><code>value_hash = NamedValueHash()\nvalue = NamedValue(\"example\", 42)\nvalue.register_to_value_hash(value_hash).force_set_value(43)\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_to_value_hash(self, h: NamedValueHash) -&gt; Self:\n    \"\"\"\n    Registers this value instance in a NamedValueHash.\n\n    Registers this value in the provided hash container. If the hash contains\n    value overrides, this value's current value may be overridden during\n    registration.\n\n    Args:\n        h (NamedValueHash): The hash to register this value in\n\n    Returns:\n        Self: This instance for method chaining\n\n    Example:\n        ```python\n        value_hash = NamedValueHash()\n        value = NamedValue(\"example\", 42)\n        value.register_to_value_hash(value_hash).force_set_value(43)\n        ```\n    \"\"\"\n    h.register_value(self)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash","title":"NamedValueHash","text":"<p>               Bases: <code>NamedObjectHash</code></p> <p>A type-safe dictionary for storing and managing NamedValue objects.</p> <p>NamedValueHash provides a dictionary-like interface for managing a collection of NamedValue instances, using their names as keys. It ensures type safety and provides convenient methods for accessing and managing the stored values.</p> <p>The hash maintains unique naming across all stored values and supports serialization/deserialization of the entire collection.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category identifier for object registration</p> <code>model_config</code> <code>ConfigDict</code> <p>Pydantic configuration for model behavior</p> Example <pre><code>value_hash = NamedValueHash()\nvalue_hash.register_value(NamedValue(\"count\", 42))\nprint(value_hash.get_raw_value(\"count\"))  # Outputs: 42\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_raw_value","title":"get_raw_value","text":"<pre><code>get_raw_value(name: str) -&gt; Any\n</code></pre> <p>Get the underlying value by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to retrieve</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The actual value stored in the named value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> <code>ValueError</code> <p>If the value hasn't been set yet</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"price\", 10.99))\nprint(hash.get_raw_value(\"price\"))  # Outputs: 10.99\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_raw_value(self, name: str) -&gt; Any:\n    \"\"\"\n    Get the underlying value by name.\n\n    Args:\n        name (str): Name of the value to retrieve\n\n    Returns:\n        Any: The actual value stored in the named value\n\n    Raises:\n        KeyError: If no value exists with the given name\n        ValueError: If the value hasn't been set yet\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"price\", 10.99))\n        print(hash.get_raw_value(\"price\"))  # Outputs: 10.99\n        ```\n    \"\"\"\n    return self.get_value(name).value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_raw_values","title":"get_raw_values","text":"<pre><code>get_raw_values() -&gt; Iterable[Any]\n</code></pre> <p>Get the underlying values of all named values.</p> <p>Returns:</p> Type Description <code>Iterable[Any]</code> <p>Iterable[Any]: Iterator over the actual values stored in each NamedValue</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\nhash.register_value(NamedValue(\"y\", 2))\nprint(list(hash.get_raw_values()))  # Outputs: [1, 2]\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_raw_values(self) -&gt; Iterable[Any]:\n    \"\"\"\n    Get the underlying values of all named values.\n\n    Returns:\n        Iterable[Any]: Iterator over the actual values stored in each NamedValue\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        hash.register_value(NamedValue(\"y\", 2))\n        print(list(hash.get_raw_values()))  # Outputs: [1, 2]\n        ```\n    \"\"\"\n    return (val.value for val in self.get_values())\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_value","title":"get_value","text":"<pre><code>get_value(name: str) -&gt; NamedValue\n</code></pre> <p>Retrieve a named value by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to retrieve</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The requested named value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"price\", 10.99))\nprice = hash.get_value(\"price\")\nprint(price.value)  # Outputs: 10.99\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value(self, name: str) -&gt; NamedValue:\n    \"\"\"\n    Retrieve a named value by its name.\n\n    Args:\n        name (str): Name of the value to retrieve\n\n    Returns:\n        NamedValue: The requested named value\n\n    Raises:\n        KeyError: If no value exists with the given name\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"price\", 10.99))\n        price = hash.get_value(\"price\")\n        print(price.value)  # Outputs: 10.99\n        ```\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_value_by_type","title":"get_value_by_type","text":"<pre><code>get_value_by_type(value_type: Type) -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all values of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>Type</code> <p>Type to filter values by</p> required <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: Values matching the specified type</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\nhash.register_value(NamedValue(\"name\", \"test\"))\nintegers = list(hash.get_value_by_type(int))\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value_by_type(self, value_type: Type) -&gt; Iterable[NamedValue]:\n    \"\"\"\n    Get all values of a specific type.\n\n    Args:\n        value_type (Type): Type to filter values by\n\n    Returns:\n        Iterable[NamedValue]: Values matching the specified type\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        hash.register_value(NamedValue(\"name\", \"test\"))\n        integers = list(hash.get_value_by_type(int))\n        ```\n    \"\"\"\n    return [val for val in self.get_values() if isinstance(val, value_type)]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_value_names","title":"get_value_names","text":"<pre><code>get_value_names() -&gt; Iterable[str]\n</code></pre> <p>Get names of all registered values.</p> <p>Returns:</p> Type Description <code>Iterable[str]</code> <p>Iterable[str]: An iterator over all value names</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\nhash.register_value(NamedValue(\"y\", 2))\nprint(list(hash.get_value_names()))  # Outputs: ['x', 'y']\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value_names(self) -&gt; Iterable[str]:\n    \"\"\"\n    Get names of all registered values.\n\n    Returns:\n        Iterable[str]: An iterator over all value names\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        hash.register_value(NamedValue(\"y\", 2))\n        print(list(hash.get_value_names()))  # Outputs: ['x', 'y']\n        ```\n    \"\"\"\n    return self.get_object_names()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_values","title":"get_values","text":"<pre><code>get_values() -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all registered named values.</p> <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: An iterator over all stored named values</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\nhash.register_value(NamedValue(\"y\", 2))\nfor value in hash.get_values():\n    print(f\"{value.name}: {value.value}\")\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_values(self) -&gt; Iterable[NamedValue]:\n    \"\"\"\n    Get all registered named values.\n\n    Returns:\n        Iterable[NamedValue]: An iterator over all stored named values\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        hash.register_value(NamedValue(\"y\", 2))\n        for value in hash.get_values():\n            print(f\"{value.name}: {value.value}\")\n        ```\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs) -&gt; dict[str, Any]\n</code></pre> <p>Custom serialization to preserve stored values and their states.</p> <p>Creates a dictionary representation of the hash that includes full serialization of all contained NamedValue objects, preserving their values and states.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional serialization options passed to all nested objects</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary containing the complete hash state</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\ndata = hash.model_dump()\nprint(data['objects']['x']['stored_value'])  # Outputs: 1\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"\n    Custom serialization to preserve stored values and their states.\n\n    Creates a dictionary representation of the hash that includes full\n    serialization of all contained NamedValue objects, preserving their\n    values and states.\n\n    Args:\n        **kwargs: Additional serialization options passed to all nested objects\n\n    Returns:\n        dict[str, Any]: Dictionary containing the complete hash state\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        data = hash.model_dump()\n        print(data['objects']['x']['stored_value'])  # Outputs: 1\n        ```\n    \"\"\"\n    data = super().model_dump(**kwargs)\n    # Ensure each object's stored value is included\n    if 'objects' in data:\n        for name, obj in self.objects.items():\n            if isinstance(obj, NamedValue):\n                # Get the full dump including stored value\n                obj_data = obj.model_dump(**kwargs)\n                data['objects'][name] = obj_data\n    return data\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(**kwargs) -&gt; str\n</code></pre> <p>Custom JSON serialization of the entire hash.</p> <p>Serializes the NamedValueHash instance and all contained NamedValue objects to a JSON string representation. Handles both the hash structure and the nested value serialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>JSON serialization options such as: - indent: Number of spaces for pretty printing - ensure_ascii: Escape non-ASCII characters - separators: Tuple of (item_sep, key_sep) for custom formatting</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON string representation of the hash</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\njson_str = hash.model_dump_json(indent=2)\nprint(json_str)  # Pretty-printed JSON with nested values\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Custom JSON serialization of the entire hash.\n\n    Serializes the NamedValueHash instance and all contained NamedValue\n    objects to a JSON string representation. Handles both the hash structure\n    and the nested value serialization.\n\n    Args:\n        **kwargs: JSON serialization options such as:\n            - indent: Number of spaces for pretty printing\n            - ensure_ascii: Escape non-ASCII characters\n            - separators: Tuple of (item_sep, key_sep) for custom formatting\n\n    Returns:\n        str: JSON string representation of the hash\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        json_str = hash.model_dump_json(indent=2)\n        print(json_str)  # Pretty-printed JSON with nested values\n        ```\n    \"\"\"\n    # Separate JSON-specific kwargs from model_dump kwargs\n    json_kwargs = {k: v for k, v in kwargs.items() if k in {'indent', 'ensure_ascii', 'separators'}}\n    dump_kwargs = {k: v for k, v in kwargs.items() if k not in json_kwargs}\n\n    # Get model data\n    data = self.model_dump(**dump_kwargs)\n    # Serialize to JSON\n    return json.dumps(data, **json_kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(data: Any) -&gt; NamedValueHash\n</code></pre> <p>Custom validation to restore hash state from serialized data.</p> <p>Reconstructs a NamedValueHash instance from serialized data, including all contained NamedValue objects with their values and states.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Serialized data to deserialize. Should be a dictionary containing an 'objects' key with serialized NamedValue instances</p> required <p>Returns:</p> Name Type Description <code>NamedValueHash</code> <code>NamedValueHash</code> <p>New instance with all values restored</p> Example <pre><code>data = {\n    'objects': {\n        'x': {'name': 'x', 'type': 'NamedValue', 'stored_value': 1}\n    }\n}\nhash = NamedValueHash.model_validate(data)\nprint(hash.get_raw_value('x'))  # Outputs: 1\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate(cls, data: Any) -&gt; NamedValueHash:\n    \"\"\"\n    Custom validation to restore hash state from serialized data.\n\n    Reconstructs a NamedValueHash instance from serialized data, including\n    all contained NamedValue objects with their values and states.\n\n    Args:\n        data (Any): Serialized data to deserialize. Should be a dictionary\n            containing an 'objects' key with serialized NamedValue instances\n\n    Returns:\n        NamedValueHash: New instance with all values restored\n\n    Example:\n        ```python\n        data = {\n            'objects': {\n                'x': {'name': 'x', 'type': 'NamedValue', 'stored_value': 1}\n            }\n        }\n        hash = NamedValueHash.model_validate(data)\n        print(hash.get_raw_value('x'))  # Outputs: 1\n        ```\n    \"\"\"\n    if not isinstance(data, dict):\n        return super().model_validate(data)\n\n    instance = cls()\n\n    # Process each object in the data\n    for name, obj_data in data.get('objects', {}).items():\n        if isinstance(obj_data, dict):\n            obj_type = obj_data.get('type')\n            if obj_type:\n                # Get the appropriate class from registry\n                value_class = ObjectRegistry.get(cls._registry_category, obj_type)\n                # Create and validate the object with its stored value\n                value_obj = value_class.model_validate(obj_data)\n                instance.register_value(value_obj)\n\n    return instance\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str, **kwargs) -&gt; NamedValueHash\n</code></pre> <p>Custom JSON deserialization to NamedValueHash instance.</p> <p>Reconstructs a NamedValueHash instance from a JSON string representation, including all contained NamedValue objects with their complete state.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>str</code> <p>JSON string containing serialized hash data</p> required <code>**kwargs</code> <p>Additional validation options for nested objects</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NamedValueHash</code> <code>NamedValueHash</code> <p>New instance with all values restored</p> Example <pre><code>json_str = '''\n{\n    \"objects\": {\n        \"x\": {\"name\": \"x\", \"type\": \"NamedValue\", \"stored_value\": 1}\n    }\n}\n'''\nhash = NamedValueHash.model_validate_json(json_str)\nprint(hash.get_raw_value('x'))  # Outputs: 1\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate_json(cls, json_data: str, **kwargs) -&gt; NamedValueHash:\n    \"\"\"\n    Custom JSON deserialization to NamedValueHash instance.\n\n    Reconstructs a NamedValueHash instance from a JSON string representation,\n    including all contained NamedValue objects with their complete state.\n\n    Args:\n        json_data (str): JSON string containing serialized hash data\n        **kwargs: Additional validation options for nested objects\n\n    Returns:\n        NamedValueHash: New instance with all values restored\n\n    Example:\n        ```python\n        json_str = '''\n        {\n            \"objects\": {\n                \"x\": {\"name\": \"x\", \"type\": \"NamedValue\", \"stored_value\": 1}\n            }\n        }\n        '''\n        hash = NamedValueHash.model_validate_json(json_str)\n        print(hash.get_raw_value('x'))  # Outputs: 1\n        ```\n    \"\"\"\n    data = json.loads(json_data)\n    return cls.model_validate(data, **kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.register_value","title":"register_value","text":"<pre><code>register_value(value: NamedValue) -&gt; Self\n</code></pre> <p>Register a named value in the hash.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>The value to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for method chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a value with the same name already exists</p> Example <pre><code>hash = NamedValueHash()\nvalue = NamedValue(\"price\", 10.99)\nhash.register_value(value).register_value(NamedValue(\"qty\", 5))\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_value(self, value: NamedValue) -&gt; Self:\n    \"\"\"\n    Register a named value in the hash.\n\n    Args:\n        value (NamedValue): The value to register\n\n    Returns:\n        Self: Returns self for method chaining\n\n    Raises:\n        ValueError: If a value with the same name already exists\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        value = NamedValue(\"price\", 10.99)\n        hash.register_value(value).register_value(NamedValue(\"qty\", 5))\n        ```\n    \"\"\"\n    return self.register_object(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.set_raw_value","title":"set_raw_value","text":"<pre><code>set_raw_value(name: str, value: Any) -&gt; None\n</code></pre> <p>Set the underlying value for a named value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to update</p> required <code>value</code> <code>Any</code> <p>New value to set</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> <code>TypeError</code> <p>If value type doesn't match the expected type</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"price\", 10.99))\nhash.set_raw_value(\"price\", 11.99)\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def set_raw_value(self, name: str, value: Any) -&gt; None:\n    \"\"\"\n    Set the underlying value for a named value.\n\n    Args:\n        name (str): Name of the value to update\n        value (Any): New value to set\n\n    Raises:\n        KeyError: If no value exists with the given name\n        TypeError: If value type doesn't match the expected type\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"price\", 10.99))\n        hash.set_raw_value(\"price\", 11.99)\n        ```\n    \"\"\"\n    self.get_value(name).value = value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList","title":"NamedValueList","text":"<p>               Bases: <code>NamedObjectList</code></p> <p>An ordered list container for managing NamedValue objects.</p> <p>NamedValueList maintains an ordered collection of NamedValue objects while providing type safety and convenient access methods. It preserves insertion order while also allowing access by name.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category identifier for object registration</p> <code>objects</code> <code>List[SerializeAsAny[InstanceOf[NamedValue]]]</code> <p>The list of stored values</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(\"first\", 1))\nvalue_list.append(NamedValue(\"second\", 2))\nprint([v.value for v in value_list])  # Outputs: [1, 2]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NamedValue\n</code></pre> <p>Get a named value by its index in the list.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the named value to retrieve</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The named value at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(name=\"price\", value=10.5))\nfirst_value = value_list[0] # Get first named value\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NamedValue:\n    \"\"\"Get a named value by its index in the list.\n\n    Args:\n        idx (int): Index of the named value to retrieve\n\n    Returns:\n        NamedValue: The named value at the specified index\n\n    Raises:\n        IndexError: If the index is out of range\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.append(NamedValue(name=\"price\", value=10.5))\n        first_value = value_list[0] # Get first named value\n        ```\n    \"\"\"\n    return super().__getitem__(idx)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.append","title":"append","text":"<pre><code>append(value: NamedValue) -&gt; Self\n</code></pre> <p>Append a named value to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>Named value to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The list instance for method chaining</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(\"x\", 1)).append(NamedValue(\"y\", 2))\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def append(self, value: NamedValue) -&gt; Self:\n    \"\"\"\n    Append a named value to the end of the list.\n\n    Args:\n        value (NamedValue): Named value to append\n\n    Returns:\n        Self: The list instance for method chaining\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.append(NamedValue(\"x\", 1)).append(NamedValue(\"y\", 2))\n        ```\n    \"\"\"\n    return super().append(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.extend","title":"extend","text":"<pre><code>extend(values: Iterable[NamedValue]) -&gt; Self\n</code></pre> <p>Extend the list with multiple named values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Iterable[NamedValue]</code> <p>Collection of named values to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The list instance for method chaining</p> Example <pre><code>value_list = NamedValueList()\nnew_values = [NamedValue(\"x\", 1), NamedValue(\"y\", 2)]\nvalue_list.extend(new_values)\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def extend(self, values: Iterable[NamedValue]) -&gt; Self:\n    \"\"\"\n    Extend the list with multiple named values.\n\n    Args:\n        values (Iterable[NamedValue]): Collection of named values to add\n\n    Returns:\n        Self: The list instance for method chaining\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        new_values = [NamedValue(\"x\", 1), NamedValue(\"y\", 2)]\n        value_list.extend(new_values)\n        ```\n    \"\"\"\n    return super().extend(values)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.get_value","title":"get_value","text":"<pre><code>get_value(name: str) -&gt; NamedValue\n</code></pre> <p>Get a registered named value by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to retrieve</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The requested named value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(\"x\", 1))\nx = value_list.get_value(\"x\")\nprint(x.value)  # Outputs: 1\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value(self, name: str) -&gt; NamedValue:\n    \"\"\"\n    Get a registered named value by name.\n\n    Args:\n        name (str): Name of the value to retrieve\n\n    Returns:\n        NamedValue: The requested named value\n\n    Raises:\n        KeyError: If no value exists with the given name\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.append(NamedValue(\"x\", 1))\n        x = value_list.get_value(\"x\")\n        print(x.value)  # Outputs: 1\n        ```\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.get_values","title":"get_values","text":"<pre><code>get_values() -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all registered named values.</p> <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: Iterator over all stored named values</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.extend([NamedValue(\"x\", 1), NamedValue(\"y\", 2)])\nfor value in value_list.get_values():\n    print(f\"{value.name}: {value.value}\")\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_values(self) -&gt; Iterable[NamedValue]:\n    \"\"\"\n    Get all registered named values.\n\n    Returns:\n        Iterable[NamedValue]: Iterator over all stored named values\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.extend([NamedValue(\"x\", 1), NamedValue(\"y\", 2)])\n        for value in value_list.get_values():\n            print(f\"{value.name}: {value.value}\")\n        ```\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs) -&gt; dict[str, Any]\n</code></pre> <p>Custom serialization to preserve stored values.</p> <p>Extends the parent class serialization to ensure proper serialization of all stored named values and their states.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional serialization options</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary containing serialized state</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"\n    Custom serialization to preserve stored values.\n\n    Extends the parent class serialization to ensure proper serialization\n    of all stored named values and their states.\n\n    Args:\n        **kwargs: Additional serialization options\n\n    Returns:\n        dict[str, Any]: Dictionary containing serialized state\n    \"\"\"\n    data = super().model_dump(**kwargs)\n    if 'objects' in data:\n        # Ensure each object's stored value is included\n        data['objects'] = [\n            obj.model_dump(**kwargs) if isinstance(obj, NamedValue) else obj\n            for obj in self.objects\n        ]\n    return data\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(**kwargs) -&gt; str\n</code></pre> <p>Custom JSON serialization of the value list.</p> <p>Serializes the NamedValueList instance and all contained NamedValue objects to a JSON string representation. Preserves the order of values and their complete state.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>JSON serialization options such as: - indent: Number of spaces for pretty printing - ensure_ascii: Escape non-ASCII characters - separators: Tuple of (item_sep, key_sep) for custom formatting</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON string representation of the list</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(\"x\", 1))\nvalue_list.append(NamedValue(\"y\", 2))\njson_str = value_list.model_dump_json(indent=2)\nprint(json_str)  # Pretty-printed JSON with ordered values\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Custom JSON serialization of the value list.\n\n    Serializes the NamedValueList instance and all contained NamedValue\n    objects to a JSON string representation. Preserves the order of values\n    and their complete state.\n\n    Args:\n        **kwargs: JSON serialization options such as:\n            - indent: Number of spaces for pretty printing\n            - ensure_ascii: Escape non-ASCII characters\n            - separators: Tuple of (item_sep, key_sep) for custom formatting\n\n    Returns:\n        str: JSON string representation of the list\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.append(NamedValue(\"x\", 1))\n        value_list.append(NamedValue(\"y\", 2))\n        json_str = value_list.model_dump_json(indent=2)\n        print(json_str)  # Pretty-printed JSON with ordered values\n        ```\n    \"\"\"\n    # Separate JSON-specific kwargs from model_dump kwargs\n    json_kwargs = {k: v for k, v in kwargs.items() if k in {'indent', 'ensure_ascii', 'separators'}}\n    dump_kwargs = {k: v for k, v in kwargs.items() if k not in json_kwargs}\n\n    # Get model data\n    data = self.model_dump(**dump_kwargs)\n    # Serialize to JSON\n    return json.dumps(data, **json_kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(data: Any) -&gt; NamedValueList\n</code></pre> <p>Custom validation to restore stored values.</p> <p>Reconstructs a NamedValueList instance from serialized data, properly restoring all contained named values and their states.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Serialized data to deserialize</p> required <p>Returns:</p> Name Type Description <code>NamedValueList</code> <code>NamedValueList</code> <p>New instance with restored values</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate(cls, data: Any) -&gt; NamedValueList:\n    \"\"\"\n    Custom validation to restore stored values.\n\n    Reconstructs a NamedValueList instance from serialized data,\n    properly restoring all contained named values and their states.\n\n    Args:\n        data (Any): Serialized data to deserialize\n\n    Returns:\n        NamedValueList: New instance with restored values\n    \"\"\"\n    if not isinstance(data, dict):\n        return super().model_validate(data)\n\n    instance = cls()\n\n    # Process each object in the data\n    for obj_data in data.get('objects', []):\n        if isinstance(obj_data, dict):\n            obj_type = obj_data.get('type')\n            if obj_type:\n                # Get the appropriate class from registry\n                value_class = ObjectRegistry.get(cls._registry_category, obj_type)\n                # Create and validate the object\n                value_obj = value_class.model_validate(obj_data)\n                instance.append(value_obj)\n\n    return instance\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str, **kwargs) -&gt; NamedValueList\n</code></pre> <p>Custom JSON deserialization to NamedValueList instance.</p> <p>Reconstructs a NamedValueList instance from a JSON string representation, preserving the order of values and restoring their complete state.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>str</code> <p>JSON string containing serialized list data</p> required <code>**kwargs</code> <p>Additional validation options for nested objects</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NamedValueList</code> <code>NamedValueList</code> <p>New instance with all values restored in order</p> Example <pre><code>json_str = '''\n{\n    \"objects\": [\n        {\"name\": \"x\", \"type\": \"NamedValue\", \"stored_value\": 1},\n        {\"name\": \"y\", \"type\": \"NamedValue\", \"stored_value\": 2}\n    ]\n}\n'''\nvalue_list = NamedValueList.model_validate_json(json_str)\nprint([v.value for v in value_list])  # Outputs: [1, 2]\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate_json(cls, json_data: str, **kwargs) -&gt; NamedValueList:\n    \"\"\"\n    Custom JSON deserialization to NamedValueList instance.\n\n    Reconstructs a NamedValueList instance from a JSON string representation,\n    preserving the order of values and restoring their complete state.\n\n    Args:\n        json_data (str): JSON string containing serialized list data\n        **kwargs: Additional validation options for nested objects\n\n    Returns:\n        NamedValueList: New instance with all values restored in order\n\n    Example:\n        ```python\n        json_str = '''\n        {\n            \"objects\": [\n                {\"name\": \"x\", \"type\": \"NamedValue\", \"stored_value\": 1},\n                {\"name\": \"y\", \"type\": \"NamedValue\", \"stored_value\": 2}\n            ]\n        }\n        '''\n        value_list = NamedValueList.model_validate_json(json_str)\n        print([v.value for v in value_list])  # Outputs: [1, 2]\n        ```\n    \"\"\"\n    data = json.loads(json_data)\n    return cls.model_validate(data, **kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.register_value","title":"register_value","text":"<pre><code>register_value(value: NamedValue) -&gt; Self\n</code></pre> <p>Register a named value to the list.</p> <p>Similar to append but uses the register_object method internally, which may perform additional validation.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>Named value to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The list instance for method chaining</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.register_value(NamedValue(\"x\", 1))\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_value(self, value: NamedValue) -&gt; Self:\n    \"\"\"\n    Register a named value to the list.\n\n    Similar to append but uses the register_object method internally,\n    which may perform additional validation.\n\n    Args:\n        value (NamedValue): Named value to register\n\n    Returns:\n        Self: The list instance for method chaining\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.register_value(NamedValue(\"x\", 1))\n        ```\n    \"\"\"\n    return self.register_object(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueState","title":"NamedValueState","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>State enumeration for NamedValue objects.</p> <p>This enum tracks whether a named value has been set or remains unset. Once set, values are typically frozen unless explicitly forced to change.</p> <p>Attributes:</p> Name Type Description <code>UNSET</code> <p>Indicates no value has been set yet</p> <code>SET</code> <p>Indicates value has been set and is frozen</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueState.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Get string representation for debugging.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The state value as a string (\"unset\" or \"set\")</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Get string representation for debugging.\n\n    Returns:\n        str: The state value as a string (\"unset\" or \"set\")\n    \"\"\"\n    return self.value  # Returns just \"unset\" or \"set\"\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueState.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Convert state to string representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The state value as a string (\"unset\" or \"set\")</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Convert state to string representation.\n\n    Returns:\n        str: The state value as a string (\"unset\" or \"set\")\n    \"\"\"\n    return self.value  # Returns just \"unset\" or \"set\"\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NormalDistribution","title":"NormalDistribution","text":"<p>               Bases: <code>RandomVariable[float]</code></p> <p>Normal (Gaussian) distribution with mean \u03bc and standard deviation \u03c3.</p> <p>The normal distribution is a continuous probability distribution that is symmetric about its mean, showing the familiar bell-shaped curve.</p> Key Properties <ul> <li>Symmetric about the mean</li> <li>~68% of values lie within 1\u03c3 of \u03bc</li> <li>~95% lie within 2\u03c3 of \u03bc</li> <li>~99.7% lie within 3\u03c3 of \u03bc</li> </ul> <p>Attributes:</p> Name Type Description <code>mu</code> <code>float</code> <p>Mean (\u03bc) of the distribution</p> <code>sigma</code> <code>float</code> <p>Standard deviation (\u03c3) of the distribution</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NormalDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the normal cumulative distribution function.</p> <p>The CDF is computed using the error function: F(x) = 1/2 * (1 + erf((x-\u03bc)/(\u03c3\u221a2)))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the normal cumulative distribution function.\n\n    The CDF is computed using the error function:\n    F(x) = 1/2 * (1 + erf((x-\u03bc)/(\u03c3\u221a2)))\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return 0.5 * (1 + sp.erf((x - self.mu)/(self.sigma * np.sqrt(2))))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NormalDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the normal probability density function.</p> <p>The PDF is given by: f(x) = 1/(\u03c3\u221a(2\u03c0)) * exp(-(x-\u03bc)\u00b2/(2\u03c3\u00b2))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: PDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the normal probability density function.\n\n    The PDF is given by:\n    f(x) = 1/(\u03c3\u221a(2\u03c0)) * exp(-(x-\u03bc)\u00b2/(2\u03c3\u00b2))\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: PDF values at the input points\n    \"\"\"\n    return 1/(self.sigma * np.sqrt(2*np.pi)) * np.exp(-(x - self.mu)**2 / (2*self.sigma**2))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NormalDistribution.sample","title":"sample","text":"<pre><code>sample(size: int | tuple[int, ...] = 1, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Generate random samples from the normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int | tuple[int, ...]</code> <p>Number or shape of samples</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Array of samples from N(\u03bc, \u03c3)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int | tuple[int, ...] = 1, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Generate random samples from the normal distribution.\n\n    Args:\n        size (int | tuple[int, ...]): Number or shape of samples\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Array of samples from N(\u03bc, \u03c3)\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.normal(self.mu, self.sigma, size=size)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NumericDunders","title":"NumericDunders","text":"<p>A mixin class containing numeric dunder methods that can be applied to any class via composition</p> <p>Attributes:</p> Name Type Description <code>RESERVED_NAME</code> <code>str</code> <p>Name of the reserved attribute that holds the value</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NumericDunders.get_value","title":"get_value  <code>classmethod</code>","text":"<pre><code>get_value(instance)\n</code></pre> <p>Get the value of the instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>Instance of the class</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Value of the instance stored in the reserved attribute or else returns the instance. For example, if the reserved attribute is 'value', then it returns <code>instance.value</code> else if the instance is just a float or an int or something like that, then it returns the instance itself.</p> Source code in <code>src/process_manager/data_handlers/mixins.py</code> <pre><code>@classmethod\ndef get_value(cls, instance):\n    \"\"\"\n    Get the value of the instance\n\n    Args:\n        instance (Any): Instance of the class\n\n    Returns:\n        Any: Value of the instance stored in the reserved attribute or else returns the instance.\n            For example, if the reserved attribute is 'value', then it returns `instance.value` else\n            if the instance is just a float or an int or something like that, then it returns the instance itself.\n    \"\"\"\n    return getattr(instance, cls.RESERVED_NAME, instance)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry","title":"ObjectRegistry","text":"<p>Generic registry for named object types.</p> <p>Stores object types for deserialization from JSON files. Types are stored at the class level for consistent access across modules.</p> <p>Types are stored at the class level for consistent access across modules.</p> <p>Methods:</p> Name Description <code>register</code> <p>Register an object type</p> <code>get</code> <p>Get an object type by name</p> <code>get_all</code> <p>Get all registered object types</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(category: str, name: str) -&gt; Type[NamedObject]\n</code></pre> <p>Get an object type by category and name.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get(cls, category: str, name: str) -&gt; Type[NamedObject]:\n    \"\"\"Get an object type by category and name.\"\"\"\n    registry = cls.get_registry(category)\n    if name not in registry:\n        raise ValueError(f\"{name} not found in {category} registry\")\n    return registry[name]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry.get_all","title":"get_all  <code>classmethod</code>","text":"<pre><code>get_all(category: str) -&gt; list[Type[NamedObject]]\n</code></pre> <p>Get all registered types for a category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get_all(cls, category: str) -&gt; list[Type[NamedObject]]:\n    \"\"\"Get all registered types for a category.\"\"\"\n    return list(cls.get_registry(category).values())\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry.get_registry","title":"get_registry  <code>classmethod</code>","text":"<pre><code>get_registry(category: str) -&gt; Dict[str, Type[NamedObject]]\n</code></pre> <p>Get or create registry for a category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get_registry(cls, category: str) -&gt; Dict[str, Type[NamedObject]]:\n    \"\"\"Get or create registry for a category.\"\"\"\n    # Get the actual string value if it's a PrivateAttr\n    if hasattr(category, 'default'):\n        category = category.default\n    if category not in cls._registries:\n        cls._registries[category] = {}\n    return cls._registries[category]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(category: str, obj_type: Type[NamedObject]) -&gt; None\n</code></pre> <p>Register an object type in its category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef register(cls, category: str, obj_type: Type[NamedObject]) -&gt; None:\n    \"\"\"Register an object type in its category.\"\"\"\n    # Get the actual string value if it's a PrivateAttr\n    if hasattr(category, 'default'):\n        category = category.default\n    registry = cls.get_registry(category)\n    registry[obj_type.__name__] = obj_type\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable","title":"RandomVariable","text":"<p>               Bases: <code>NamedObject</code>, <code>Generic[T]</code></p> <p>Base class for random variables.</p> <p>This class provides a common interface for random variable implementations. Subclasses must implement sample(), pdf(), and cdf() methods. The metaclass ensures these methods support dimension control via the squeeze parameter.</p> <p>The class is generic over the type of values it produces (T), which must be a subtype of SerializableValue to ensure proper serialization behavior.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p> <code>name</code> <code>str</code> <p>Identifier for this random variable instance</p> Type Variables <p>T: The type of values produced by this random variable</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Evaluate cumulative distribution function at specified points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>CDF values at the input points</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Evaluate cumulative distribution function at specified points.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): CDF values at the input points\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Evaluate probability density function at specified points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>PDF values at the input points</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Evaluate probability density function at specified points.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): PDF values at the input points\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable.register_to_hash","title":"register_to_hash","text":"<pre><code>register_to_hash(\n    var_hash: RandomVariableHash, size: int = 1, sample: bool = True, squeeze: bool = True\n) -&gt; NamedValue[T | NDArray[Any, T]]\n</code></pre> <p>Register this random variable to a hash and return sampled values.</p> <p>This is a convenience method for adding a random variable to a collection and immediately sampling from it.</p> <p>Parameters:</p> Name Type Description Default <code>var_hash</code> <code>RandomVariableHash</code> <p>Hash object to register to</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>NamedValue[T | NDArray[Any, T]]</code> <p>Named value containing samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_to_hash(\n        self, \n        var_hash: RandomVariableHash, \n        size: int = 1, \n        sample: bool = True,\n        squeeze: bool = True,\n    ) -&gt; NamedValue[T|NDArray[Any,T]]:\n    \"\"\"Register this random variable to a hash and return sampled values.\n\n    This is a convenience method for adding a random variable to a collection\n    and immediately sampling from it.\n\n    Args:\n        var_hash (RandomVariableHash): Hash object to register to\n        size (int): Number of samples to generate\n\n    Returns:\n        (NamedValue[T|NDArray[Any,T]]): Named value containing samples\n    \"\"\"\n    return var_hash.register_variable(self, size=size, sample=sample, squeeze=squeeze)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Generate random samples from the categorical distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate. Defaults to 1.</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>Array of samples from the categories</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Generate random samples from the categorical distribution.\n\n    Args:\n        size (int): Number of samples to generate. Defaults to 1.\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): Array of samples from the categories\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableHash","title":"RandomVariableHash","text":"<p>               Bases: <code>NamedObjectHash</code></p> <p>Collection of random variables.</p> <p>This class manages a collection of RandomVariable objects, providing methods to register, retrieve and sample from multiple distributions.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableHash.get_variables","title":"get_variables","text":"<pre><code>get_variables() -&gt; Iterable[RandomVariable]\n</code></pre> <p>Get all registered random variables.</p> <p>Returns:</p> Type Description <code>Iterable[RandomVariable]</code> <p>Iterable[RandomVariable]: Iterator over all registered variables</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variables(self) -&gt; Iterable[RandomVariable]:\n    \"\"\"Get all registered random variables.\n\n    Returns:\n        Iterable[RandomVariable]: Iterator over all registered variables\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableHash.register_variable","title":"register_variable","text":"<pre><code>register_variable(\n    var: RandomVariable, size: int = 1, sample: bool = True, squeeze: bool = True\n) -&gt; NamedValue[SerializableValue | NDArray[Any, SerializableValue]]\n</code></pre> <p>Register a random variable and return its samples wrapped in a NamedValue.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>RandomVariable</code> <p>Random variable to register</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>NamedValue[SerializableValue | NDArray[Any, SerializableValue]]</code> <p>NamedValue[SerializableValue|NDArray[Any,SerializableValue]]: Named value containing samples</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a variable with the same name already exists</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_variable(\n        self, \n        var: RandomVariable, \n        size: int = 1,\n        sample: bool = True,\n        squeeze: bool = True,\n    ) -&gt; NamedValue[SerializableValue|NDArray[Any,SerializableValue]]:\n    \"\"\"Register a random variable and return its samples wrapped in a NamedValue.\n\n    Args:\n        var (RandomVariable): Random variable to register\n        size (int): Number of samples to generate\n\n    Returns:\n        NamedValue[SerializableValue|NDArray[Any,SerializableValue]]: Named value containing samples\n\n    Raises:\n        ValueError: If a variable with the same name already exists\n    \"\"\"\n    if var.name in self.objects:\n        raise ValueError(f\"A variable with name '{var.name}' already exists in the collection\")\n\n    self.register_object(var)\n    if sample:\n        samples = var.sample(size=size)\n        if squeeze:\n            return NamedValue(name=var.name, value=samples.squeeze())\n        else:\n            return NamedValue(name=var.name, value=samples)\n    else:\n        return None\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableHash.sample_all","title":"sample_all","text":"<pre><code>sample_all(size: int = 1) -&gt; dict[str, ndarray]\n</code></pre> <p>Sample from all registered distributions.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate per distribution</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>dict[str, np.ndarray]: Dictionary mapping variable names to their samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample_all(self, size: int = 1) -&gt; dict[str, np.ndarray]:\n    \"\"\"Sample from all registered distributions.\n\n    Args:\n        size (int): Number of samples to generate per distribution\n\n    Returns:\n        dict[str, np.ndarray]: Dictionary mapping variable names to their samples\n    \"\"\"\n    return {name: var.sample(size) for name, var in self.objects.items()}\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList","title":"RandomVariableList","text":"<p>               Bases: <code>NamedObjectList</code></p> <p>List of random variables.</p> <p>This class manages an ordered list of RandomVariable objects, providing methods to add, access, and sample from multiple distributions while maintaining their order.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>objects</code> <code>List[SerializeAsAny[InstanceOf[RandomVariable]]]</code> <p>List of random variable objects</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; RandomVariable\n</code></pre> <p>Get a random variable by its index in the list.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the random variable to retrieve</p> required <p>Returns:</p> Name Type Description <code>RandomVariable</code> <code>RandomVariable</code> <p>The random variable at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; RandomVariable:\n    \"\"\"Get a random variable by its index in the list.\n\n    Args:\n        idx (int): Index of the random variable to retrieve\n\n    Returns:\n        RandomVariable: The random variable at the specified index\n\n    Raises:\n        IndexError: If the index is out of range\n    \"\"\"\n    return super().__getitem__(idx)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.append","title":"append","text":"<pre><code>append(variable: RandomVariable) -&gt; Self\n</code></pre> <p>Append a random variable to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>RandomVariable</code> <p>Random variable to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance for method chaining</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def append(self, variable: RandomVariable) -&gt; Self:\n    \"\"\"Append a random variable to the end of the list.\n\n    Args:\n        variable (RandomVariable): Random variable to append\n\n    Returns:\n        Self: The RandomVariableList instance for method chaining\n    \"\"\"\n    return super().append(variable)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.extend","title":"extend","text":"<pre><code>extend(variables: Iterable[RandomVariable]) -&gt; Self\n</code></pre> <p>Extend the list with multiple random variables.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Iterable[RandomVariable]</code> <p>Collection of random variables to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance for method chaining</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def extend(self, variables: Iterable[RandomVariable]) -&gt; Self:\n    \"\"\"Extend the list with multiple random variables.\n\n    Args:\n        variables (Iterable[RandomVariable]): Collection of random variables to add\n\n    Returns:\n        Self: The RandomVariableList instance for method chaining\n    \"\"\"\n    return super().extend(variables)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: str) -&gt; RandomVariable\n</code></pre> <p>Get a registered random variable by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the random variable</p> required <p>Returns:</p> Name Type Description <code>RandomVariable</code> <code>RandomVariable</code> <p>The requested random variable</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no variable exists with the given name</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variable(self, name: str) -&gt; RandomVariable:\n    \"\"\"Get a registered random variable by name.\n\n    Args:\n        name (str): Name of the random variable\n\n    Returns:\n        RandomVariable: The requested random variable\n\n    Raises:\n        KeyError: If no variable exists with the given name\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.get_variables","title":"get_variables","text":"<pre><code>get_variables() -&gt; Iterable[RandomVariable]\n</code></pre> <p>Get all registered random variables.</p> <p>Returns:</p> Type Description <code>Iterable[RandomVariable]</code> <p>Iterable[RandomVariable]: Iterator over all registered variables</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variables(self) -&gt; Iterable[RandomVariable]:\n    \"\"\"Get all registered random variables.\n\n    Returns:\n        Iterable[RandomVariable]: Iterator over all registered variables\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.register_variable","title":"register_variable","text":"<pre><code>register_variable(var: RandomVariable) -&gt; Self\n</code></pre> <p>Register a random variable to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>RandomVariable</code> <p>Random variable to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_variable(self, var: RandomVariable) -&gt; Self:\n    \"\"\"Register a random variable to the collection.\n\n    Args:\n        var (RandomVariable): Random variable to register\n\n    Returns:\n        Self: The RandomVariableList instance\n    \"\"\"\n    return self.register_object(var)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.sample_all","title":"sample_all","text":"<pre><code>sample_all(size: int = 1) -&gt; dict[str, ndarray]\n</code></pre> <p>Sample from all variables in the list.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate per variable</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>dict[str, np.ndarray]: Dictionary mapping variable names to their samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample_all(self, size: int = 1) -&gt; dict[str, np.ndarray]:\n    \"\"\"Sample from all variables in the list.\n\n    Args:\n        size (int): Number of samples to generate per variable\n\n    Returns:\n        dict[str, np.ndarray]: Dictionary mapping variable names to their samples\n    \"\"\"\n    return {var.name: var.sample(size) for var in self.objects}\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution","title":"UniformDistribution","text":"<p>               Bases: <code>RandomVariable[float]</code></p> <p>Continuous uniform distribution over an interval [low, high].</p> <p>The uniform distribution describes equal probability over a continuous interval. Any value between low and high is equally likely to be drawn.</p> Key Properties <ul> <li>Mean = (low + high)/2</li> <li>Variance = (high - low)\u00b2/12</li> <li>Constant PDF over [low, high]</li> <li>Linear CDF over [low, high]</li> </ul> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>Lower bound of the interval</p> <code>high</code> <code>float</code> <p>Upper bound of the interval</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the uniform cumulative distribution function.</p> <p>The CDF is: - 0 for x &lt; low - (x-low)/(high-low) for low \u2264 x \u2264 high - 1 for x &gt; high</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the uniform cumulative distribution function.\n\n    The CDF is:\n    - 0 for x &lt; low\n    - (x-low)/(high-low) for low \u2264 x \u2264 high\n    - 1 for x &gt; high\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return np.where(\n        x &lt; self.low,\n        0.0,\n        np.where(\n            x &gt; self.high,\n            1.0,\n            (x - self.low) / (self.high - self.low)\n        )\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the uniform probability density function.</p> <p>The PDF is 1/(high-low) for x in [low,high] and 0 elsewhere.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: PDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the uniform probability density function.\n\n    The PDF is 1/(high-low) for x in [low,high] and 0 elsewhere.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: PDF values at the input points\n    \"\"\"\n    return np.where(\n        (x &gt;= self.low) &amp; (x &lt;= self.high),\n        1.0 / (self.high - self.low),\n        0.0\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Generate random samples from the uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Array of samples from U(low,high)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Generate random samples from the uniform distribution.\n\n    Args:\n        size (int): Number of samples to generate\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Array of samples from U(low,high)\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.uniform(self.low, self.high, size=size)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution.validate_bounds","title":"validate_bounds","text":"<pre><code>validate_bounds() -&gt; UniformDistribution\n</code></pre> <p>Validate that high &gt; low.</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>@model_validator(mode='after')\ndef validate_bounds(self) -&gt; UniformDistribution:\n    \"\"\"Validate that high &gt; low.\"\"\"\n    if self.high &lt;= self.low:\n        raise ValueError(f\"Upper bound ({self.high}) must be greater than lower bound ({self.low})\")\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/","title":"base","text":""},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base","title":"base","text":"<p>Base module for named objects and their collections. Provides common functionality for serialization and management of named objects.</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObject","title":"NamedObject","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for named objects with serialization support.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Name of object class type (computed field)</p> <code>name</code> <code>str</code> <p>Name of the object</p> Configuration <p>model_config (ConfigDict): Pydantic model configuration</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObject.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>Returns the name of the object type.</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObject.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(*, registry_category: str = None, **kwargs)\n</code></pre> <p>Register subclasses in appropriate registry category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init_subclass__(cls, *, registry_category: str = None, **kwargs):\n    \"\"\"Register subclasses in appropriate registry category.\"\"\"\n    super().__init_subclass__(**kwargs)\n    if registry_category:\n        cls._registry_category = registry_category\n    ObjectRegistry.register(cls._registry_category, cls)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash","title":"NamedObjectHash","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dictionary of named objects with type checking and conflict prevention.</p> <p>Attributes:</p> Name Type Description <code>objects</code> <code>dict</code> <p>Dictionary of named objects</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.deserialize_objects","title":"deserialize_objects  <code>classmethod</code>","text":"<pre><code>deserialize_objects(data: Any) -&gt; Any\n</code></pre> <p>Deserialize objects during validation.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@model_validator(mode='before')\n@classmethod\ndef deserialize_objects(cls, data: Any) -&gt; Any:\n    \"\"\"Deserialize objects during validation.\"\"\"\n    if not isinstance(data, dict):\n        return data\n\n    objects = data.get('objects', {})\n    if isinstance(objects, dict):\n        for name, obj_data in objects.items():\n            if isinstance(obj_data, dict):\n                type_name = obj_data.get('type')\n                if type_name:\n                    # Remove type as it's not part of the constructor\n                    obj_data = obj_data.copy()\n                    obj_data.pop('type')\n                    obj_type = ObjectRegistry.get(cls._registry_category, type_name)\n                    data['objects'][name] = obj_type(**obj_data)\n    return data\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.get_object","title":"get_object","text":"<pre><code>get_object(name: str) -&gt; NamedObject\n</code></pre> <p>Get object by name.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_object(self, name: str) -&gt; NamedObject:\n    \"\"\"Get object by name.\"\"\"\n    return self.objects[name]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.get_object_names","title":"get_object_names","text":"<pre><code>get_object_names() -&gt; Iterable[str]\n</code></pre> <p>Get names of all objects.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_object_names(self) -&gt; Iterable[str]:\n    \"\"\"Get names of all objects.\"\"\"\n    return self.objects.keys()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.get_objects","title":"get_objects","text":"<pre><code>get_objects() -&gt; Iterable[NamedObject]\n</code></pre> <p>Get all objects.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_objects(self) -&gt; Iterable[NamedObject]:\n    \"\"\"Get all objects.\"\"\"\n    return self.objects.values()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.register_object","title":"register_object","text":"<pre><code>register_object(obj: NamedObject) -&gt; Self\n</code></pre> <p>Register a named object. Checks for naming conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>NamedObject</code> <p>Object to register</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If object with same name exists</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def register_object(self, obj: NamedObject) -&gt; Self:\n    \"\"\"\n    Register a named object. Checks for naming conflicts.\n\n    Args:\n        obj (NamedObject): Object to register\n\n    Raises:\n        ValueError: If object with same name exists\n    \"\"\"\n    if obj.name in self.objects:\n        raise ValueError(\n            f\"Naming conflict: An object named '{obj.name}' already exists.\"\n            f\"\\n\\tExisting: \\n{self.get_object(obj.name).model_dump_json(indent=4)}\"\n            f\"\\n\\tNew: \\n{obj.model_dump_json(indent=4)}\"\n        )\n    self.objects[obj.name] = obj\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList","title":"NamedObjectList","text":"<p>               Bases: <code>BaseModel</code></p> <p>List of named objects with type checking.</p> <p>Attributes:</p> Name Type Description <code>objects</code> <code>list</code> <p>List of named objects</p> Example <pre><code>obj_list = NamedObjectList()\nobj_list.append(named_object)\nobj_list.extend([obj1, obj2, obj3])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NamedObject\n</code></pre> <p>Get object by index.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NamedObject:\n    \"\"\"Get object by index.\"\"\"\n    return self.objects[idx]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterable[NamedObject]\n</code></pre> <p>Iterate over objects in list.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __iter__(self) -&gt; Iterable[NamedObject]:\n    \"\"\"Iterate over objects in list.\"\"\"\n    return iter(self.objects)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of objects in list.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of objects in list.\"\"\"\n    return len(self.objects)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.append","title":"append","text":"<pre><code>append(obj: NamedObject) -&gt; Self\n</code></pre> <p>Append a single object to the list.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>NamedObject</code> <p>Object to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def append(self, obj: NamedObject) -&gt; Self:\n    \"\"\"\n    Append a single object to the list.\n\n    Args:\n        obj (NamedObject): Object to append\n\n    Returns:\n        Self: Returns self for chaining\n    \"\"\"\n    self.objects.append(obj)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.extend","title":"extend","text":"<pre><code>extend(objects: Iterable[NamedObject]) -&gt; Self\n</code></pre> <p>Extend list with multiple objects.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>Iterable[NamedObject]</code> <p>Objects to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def extend(self, objects: Iterable[NamedObject]) -&gt; Self:\n    \"\"\"\n    Extend list with multiple objects.\n\n    Args:\n        objects (Iterable[NamedObject]): Objects to add\n\n    Returns:\n        Self: Returns self for chaining\n    \"\"\"\n    self.objects.extend(objects)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(iterable: Iterable[NamedObject]) -&gt; Self\n</code></pre> <p>Create instance from an iterable of named objects.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[NamedObject]</code> <p>Objects to add to list</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>New instance containing the objects</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef from_iterable(cls, iterable: Iterable[NamedObject]) -&gt; Self:\n    \"\"\"\n    Create instance from an iterable of named objects.\n\n    Args:\n        iterable (Iterable[NamedObject]): Objects to add to list\n\n    Returns:\n        Self: New instance containing the objects\n    \"\"\"\n    return cls(objects=list(iterable))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry","title":"ObjectRegistry","text":"<p>Generic registry for named object types.</p> <p>Stores object types for deserialization from JSON files. Types are stored at the class level for consistent access across modules.</p> <p>Types are stored at the class level for consistent access across modules.</p> <p>Methods:</p> Name Description <code>register</code> <p>Register an object type</p> <code>get</code> <p>Get an object type by name</p> <code>get_all</code> <p>Get all registered object types</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(category: str, name: str) -&gt; Type[NamedObject]\n</code></pre> <p>Get an object type by category and name.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get(cls, category: str, name: str) -&gt; Type[NamedObject]:\n    \"\"\"Get an object type by category and name.\"\"\"\n    registry = cls.get_registry(category)\n    if name not in registry:\n        raise ValueError(f\"{name} not found in {category} registry\")\n    return registry[name]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry.get_all","title":"get_all  <code>classmethod</code>","text":"<pre><code>get_all(category: str) -&gt; list[Type[NamedObject]]\n</code></pre> <p>Get all registered types for a category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get_all(cls, category: str) -&gt; list[Type[NamedObject]]:\n    \"\"\"Get all registered types for a category.\"\"\"\n    return list(cls.get_registry(category).values())\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry.get_registry","title":"get_registry  <code>classmethod</code>","text":"<pre><code>get_registry(category: str) -&gt; Dict[str, Type[NamedObject]]\n</code></pre> <p>Get or create registry for a category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get_registry(cls, category: str) -&gt; Dict[str, Type[NamedObject]]:\n    \"\"\"Get or create registry for a category.\"\"\"\n    # Get the actual string value if it's a PrivateAttr\n    if hasattr(category, 'default'):\n        category = category.default\n    if category not in cls._registries:\n        cls._registries[category] = {}\n    return cls._registries[category]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(category: str, obj_type: Type[NamedObject]) -&gt; None\n</code></pre> <p>Register an object type in its category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef register(cls, category: str, obj_type: Type[NamedObject]) -&gt; None:\n    \"\"\"Register an object type in its category.\"\"\"\n    # Get the actual string value if it's a PrivateAttr\n    if hasattr(category, 'default'):\n        category = category.default\n    registry = cls.get_registry(category)\n    registry[obj_type.__name__] = obj_type\n</code></pre>"},{"location":"reference/process_manager/data_handlers/mixins/","title":"mixins","text":""},{"location":"reference/process_manager/data_handlers/mixins/#process_manager.data_handlers.mixins","title":"mixins","text":"<p>Defines inputs</p>"},{"location":"reference/process_manager/data_handlers/mixins/#process_manager.data_handlers.mixins.ArrayDunders","title":"ArrayDunders","text":"<p>               Bases: <code>NumericDunders</code></p> <p>A mixin class that extends NumericDunders with additional array-like behavior.</p>"},{"location":"reference/process_manager/data_handlers/mixins/#process_manager.data_handlers.mixins.NumericDunders","title":"NumericDunders","text":"<p>A mixin class containing numeric dunder methods that can be applied to any class via composition</p> <p>Attributes:</p> Name Type Description <code>RESERVED_NAME</code> <code>str</code> <p>Name of the reserved attribute that holds the value</p>"},{"location":"reference/process_manager/data_handlers/mixins/#process_manager.data_handlers.mixins.NumericDunders.get_value","title":"get_value  <code>classmethod</code>","text":"<pre><code>get_value(instance)\n</code></pre> <p>Get the value of the instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>Instance of the class</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Value of the instance stored in the reserved attribute or else returns the instance. For example, if the reserved attribute is 'value', then it returns <code>instance.value</code> else if the instance is just a float or an int or something like that, then it returns the instance itself.</p> Source code in <code>src/process_manager/data_handlers/mixins.py</code> <pre><code>@classmethod\ndef get_value(cls, instance):\n    \"\"\"\n    Get the value of the instance\n\n    Args:\n        instance (Any): Instance of the class\n\n    Returns:\n        Any: Value of the instance stored in the reserved attribute or else returns the instance.\n            For example, if the reserved attribute is 'value', then it returns `instance.value` else\n            if the instance is just a float or an int or something like that, then it returns the instance itself.\n    \"\"\"\n    return getattr(instance, cls.RESERVED_NAME, instance)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/","title":"random_variables","text":""},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables","title":"random_variables","text":"<p>Random Variable Implementations for Process Analysis.</p> <p>This module provides a framework for working with random variables and probability distributions in a type-safe, numerically stable way. It includes implementations of common distributions (Normal, Uniform, Categorical) and infrastructure for managing collections of random variables.</p> <p>The module uses a metaclass-based approach to ensure consistent handling of array dimensions across all distributions, making it easy to work with both scalar and vector-valued random variables.</p> Key Features <ul> <li>Type-safe implementations of common probability distributions</li> <li>Automatic dimension handling via the squeezable decorator</li> <li>Support for reproducible sampling via seed management</li> <li>Collections for managing groups of random variables</li> <li>Serialization support via pydantic</li> </ul>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution","title":"CategoricalDistribution","text":"<p>               Bases: <code>RandomVariable[T]</code></p> <p>Categorical distribution for discrete outcomes with specified probabilities.</p> <p>A categorical distribution (also called a discrete distribution) describes the probability of obtaining one of k possible outcomes. Each outcome has a probability between 0 and 1, and all probabilities must sum to 1.</p> <p>If probabilities are not specified, defaults to equal probabilities for all categories (uniform discrete distribution).</p> Key Properties <ul> <li>Support is finite set of categories</li> <li>PMF gives probability of each category</li> <li>CDF is step function</li> </ul> <p>Attributes:</p> Name Type Description <code>categories</code> <code>ndarray</code> <p>Array of possible outcomes (any type)</p> <code>probabilities</code> <code>ndarray</code> <p>Probability for each category</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p> <code>replace</code> <code>bool</code> <p>Whether or not to allow multiple draws of the same value (allowed if True)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If probabilities don't sum to 1</p> <code>ValueError</code> <p>If lengths of categories and probabilities don't match</p> <code>ValueError</code> <p>If any probability is negative</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the cumulative distribution function.</p> <p>For categorical distributions, this is a step function that increases at each category by that category's probability.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the cumulative distribution function.\n\n    For categorical distributions, this is a step function that\n    increases at each category by that category's probability.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return np.array([\n        np.sum(self.probabilities[self.categories &lt;= val])\n        for val in x\n    ])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the probability mass function (PMF).</p> <p>For categorical distributions, this gives the probability of each category occurring.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PMF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Probability of each input value</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the probability mass function (PMF).\n\n    For categorical distributions, this gives the probability of\n    each category occurring.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PMF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Probability of each input value\n    \"\"\"\n    return np.array([\n        self.probabilities[self.categories == val].item()\n        if val in self.categories else 0.0\n        for val in x\n    ])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Generate random samples from the categorical distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate. Defaults to 1.</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> Notes <p>The squeeze parameter is added automatically by the metaclass and does not appear in the function signature, but can be passed as a keyword argument.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>NDArray[Any,T]: Array of samples from the categories</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any,T]:\n    \"\"\"Generate random samples from the categorical distribution.\n\n    Args:\n        size (int, optional): Number of samples to generate. Defaults to 1.\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Notes:\n        The squeeze parameter is added automatically by the metaclass and does not appear\n        in the function signature, but can be passed as a keyword argument.\n\n    Returns:\n        NDArray[Any,T]: Array of samples from the categories\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.choice(self.categories, size=size, p=self.probabilities, replace=self.replace)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution.validate_and_set_probabilities","title":"validate_and_set_probabilities","text":"<pre><code>validate_and_set_probabilities() -&gt; CategoricalDistribution\n</code></pre> <p>Validate probability values and set defaults if needed.</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>@model_validator(mode='after')\ndef validate_and_set_probabilities(self) -&gt; CategoricalDistribution:\n    \"\"\"Validate probability values and set defaults if needed.\"\"\"\n    if self.probabilities is None:\n        n_categories = len(self.categories)\n        self.probabilities = np.ones(n_categories) / n_categories\n        return self\n\n    if len(self.categories) != len(self.probabilities):\n        raise ValueError(\n            f\"Number of categories ({len(self.categories)}) must match \"\n            f\"number of probabilities ({len(self.probabilities)})\"\n        )\n    if not np.all(self.probabilities &gt;= 0):\n        raise ValueError(\"All probabilities must be non-negative\")\n    if not np.isclose(np.sum(self.probabilities), 1.0):\n        raise ValueError(\"Probabilities must sum to 1\")\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.NormalDistribution","title":"NormalDistribution","text":"<p>               Bases: <code>RandomVariable[float]</code></p> <p>Normal (Gaussian) distribution with mean \u03bc and standard deviation \u03c3.</p> <p>The normal distribution is a continuous probability distribution that is symmetric about its mean, showing the familiar bell-shaped curve.</p> Key Properties <ul> <li>Symmetric about the mean</li> <li>~68% of values lie within 1\u03c3 of \u03bc</li> <li>~95% lie within 2\u03c3 of \u03bc</li> <li>~99.7% lie within 3\u03c3 of \u03bc</li> </ul> <p>Attributes:</p> Name Type Description <code>mu</code> <code>float</code> <p>Mean (\u03bc) of the distribution</p> <code>sigma</code> <code>float</code> <p>Standard deviation (\u03c3) of the distribution</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.NormalDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the normal cumulative distribution function.</p> <p>The CDF is computed using the error function: F(x) = 1/2 * (1 + erf((x-\u03bc)/(\u03c3\u221a2)))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the normal cumulative distribution function.\n\n    The CDF is computed using the error function:\n    F(x) = 1/2 * (1 + erf((x-\u03bc)/(\u03c3\u221a2)))\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return 0.5 * (1 + sp.erf((x - self.mu)/(self.sigma * np.sqrt(2))))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.NormalDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the normal probability density function.</p> <p>The PDF is given by: f(x) = 1/(\u03c3\u221a(2\u03c0)) * exp(-(x-\u03bc)\u00b2/(2\u03c3\u00b2))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: PDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the normal probability density function.\n\n    The PDF is given by:\n    f(x) = 1/(\u03c3\u221a(2\u03c0)) * exp(-(x-\u03bc)\u00b2/(2\u03c3\u00b2))\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: PDF values at the input points\n    \"\"\"\n    return 1/(self.sigma * np.sqrt(2*np.pi)) * np.exp(-(x - self.mu)**2 / (2*self.sigma**2))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.NormalDistribution.sample","title":"sample","text":"<pre><code>sample(size: int | tuple[int, ...] = 1, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Generate random samples from the normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int | tuple[int, ...]</code> <p>Number or shape of samples</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Array of samples from N(\u03bc, \u03c3)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int | tuple[int, ...] = 1, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Generate random samples from the normal distribution.\n\n    Args:\n        size (int | tuple[int, ...]): Number or shape of samples\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Array of samples from N(\u03bc, \u03c3)\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.normal(self.mu, self.sigma, size=size)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable","title":"RandomVariable","text":"<p>               Bases: <code>NamedObject</code>, <code>Generic[T]</code></p> <p>Base class for random variables.</p> <p>This class provides a common interface for random variable implementations. Subclasses must implement sample(), pdf(), and cdf() methods. The metaclass ensures these methods support dimension control via the squeeze parameter.</p> <p>The class is generic over the type of values it produces (T), which must be a subtype of SerializableValue to ensure proper serialization behavior.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p> <code>name</code> <code>str</code> <p>Identifier for this random variable instance</p> Type Variables <p>T: The type of values produced by this random variable</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Evaluate cumulative distribution function at specified points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>CDF values at the input points</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Evaluate cumulative distribution function at specified points.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): CDF values at the input points\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Evaluate probability density function at specified points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>PDF values at the input points</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Evaluate probability density function at specified points.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): PDF values at the input points\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable.register_to_hash","title":"register_to_hash","text":"<pre><code>register_to_hash(\n    var_hash: RandomVariableHash, size: int = 1, sample: bool = True, squeeze: bool = True\n) -&gt; NamedValue[T | NDArray[Any, T]]\n</code></pre> <p>Register this random variable to a hash and return sampled values.</p> <p>This is a convenience method for adding a random variable to a collection and immediately sampling from it.</p> <p>Parameters:</p> Name Type Description Default <code>var_hash</code> <code>RandomVariableHash</code> <p>Hash object to register to</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>NamedValue[T | NDArray[Any, T]]</code> <p>Named value containing samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_to_hash(\n        self, \n        var_hash: RandomVariableHash, \n        size: int = 1, \n        sample: bool = True,\n        squeeze: bool = True,\n    ) -&gt; NamedValue[T|NDArray[Any,T]]:\n    \"\"\"Register this random variable to a hash and return sampled values.\n\n    This is a convenience method for adding a random variable to a collection\n    and immediately sampling from it.\n\n    Args:\n        var_hash (RandomVariableHash): Hash object to register to\n        size (int): Number of samples to generate\n\n    Returns:\n        (NamedValue[T|NDArray[Any,T]]): Named value containing samples\n    \"\"\"\n    return var_hash.register_variable(self, size=size, sample=sample, squeeze=squeeze)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Generate random samples from the categorical distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate. Defaults to 1.</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>Array of samples from the categories</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Generate random samples from the categorical distribution.\n\n    Args:\n        size (int): Number of samples to generate. Defaults to 1.\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): Array of samples from the categories\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableHash","title":"RandomVariableHash","text":"<p>               Bases: <code>NamedObjectHash</code></p> <p>Collection of random variables.</p> <p>This class manages a collection of RandomVariable objects, providing methods to register, retrieve and sample from multiple distributions.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableHash.get_variables","title":"get_variables","text":"<pre><code>get_variables() -&gt; Iterable[RandomVariable]\n</code></pre> <p>Get all registered random variables.</p> <p>Returns:</p> Type Description <code>Iterable[RandomVariable]</code> <p>Iterable[RandomVariable]: Iterator over all registered variables</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variables(self) -&gt; Iterable[RandomVariable]:\n    \"\"\"Get all registered random variables.\n\n    Returns:\n        Iterable[RandomVariable]: Iterator over all registered variables\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableHash.register_variable","title":"register_variable","text":"<pre><code>register_variable(\n    var: RandomVariable, size: int = 1, sample: bool = True, squeeze: bool = True\n) -&gt; NamedValue[SerializableValue | NDArray[Any, SerializableValue]]\n</code></pre> <p>Register a random variable and return its samples wrapped in a NamedValue.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>RandomVariable</code> <p>Random variable to register</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>NamedValue[SerializableValue | NDArray[Any, SerializableValue]]</code> <p>NamedValue[SerializableValue|NDArray[Any,SerializableValue]]: Named value containing samples</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a variable with the same name already exists</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_variable(\n        self, \n        var: RandomVariable, \n        size: int = 1,\n        sample: bool = True,\n        squeeze: bool = True,\n    ) -&gt; NamedValue[SerializableValue|NDArray[Any,SerializableValue]]:\n    \"\"\"Register a random variable and return its samples wrapped in a NamedValue.\n\n    Args:\n        var (RandomVariable): Random variable to register\n        size (int): Number of samples to generate\n\n    Returns:\n        NamedValue[SerializableValue|NDArray[Any,SerializableValue]]: Named value containing samples\n\n    Raises:\n        ValueError: If a variable with the same name already exists\n    \"\"\"\n    if var.name in self.objects:\n        raise ValueError(f\"A variable with name '{var.name}' already exists in the collection\")\n\n    self.register_object(var)\n    if sample:\n        samples = var.sample(size=size)\n        if squeeze:\n            return NamedValue(name=var.name, value=samples.squeeze())\n        else:\n            return NamedValue(name=var.name, value=samples)\n    else:\n        return None\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableHash.sample_all","title":"sample_all","text":"<pre><code>sample_all(size: int = 1) -&gt; dict[str, ndarray]\n</code></pre> <p>Sample from all registered distributions.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate per distribution</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>dict[str, np.ndarray]: Dictionary mapping variable names to their samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample_all(self, size: int = 1) -&gt; dict[str, np.ndarray]:\n    \"\"\"Sample from all registered distributions.\n\n    Args:\n        size (int): Number of samples to generate per distribution\n\n    Returns:\n        dict[str, np.ndarray]: Dictionary mapping variable names to their samples\n    \"\"\"\n    return {name: var.sample(size) for name, var in self.objects.items()}\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList","title":"RandomVariableList","text":"<p>               Bases: <code>NamedObjectList</code></p> <p>List of random variables.</p> <p>This class manages an ordered list of RandomVariable objects, providing methods to add, access, and sample from multiple distributions while maintaining their order.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>objects</code> <code>List[SerializeAsAny[InstanceOf[RandomVariable]]]</code> <p>List of random variable objects</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; RandomVariable\n</code></pre> <p>Get a random variable by its index in the list.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the random variable to retrieve</p> required <p>Returns:</p> Name Type Description <code>RandomVariable</code> <code>RandomVariable</code> <p>The random variable at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; RandomVariable:\n    \"\"\"Get a random variable by its index in the list.\n\n    Args:\n        idx (int): Index of the random variable to retrieve\n\n    Returns:\n        RandomVariable: The random variable at the specified index\n\n    Raises:\n        IndexError: If the index is out of range\n    \"\"\"\n    return super().__getitem__(idx)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.append","title":"append","text":"<pre><code>append(variable: RandomVariable) -&gt; Self\n</code></pre> <p>Append a random variable to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>RandomVariable</code> <p>Random variable to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance for method chaining</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def append(self, variable: RandomVariable) -&gt; Self:\n    \"\"\"Append a random variable to the end of the list.\n\n    Args:\n        variable (RandomVariable): Random variable to append\n\n    Returns:\n        Self: The RandomVariableList instance for method chaining\n    \"\"\"\n    return super().append(variable)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.extend","title":"extend","text":"<pre><code>extend(variables: Iterable[RandomVariable]) -&gt; Self\n</code></pre> <p>Extend the list with multiple random variables.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Iterable[RandomVariable]</code> <p>Collection of random variables to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance for method chaining</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def extend(self, variables: Iterable[RandomVariable]) -&gt; Self:\n    \"\"\"Extend the list with multiple random variables.\n\n    Args:\n        variables (Iterable[RandomVariable]): Collection of random variables to add\n\n    Returns:\n        Self: The RandomVariableList instance for method chaining\n    \"\"\"\n    return super().extend(variables)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: str) -&gt; RandomVariable\n</code></pre> <p>Get a registered random variable by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the random variable</p> required <p>Returns:</p> Name Type Description <code>RandomVariable</code> <code>RandomVariable</code> <p>The requested random variable</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no variable exists with the given name</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variable(self, name: str) -&gt; RandomVariable:\n    \"\"\"Get a registered random variable by name.\n\n    Args:\n        name (str): Name of the random variable\n\n    Returns:\n        RandomVariable: The requested random variable\n\n    Raises:\n        KeyError: If no variable exists with the given name\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.get_variables","title":"get_variables","text":"<pre><code>get_variables() -&gt; Iterable[RandomVariable]\n</code></pre> <p>Get all registered random variables.</p> <p>Returns:</p> Type Description <code>Iterable[RandomVariable]</code> <p>Iterable[RandomVariable]: Iterator over all registered variables</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variables(self) -&gt; Iterable[RandomVariable]:\n    \"\"\"Get all registered random variables.\n\n    Returns:\n        Iterable[RandomVariable]: Iterator over all registered variables\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.register_variable","title":"register_variable","text":"<pre><code>register_variable(var: RandomVariable) -&gt; Self\n</code></pre> <p>Register a random variable to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>RandomVariable</code> <p>Random variable to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_variable(self, var: RandomVariable) -&gt; Self:\n    \"\"\"Register a random variable to the collection.\n\n    Args:\n        var (RandomVariable): Random variable to register\n\n    Returns:\n        Self: The RandomVariableList instance\n    \"\"\"\n    return self.register_object(var)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.sample_all","title":"sample_all","text":"<pre><code>sample_all(size: int = 1) -&gt; dict[str, ndarray]\n</code></pre> <p>Sample from all variables in the list.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate per variable</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>dict[str, np.ndarray]: Dictionary mapping variable names to their samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample_all(self, size: int = 1) -&gt; dict[str, np.ndarray]:\n    \"\"\"Sample from all variables in the list.\n\n    Args:\n        size (int): Number of samples to generate per variable\n\n    Returns:\n        dict[str, np.ndarray]: Dictionary mapping variable names to their samples\n    \"\"\"\n    return {var.name: var.sample(size) for var in self.objects}\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableMeta","title":"RandomVariableMeta","text":"<p>               Bases: <code>type(BaseModel)</code></p> <p>Metaclass for random variable implementations that automatically adds array handling functionality.</p> <p>This metaclass inherits from pydantic's model metaclass to maintain compatibility with the  BaseModel validation system while adding automatic array handling capabilities to all random  variable implementations.</p> Key Features <ul> <li>Automatically applies the <code>squeezable</code> decorator to sample(), pdf(), and cdf() methods</li> <li>Maintains compatibility with pydantic's model validation system</li> <li>Ensures consistent array handling across all random variable implementations</li> </ul> The metaclass processes each new random variable class during its creation by <ol> <li>Identifying the standard distribution methods (sample, pdf, cdf)</li> <li>If these methods are defined in the class (not inherited), wrapping them with    the squeezable decorator</li> <li>Preserving the original method docstrings while adding squeeze parameter documentation</li> </ol> Example <pre><code>class NormalDistribution(RandomVariable[float]):\n    def sample(self, size: int = 1) -&gt; NDArray[Any, float]:\n        # Method will automatically get squeeze functionality\n        # and accept an optional `bool` defaulting to `squeeze=True`\n        return rng.normal(self.mu, self.sigma, size=size)\n</code></pre> Technical Details <ul> <li>Inherits from type(BaseModel) to maintain pydantic compatibility</li> <li>Uses new to modify class attributes during class creation</li> <li>Preserves method signatures while adding the squeeze parameter</li> <li>Ensures proper type hints and docstring updates</li> </ul> Notes <ul> <li>The squeezable decorator adds a <code>squeeze</code> parameter to wrapped methods</li> <li>When squeeze=True (default), output arrays are squeezed and 0-d arrays   are converted to scalar values</li> <li>Original method behavior is preserved when squeeze=False</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mcs</code> <p>The metaclass instance</p> required <code>name</code> <code>str</code> <p>Name of the class being created</p> required <code>bases</code> <code>tuple</code> <p>Base classes</p> required <code>namespace</code> <code>dict</code> <p>Class namespace dictionary</p> required <code>**kwargs</code> <p>Additional keyword arguments passed to type(BaseModel)</p> required <p>Returns:</p> Type Description <code>type</code> <p>The created class with enhanced array handling capabilities</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution","title":"UniformDistribution","text":"<p>               Bases: <code>RandomVariable[float]</code></p> <p>Continuous uniform distribution over an interval [low, high].</p> <p>The uniform distribution describes equal probability over a continuous interval. Any value between low and high is equally likely to be drawn.</p> Key Properties <ul> <li>Mean = (low + high)/2</li> <li>Variance = (high - low)\u00b2/12</li> <li>Constant PDF over [low, high]</li> <li>Linear CDF over [low, high]</li> </ul> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>Lower bound of the interval</p> <code>high</code> <code>float</code> <p>Upper bound of the interval</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the uniform cumulative distribution function.</p> <p>The CDF is: - 0 for x &lt; low - (x-low)/(high-low) for low \u2264 x \u2264 high - 1 for x &gt; high</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the uniform cumulative distribution function.\n\n    The CDF is:\n    - 0 for x &lt; low\n    - (x-low)/(high-low) for low \u2264 x \u2264 high\n    - 1 for x &gt; high\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return np.where(\n        x &lt; self.low,\n        0.0,\n        np.where(\n            x &gt; self.high,\n            1.0,\n            (x - self.low) / (self.high - self.low)\n        )\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the uniform probability density function.</p> <p>The PDF is 1/(high-low) for x in [low,high] and 0 elsewhere.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: PDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the uniform probability density function.\n\n    The PDF is 1/(high-low) for x in [low,high] and 0 elsewhere.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: PDF values at the input points\n    \"\"\"\n    return np.where(\n        (x &gt;= self.low) &amp; (x &lt;= self.high),\n        1.0 / (self.high - self.low),\n        0.0\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Generate random samples from the uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Array of samples from U(low,high)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Generate random samples from the uniform distribution.\n\n    Args:\n        size (int): Number of samples to generate\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Array of samples from U(low,high)\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.uniform(self.low, self.high, size=size)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution.validate_bounds","title":"validate_bounds","text":"<pre><code>validate_bounds() -&gt; UniformDistribution\n</code></pre> <p>Validate that high &gt; low.</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>@model_validator(mode='after')\ndef validate_bounds(self) -&gt; UniformDistribution:\n    \"\"\"Validate that high &gt; low.\"\"\"\n    if self.high &lt;= self.low:\n        raise ValueError(f\"Upper bound ({self.high}) must be greater than lower bound ({self.low})\")\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.squeezable","title":"squeezable","text":"<pre><code>squeezable(func: Callable[P, R], squeeze_by_default: bool = False) -&gt; Callable[P, R]\n</code></pre> <p>Decorator that makes a function's output array squeezable via an added keyword argument <code>squeeze</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to be decorated.</p> required <code>squeeze_by_default</code> <code>bool</code> <p>Whether or not to squeeze by default</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[P, R]</code> <p>A new function that  squeezes the output of <code>func</code> if added keyword <code>squeeze</code> is True (default)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def squeezable(func: Callable[P, R], squeeze_by_default: bool = False) -&gt; Callable[P, R]:\n    \"\"\"\n    Decorator that makes a function's output array squeezable\n    via an added keyword argument `squeeze`.\n\n    Args:\n        func (Callable[P, R]): The function to be decorated.\n        squeeze_by_default (bool): Whether or not to squeeze by default\n\n    Returns:\n        (Callable[P, R]): A new function that \n            squeezes the output of `func` if added keyword `squeeze` is True (default)\n    \"\"\"\n    # Get the original signature\n    sig = inspect.signature(func)\n\n    # Create new parameters list with correct ordering\n    parameters = []\n    has_var_kwargs = False\n\n    # First add all non-variadic parameters\n    for param in sig.parameters.values():\n        if param.kind != Parameter.VAR_KEYWORD:\n            parameters.append(param)\n        else:\n            has_var_kwargs = True\n\n    # Add squeeze parameter as keyword-only\n    parameters.append(\n        Parameter(\n            'squeeze',\n            Parameter.KEYWORD_ONLY,\n            default=squeeze_by_default,\n            annotation=bool\n        )\n    )\n\n    # Add var_kwargs at the end if it exists\n    if has_var_kwargs:\n        parameters.append(\n            Parameter(\n                'kwargs',\n                Parameter.VAR_KEYWORD\n            )\n        )\n\n    # Create new signature\n    new_sig = sig.replace(parameters=parameters)\n\n    @wraps(func)\n    def wrapper(*args: P.args, squeeze: bool = squeeze_by_default, **kwargs: P.kwargs) -&gt; R:\n        result = func(*args, **kwargs)\n        if squeeze:\n            result = result.squeeze()\n            if isinstance(result, np.ndarray) and result.ndim == 0:\n                result = result.item()\n        return result\n\n    # Update the wrapper's signature\n    wrapper.__signature__ = new_sig\n    return wrapper\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/","title":"values","text":""},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values","title":"values","text":"<p>Module for generating, sorting, and managing named values. This uses pydantic dataclasses for JSON serialization to avoid overloading system memory.</p> <p>The module provides a robust framework for managing named values with type safety, serialization, and state management. It includes classes for individual named values, collections of named values in both list and hash (dictionary) formats, and utilities for type validation and serialization.</p> <p>Classes:</p> Name Description <code>NamedValueState</code> <p>Enum for tracking the state of named values</p> <code>NamedValue</code> <p>Base class for type-safe named values with state management</p> <code>NamedValueHash</code> <p>Dictionary-like container for managing named values</p> <code>NamedValueList</code> <p>List-like container for managing ordered named values</p> Types <p>SerializableValue: Union type defining all allowed value types T: Generic type variable bound to SerializableValue</p>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue","title":"NamedValue","text":"<pre><code>NamedValue(name: str, value: T | None = None, **data)\n</code></pre> <p>               Bases: <code>NamedObject</code>, <code>Generic[T]</code></p> <p>A named value container with type safety and state management.</p> <p>NamedValue provides a type-safe way to store and manage values with built-in state tracking, serialization, and validation. Values can be frozen after initial setting to prevent accidental modification.</p> Type Parameters <p>T: The type of value to store, must be a SerializableValue</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for the value</p> <code>_stored_value</code> <code>T | NamedValueState</code> <p>The actual stored value or UNSET state</p> <code>_state</code> <code>NamedValueState</code> <p>Current state of the value</p> <code>_type</code> <code>type</code> <p>Runtime type information for validation</p> Properties <p>value (T): Access or modify the stored value</p> Example <pre><code># Create a named integer value\ncount = NamedValue[int](\"item_count\")\ncount.value = 42  # Sets and freezes the value\nprint(count.value)  # Outputs: 42\ncount.value = 50  # Raises ValueError - value is frozen\ncount.force_set_value(50)  # Allows value change\n</code></pre> <p>Initialize a new NamedValue instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for this value</p> required <code>value</code> <code>T | None</code> <p>Initial value to store. Defaults to None.</p> <code>None</code> <code>**data</code> <p>Additional keyword arguments passed to parent class</p> <code>{}</code> Note <p>If value is provided, it will be validated and set immediately. The value will be frozen after initial setting.</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __init__(self, name: str, value: T | None = None, **data):\n    \"\"\"\n    Initialize a new NamedValue instance.\n\n    Args:\n        name (str): Unique identifier for this value\n        value (T | None, optional): Initial value to store. Defaults to None.\n        **data: Additional keyword arguments passed to parent class\n\n    Note:\n        If value is provided, it will be validated and set immediately.\n        The value will be frozen after initial setting.\n    \"\"\"\n    data.pop('stored_value', None)\n    data.pop('_stored_value', None)\n\n    super().__init__(name=name, **data)\n    self._type = self._extract_value_type()\n    object.__setattr__(self, '_stored_value', NamedValueState.UNSET)  # Explicitly set initial value\n\n    if value is not None:\n        self.value = value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: T\n</code></pre> <p>Get the stored value.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The currently stored value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to access before a value has been set</p> Note <p>This property provides read access to the stored value. Once set, the value is frozen and can only be changed using force_set_value().</p>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name: str, value: Any) -&gt; None\n</code></pre> <p>Prevent direct modification of protected attributes.</p> <p>Overrides attribute setting to prevent direct modification of internal state attributes. These attributes should only be modified through appropriate methods.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the attribute to set</p> required <code>value</code> <code>Any</code> <p>Value to set</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If attempting to modify protected attributes directly</p> Example <pre><code>value = NamedValue(\"example\")\nvalue._stored_value = 42  # Raises AttributeError\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    \"\"\"\n    Prevent direct modification of protected attributes.\n\n    Overrides attribute setting to prevent direct modification of internal\n    state attributes. These attributes should only be modified through\n    appropriate methods.\n\n    Args:\n        name (str): Name of the attribute to set\n        value (Any): Value to set\n\n    Raises:\n        AttributeError: If attempting to modify protected attributes directly\n\n    Example:\n        ```python\n        value = NamedValue(\"example\")\n        value._stored_value = 42  # Raises AttributeError\n        ```\n    \"\"\"\n    if name in ('_stored_value', '_state'):\n        raise AttributeError(f\"Cannot modify {name} directly. Use appropriate methods instead.\")\n    super().__setattr__(name, value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.append_to_value_list","title":"append_to_value_list","text":"<pre><code>append_to_value_list(l: NamedValueList) -&gt; Self\n</code></pre> <p>Appends this value instance to a NamedValueList.</p> <p>Convenience method for adding this value to a list while enabling method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>NamedValueList</code> <p>The list to append this value to</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>This instance for method chaining</p> Example <pre><code>value_list = NamedValueList()\nvalue = NamedValue(\"example\", 42)\nvalue.append_to_value_list(value_list).force_set_value(43)\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def append_to_value_list(self, l: NamedValueList) -&gt; Self:\n    \"\"\"\n    Appends this value instance to a NamedValueList.\n\n    Convenience method for adding this value to a list while enabling\n    method chaining.\n\n    Args:\n        l (NamedValueList): The list to append this value to\n\n    Returns:\n        Self: This instance for method chaining\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value = NamedValue(\"example\", 42)\n        value.append_to_value_list(value_list).force_set_value(43)\n        ```\n    \"\"\"\n    l.append(self)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.force_set_value","title":"force_set_value","text":"<pre><code>force_set_value(new_value: T) -&gt; None\n</code></pre> <p>Force set the value regardless of its current state.</p> <p>This method bypasses the normal freezing mechanism and allows changing an already-set value.</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>T</code> <p>New value to store</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If value doesn't match the expected type T</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def force_set_value(self, new_value: T) -&gt; None:\n    \"\"\"\n    Force set the value regardless of its current state.\n\n    This method bypasses the normal freezing mechanism and allows\n    changing an already-set value.\n\n    Args:\n        new_value (T): New value to store\n\n    Raises:\n        TypeError: If value doesn't match the expected type T\n    \"\"\"\n    object.__setattr__(self, '_stored_value', NamedValueState.UNSET)\n    object.__setattr__(self, '_state', NamedValueState.UNSET)\n    self.value = new_value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs) -&gt; dict[str, Any]\n</code></pre> <p>Custom serialization to include value state and stored value.</p> <p>Extends the parent class serialization to include the value's state and stored value (if set) in the serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional arguments passed to parent serialization</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary containing serialized state</p> Example <pre><code>value = NamedValue(\"example\", 42)\ndata = value.model_dump()\nprint(data)  # Contains 'state' and 'stored_value'\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"\n    Custom serialization to include value state and stored value.\n\n    Extends the parent class serialization to include the value's state\n    and stored value (if set) in the serialized data.\n\n    Args:\n        **kwargs: Additional arguments passed to parent serialization\n\n    Returns:\n        dict[str, Any]: Dictionary containing serialized state\n\n    Example:\n        ```python\n        value = NamedValue(\"example\", 42)\n        data = value.model_dump()\n        print(data)  # Contains 'state' and 'stored_value'\n        ```\n    \"\"\"\n    data = super().model_dump(**kwargs)\n    data['state'] = self._state\n    if self._state == NamedValueState.SET:\n        data['stored_value'] = self._stored_value\n    return data\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(**kwargs) -&gt; str\n</code></pre> <p>Custom JSON serialization of the named value.</p> <p>Serializes the named value instance to a JSON string, including all state information and stored value.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>JSON serialization options like indent, ensure_ascii, etc.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON string representation</p> Example <pre><code>value = NamedValue(\"example\", 42)\njson_str = value.model_dump_json(indent=2)\nprint(json_str)  # Pretty-printed JSON\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Custom JSON serialization of the named value.\n\n    Serializes the named value instance to a JSON string, including\n    all state information and stored value.\n\n    Args:\n        **kwargs: JSON serialization options like indent, ensure_ascii, etc.\n\n    Returns:\n        str: JSON string representation\n\n    Example:\n        ```python\n        value = NamedValue(\"example\", 42)\n        json_str = value.model_dump_json(indent=2)\n        print(json_str)  # Pretty-printed JSON\n        ```\n    \"\"\"\n    # Separate JSON-specific kwargs from model_dump kwargs\n    json_kwargs = {k: v for k, v in kwargs.items() if k in {'indent', 'ensure_ascii', 'separators'}}\n    dump_kwargs = {k: v for k, v in kwargs.items() if k not in json_kwargs}\n\n    # Get model data with stored value\n    data = self.model_dump(**dump_kwargs)\n    return json.dumps(data, **json_kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(data: Any) -&gt; NamedValue\n</code></pre> <p>Custom deserialization to restore value state and stored value.</p> <p>Reconstructs a NamedValue instance from serialized data, properly restoring both the value state and any stored value.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Serialized data to deserialize</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>New instance with restored state</p> Example <pre><code>data = {'name': 'example', 'state': 'set', 'stored_value': 42}\nvalue = NamedValue.model_validate(data)\nprint(value.value)  # Outputs: 42\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate(cls, data: Any) -&gt; NamedValue:\n    \"\"\"\n    Custom deserialization to restore value state and stored value.\n\n    Reconstructs a NamedValue instance from serialized data, properly\n    restoring both the value state and any stored value.\n\n    Args:\n        data (Any): Serialized data to deserialize\n\n    Returns:\n        NamedValue: New instance with restored state\n\n    Example:\n        ```python\n        data = {'name': 'example', 'state': 'set', 'stored_value': 42}\n        value = NamedValue.model_validate(data)\n        print(value.value)  # Outputs: 42\n        ```\n    \"\"\"\n    if not isinstance(data, dict):\n        return super().model_validate(data)\n\n    data_copy = data.copy()\n    state = NamedValueState(data_copy.pop('state', NamedValueState.UNSET))\n    stored_value = data_copy.pop('stored_value', None)\n\n    instance = super().model_validate(data_copy)\n\n    # Only set the value if state was SET\n    if state == NamedValueState.SET and stored_value is not None:\n        instance.force_set_value(stored_value)\n\n    return instance\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str, **kwargs) -&gt; NamedValue\n</code></pre> <p>Custom JSON deserialization to NamedValue instance.</p> <p>Reconstructs a NamedValue instance from a JSON string representation, restoring all state and stored value information.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>str</code> <p>JSON string to deserialize</p> required <code>**kwargs</code> <p>Additional validation options</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>New instance with restored state</p> Example <pre><code>json_str = '{\"name\": \"example\", \"state\": \"set\", \"stored_value\": 42}'\nvalue = NamedValue.model_validate_json(json_str)\nprint(value.value)  # Outputs: 42\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate_json(cls, json_data: str, **kwargs) -&gt; NamedValue:\n    \"\"\"\n    Custom JSON deserialization to NamedValue instance.\n\n    Reconstructs a NamedValue instance from a JSON string representation,\n    restoring all state and stored value information.\n\n    Args:\n        json_data (str): JSON string to deserialize\n        **kwargs: Additional validation options\n\n    Returns:\n        NamedValue: New instance with restored state\n\n    Example:\n        ```python\n        json_str = '{\"name\": \"example\", \"state\": \"set\", \"stored_value\": 42}'\n        value = NamedValue.model_validate_json(json_str)\n        print(value.value)  # Outputs: 42\n        ```\n    \"\"\"\n    data = json.loads(json_data)\n    return cls.model_validate(data, **kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.register_to_value_hash","title":"register_to_value_hash","text":"<pre><code>register_to_value_hash(h: NamedValueHash) -&gt; Self\n</code></pre> <p>Registers this value instance in a NamedValueHash.</p> <p>Registers this value in the provided hash container. If the hash contains value overrides, this value's current value may be overridden during registration.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>NamedValueHash</code> <p>The hash to register this value in</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>This instance for method chaining</p> Example <pre><code>value_hash = NamedValueHash()\nvalue = NamedValue(\"example\", 42)\nvalue.register_to_value_hash(value_hash).force_set_value(43)\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_to_value_hash(self, h: NamedValueHash) -&gt; Self:\n    \"\"\"\n    Registers this value instance in a NamedValueHash.\n\n    Registers this value in the provided hash container. If the hash contains\n    value overrides, this value's current value may be overridden during\n    registration.\n\n    Args:\n        h (NamedValueHash): The hash to register this value in\n\n    Returns:\n        Self: This instance for method chaining\n\n    Example:\n        ```python\n        value_hash = NamedValueHash()\n        value = NamedValue(\"example\", 42)\n        value.register_to_value_hash(value_hash).force_set_value(43)\n        ```\n    \"\"\"\n    h.register_value(self)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash","title":"NamedValueHash","text":"<p>               Bases: <code>NamedObjectHash</code></p> <p>A type-safe dictionary for storing and managing NamedValue objects.</p> <p>NamedValueHash provides a dictionary-like interface for managing a collection of NamedValue instances, using their names as keys. It ensures type safety and provides convenient methods for accessing and managing the stored values.</p> <p>The hash maintains unique naming across all stored values and supports serialization/deserialization of the entire collection.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category identifier for object registration</p> <code>model_config</code> <code>ConfigDict</code> <p>Pydantic configuration for model behavior</p> Example <pre><code>value_hash = NamedValueHash()\nvalue_hash.register_value(NamedValue(\"count\", 42))\nprint(value_hash.get_raw_value(\"count\"))  # Outputs: 42\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_raw_value","title":"get_raw_value","text":"<pre><code>get_raw_value(name: str) -&gt; Any\n</code></pre> <p>Get the underlying value by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to retrieve</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The actual value stored in the named value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> <code>ValueError</code> <p>If the value hasn't been set yet</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"price\", 10.99))\nprint(hash.get_raw_value(\"price\"))  # Outputs: 10.99\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_raw_value(self, name: str) -&gt; Any:\n    \"\"\"\n    Get the underlying value by name.\n\n    Args:\n        name (str): Name of the value to retrieve\n\n    Returns:\n        Any: The actual value stored in the named value\n\n    Raises:\n        KeyError: If no value exists with the given name\n        ValueError: If the value hasn't been set yet\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"price\", 10.99))\n        print(hash.get_raw_value(\"price\"))  # Outputs: 10.99\n        ```\n    \"\"\"\n    return self.get_value(name).value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_raw_values","title":"get_raw_values","text":"<pre><code>get_raw_values() -&gt; Iterable[Any]\n</code></pre> <p>Get the underlying values of all named values.</p> <p>Returns:</p> Type Description <code>Iterable[Any]</code> <p>Iterable[Any]: Iterator over the actual values stored in each NamedValue</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\nhash.register_value(NamedValue(\"y\", 2))\nprint(list(hash.get_raw_values()))  # Outputs: [1, 2]\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_raw_values(self) -&gt; Iterable[Any]:\n    \"\"\"\n    Get the underlying values of all named values.\n\n    Returns:\n        Iterable[Any]: Iterator over the actual values stored in each NamedValue\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        hash.register_value(NamedValue(\"y\", 2))\n        print(list(hash.get_raw_values()))  # Outputs: [1, 2]\n        ```\n    \"\"\"\n    return (val.value for val in self.get_values())\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_value","title":"get_value","text":"<pre><code>get_value(name: str) -&gt; NamedValue\n</code></pre> <p>Retrieve a named value by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to retrieve</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The requested named value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"price\", 10.99))\nprice = hash.get_value(\"price\")\nprint(price.value)  # Outputs: 10.99\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value(self, name: str) -&gt; NamedValue:\n    \"\"\"\n    Retrieve a named value by its name.\n\n    Args:\n        name (str): Name of the value to retrieve\n\n    Returns:\n        NamedValue: The requested named value\n\n    Raises:\n        KeyError: If no value exists with the given name\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"price\", 10.99))\n        price = hash.get_value(\"price\")\n        print(price.value)  # Outputs: 10.99\n        ```\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_value_by_type","title":"get_value_by_type","text":"<pre><code>get_value_by_type(value_type: Type) -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all values of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>Type</code> <p>Type to filter values by</p> required <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: Values matching the specified type</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\nhash.register_value(NamedValue(\"name\", \"test\"))\nintegers = list(hash.get_value_by_type(int))\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value_by_type(self, value_type: Type) -&gt; Iterable[NamedValue]:\n    \"\"\"\n    Get all values of a specific type.\n\n    Args:\n        value_type (Type): Type to filter values by\n\n    Returns:\n        Iterable[NamedValue]: Values matching the specified type\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        hash.register_value(NamedValue(\"name\", \"test\"))\n        integers = list(hash.get_value_by_type(int))\n        ```\n    \"\"\"\n    return [val for val in self.get_values() if isinstance(val, value_type)]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_value_names","title":"get_value_names","text":"<pre><code>get_value_names() -&gt; Iterable[str]\n</code></pre> <p>Get names of all registered values.</p> <p>Returns:</p> Type Description <code>Iterable[str]</code> <p>Iterable[str]: An iterator over all value names</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\nhash.register_value(NamedValue(\"y\", 2))\nprint(list(hash.get_value_names()))  # Outputs: ['x', 'y']\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value_names(self) -&gt; Iterable[str]:\n    \"\"\"\n    Get names of all registered values.\n\n    Returns:\n        Iterable[str]: An iterator over all value names\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        hash.register_value(NamedValue(\"y\", 2))\n        print(list(hash.get_value_names()))  # Outputs: ['x', 'y']\n        ```\n    \"\"\"\n    return self.get_object_names()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_values","title":"get_values","text":"<pre><code>get_values() -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all registered named values.</p> <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: An iterator over all stored named values</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\nhash.register_value(NamedValue(\"y\", 2))\nfor value in hash.get_values():\n    print(f\"{value.name}: {value.value}\")\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_values(self) -&gt; Iterable[NamedValue]:\n    \"\"\"\n    Get all registered named values.\n\n    Returns:\n        Iterable[NamedValue]: An iterator over all stored named values\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        hash.register_value(NamedValue(\"y\", 2))\n        for value in hash.get_values():\n            print(f\"{value.name}: {value.value}\")\n        ```\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs) -&gt; dict[str, Any]\n</code></pre> <p>Custom serialization to preserve stored values and their states.</p> <p>Creates a dictionary representation of the hash that includes full serialization of all contained NamedValue objects, preserving their values and states.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional serialization options passed to all nested objects</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary containing the complete hash state</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\ndata = hash.model_dump()\nprint(data['objects']['x']['stored_value'])  # Outputs: 1\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"\n    Custom serialization to preserve stored values and their states.\n\n    Creates a dictionary representation of the hash that includes full\n    serialization of all contained NamedValue objects, preserving their\n    values and states.\n\n    Args:\n        **kwargs: Additional serialization options passed to all nested objects\n\n    Returns:\n        dict[str, Any]: Dictionary containing the complete hash state\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        data = hash.model_dump()\n        print(data['objects']['x']['stored_value'])  # Outputs: 1\n        ```\n    \"\"\"\n    data = super().model_dump(**kwargs)\n    # Ensure each object's stored value is included\n    if 'objects' in data:\n        for name, obj in self.objects.items():\n            if isinstance(obj, NamedValue):\n                # Get the full dump including stored value\n                obj_data = obj.model_dump(**kwargs)\n                data['objects'][name] = obj_data\n    return data\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(**kwargs) -&gt; str\n</code></pre> <p>Custom JSON serialization of the entire hash.</p> <p>Serializes the NamedValueHash instance and all contained NamedValue objects to a JSON string representation. Handles both the hash structure and the nested value serialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>JSON serialization options such as: - indent: Number of spaces for pretty printing - ensure_ascii: Escape non-ASCII characters - separators: Tuple of (item_sep, key_sep) for custom formatting</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON string representation of the hash</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"x\", 1))\njson_str = hash.model_dump_json(indent=2)\nprint(json_str)  # Pretty-printed JSON with nested values\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Custom JSON serialization of the entire hash.\n\n    Serializes the NamedValueHash instance and all contained NamedValue\n    objects to a JSON string representation. Handles both the hash structure\n    and the nested value serialization.\n\n    Args:\n        **kwargs: JSON serialization options such as:\n            - indent: Number of spaces for pretty printing\n            - ensure_ascii: Escape non-ASCII characters\n            - separators: Tuple of (item_sep, key_sep) for custom formatting\n\n    Returns:\n        str: JSON string representation of the hash\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"x\", 1))\n        json_str = hash.model_dump_json(indent=2)\n        print(json_str)  # Pretty-printed JSON with nested values\n        ```\n    \"\"\"\n    # Separate JSON-specific kwargs from model_dump kwargs\n    json_kwargs = {k: v for k, v in kwargs.items() if k in {'indent', 'ensure_ascii', 'separators'}}\n    dump_kwargs = {k: v for k, v in kwargs.items() if k not in json_kwargs}\n\n    # Get model data\n    data = self.model_dump(**dump_kwargs)\n    # Serialize to JSON\n    return json.dumps(data, **json_kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(data: Any) -&gt; NamedValueHash\n</code></pre> <p>Custom validation to restore hash state from serialized data.</p> <p>Reconstructs a NamedValueHash instance from serialized data, including all contained NamedValue objects with their values and states.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Serialized data to deserialize. Should be a dictionary containing an 'objects' key with serialized NamedValue instances</p> required <p>Returns:</p> Name Type Description <code>NamedValueHash</code> <code>NamedValueHash</code> <p>New instance with all values restored</p> Example <pre><code>data = {\n    'objects': {\n        'x': {'name': 'x', 'type': 'NamedValue', 'stored_value': 1}\n    }\n}\nhash = NamedValueHash.model_validate(data)\nprint(hash.get_raw_value('x'))  # Outputs: 1\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate(cls, data: Any) -&gt; NamedValueHash:\n    \"\"\"\n    Custom validation to restore hash state from serialized data.\n\n    Reconstructs a NamedValueHash instance from serialized data, including\n    all contained NamedValue objects with their values and states.\n\n    Args:\n        data (Any): Serialized data to deserialize. Should be a dictionary\n            containing an 'objects' key with serialized NamedValue instances\n\n    Returns:\n        NamedValueHash: New instance with all values restored\n\n    Example:\n        ```python\n        data = {\n            'objects': {\n                'x': {'name': 'x', 'type': 'NamedValue', 'stored_value': 1}\n            }\n        }\n        hash = NamedValueHash.model_validate(data)\n        print(hash.get_raw_value('x'))  # Outputs: 1\n        ```\n    \"\"\"\n    if not isinstance(data, dict):\n        return super().model_validate(data)\n\n    instance = cls()\n\n    # Process each object in the data\n    for name, obj_data in data.get('objects', {}).items():\n        if isinstance(obj_data, dict):\n            obj_type = obj_data.get('type')\n            if obj_type:\n                # Get the appropriate class from registry\n                value_class = ObjectRegistry.get(cls._registry_category, obj_type)\n                # Create and validate the object with its stored value\n                value_obj = value_class.model_validate(obj_data)\n                instance.register_value(value_obj)\n\n    return instance\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str, **kwargs) -&gt; NamedValueHash\n</code></pre> <p>Custom JSON deserialization to NamedValueHash instance.</p> <p>Reconstructs a NamedValueHash instance from a JSON string representation, including all contained NamedValue objects with their complete state.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>str</code> <p>JSON string containing serialized hash data</p> required <code>**kwargs</code> <p>Additional validation options for nested objects</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NamedValueHash</code> <code>NamedValueHash</code> <p>New instance with all values restored</p> Example <pre><code>json_str = '''\n{\n    \"objects\": {\n        \"x\": {\"name\": \"x\", \"type\": \"NamedValue\", \"stored_value\": 1}\n    }\n}\n'''\nhash = NamedValueHash.model_validate_json(json_str)\nprint(hash.get_raw_value('x'))  # Outputs: 1\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate_json(cls, json_data: str, **kwargs) -&gt; NamedValueHash:\n    \"\"\"\n    Custom JSON deserialization to NamedValueHash instance.\n\n    Reconstructs a NamedValueHash instance from a JSON string representation,\n    including all contained NamedValue objects with their complete state.\n\n    Args:\n        json_data (str): JSON string containing serialized hash data\n        **kwargs: Additional validation options for nested objects\n\n    Returns:\n        NamedValueHash: New instance with all values restored\n\n    Example:\n        ```python\n        json_str = '''\n        {\n            \"objects\": {\n                \"x\": {\"name\": \"x\", \"type\": \"NamedValue\", \"stored_value\": 1}\n            }\n        }\n        '''\n        hash = NamedValueHash.model_validate_json(json_str)\n        print(hash.get_raw_value('x'))  # Outputs: 1\n        ```\n    \"\"\"\n    data = json.loads(json_data)\n    return cls.model_validate(data, **kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.register_value","title":"register_value","text":"<pre><code>register_value(value: NamedValue) -&gt; Self\n</code></pre> <p>Register a named value in the hash.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>The value to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for method chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a value with the same name already exists</p> Example <pre><code>hash = NamedValueHash()\nvalue = NamedValue(\"price\", 10.99)\nhash.register_value(value).register_value(NamedValue(\"qty\", 5))\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_value(self, value: NamedValue) -&gt; Self:\n    \"\"\"\n    Register a named value in the hash.\n\n    Args:\n        value (NamedValue): The value to register\n\n    Returns:\n        Self: Returns self for method chaining\n\n    Raises:\n        ValueError: If a value with the same name already exists\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        value = NamedValue(\"price\", 10.99)\n        hash.register_value(value).register_value(NamedValue(\"qty\", 5))\n        ```\n    \"\"\"\n    return self.register_object(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.set_raw_value","title":"set_raw_value","text":"<pre><code>set_raw_value(name: str, value: Any) -&gt; None\n</code></pre> <p>Set the underlying value for a named value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to update</p> required <code>value</code> <code>Any</code> <p>New value to set</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> <code>TypeError</code> <p>If value type doesn't match the expected type</p> Example <pre><code>hash = NamedValueHash()\nhash.register_value(NamedValue(\"price\", 10.99))\nhash.set_raw_value(\"price\", 11.99)\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def set_raw_value(self, name: str, value: Any) -&gt; None:\n    \"\"\"\n    Set the underlying value for a named value.\n\n    Args:\n        name (str): Name of the value to update\n        value (Any): New value to set\n\n    Raises:\n        KeyError: If no value exists with the given name\n        TypeError: If value type doesn't match the expected type\n\n    Example:\n        ```python\n        hash = NamedValueHash()\n        hash.register_value(NamedValue(\"price\", 10.99))\n        hash.set_raw_value(\"price\", 11.99)\n        ```\n    \"\"\"\n    self.get_value(name).value = value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList","title":"NamedValueList","text":"<p>               Bases: <code>NamedObjectList</code></p> <p>An ordered list container for managing NamedValue objects.</p> <p>NamedValueList maintains an ordered collection of NamedValue objects while providing type safety and convenient access methods. It preserves insertion order while also allowing access by name.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category identifier for object registration</p> <code>objects</code> <code>List[SerializeAsAny[InstanceOf[NamedValue]]]</code> <p>The list of stored values</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(\"first\", 1))\nvalue_list.append(NamedValue(\"second\", 2))\nprint([v.value for v in value_list])  # Outputs: [1, 2]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NamedValue\n</code></pre> <p>Get a named value by its index in the list.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the named value to retrieve</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The named value at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(name=\"price\", value=10.5))\nfirst_value = value_list[0] # Get first named value\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NamedValue:\n    \"\"\"Get a named value by its index in the list.\n\n    Args:\n        idx (int): Index of the named value to retrieve\n\n    Returns:\n        NamedValue: The named value at the specified index\n\n    Raises:\n        IndexError: If the index is out of range\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.append(NamedValue(name=\"price\", value=10.5))\n        first_value = value_list[0] # Get first named value\n        ```\n    \"\"\"\n    return super().__getitem__(idx)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.append","title":"append","text":"<pre><code>append(value: NamedValue) -&gt; Self\n</code></pre> <p>Append a named value to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>Named value to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The list instance for method chaining</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(\"x\", 1)).append(NamedValue(\"y\", 2))\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def append(self, value: NamedValue) -&gt; Self:\n    \"\"\"\n    Append a named value to the end of the list.\n\n    Args:\n        value (NamedValue): Named value to append\n\n    Returns:\n        Self: The list instance for method chaining\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.append(NamedValue(\"x\", 1)).append(NamedValue(\"y\", 2))\n        ```\n    \"\"\"\n    return super().append(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.extend","title":"extend","text":"<pre><code>extend(values: Iterable[NamedValue]) -&gt; Self\n</code></pre> <p>Extend the list with multiple named values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Iterable[NamedValue]</code> <p>Collection of named values to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The list instance for method chaining</p> Example <pre><code>value_list = NamedValueList()\nnew_values = [NamedValue(\"x\", 1), NamedValue(\"y\", 2)]\nvalue_list.extend(new_values)\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def extend(self, values: Iterable[NamedValue]) -&gt; Self:\n    \"\"\"\n    Extend the list with multiple named values.\n\n    Args:\n        values (Iterable[NamedValue]): Collection of named values to add\n\n    Returns:\n        Self: The list instance for method chaining\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        new_values = [NamedValue(\"x\", 1), NamedValue(\"y\", 2)]\n        value_list.extend(new_values)\n        ```\n    \"\"\"\n    return super().extend(values)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.get_value","title":"get_value","text":"<pre><code>get_value(name: str) -&gt; NamedValue\n</code></pre> <p>Get a registered named value by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to retrieve</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The requested named value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(\"x\", 1))\nx = value_list.get_value(\"x\")\nprint(x.value)  # Outputs: 1\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value(self, name: str) -&gt; NamedValue:\n    \"\"\"\n    Get a registered named value by name.\n\n    Args:\n        name (str): Name of the value to retrieve\n\n    Returns:\n        NamedValue: The requested named value\n\n    Raises:\n        KeyError: If no value exists with the given name\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.append(NamedValue(\"x\", 1))\n        x = value_list.get_value(\"x\")\n        print(x.value)  # Outputs: 1\n        ```\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.get_values","title":"get_values","text":"<pre><code>get_values() -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all registered named values.</p> <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: Iterator over all stored named values</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.extend([NamedValue(\"x\", 1), NamedValue(\"y\", 2)])\nfor value in value_list.get_values():\n    print(f\"{value.name}: {value.value}\")\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_values(self) -&gt; Iterable[NamedValue]:\n    \"\"\"\n    Get all registered named values.\n\n    Returns:\n        Iterable[NamedValue]: Iterator over all stored named values\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.extend([NamedValue(\"x\", 1), NamedValue(\"y\", 2)])\n        for value in value_list.get_values():\n            print(f\"{value.name}: {value.value}\")\n        ```\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs) -&gt; dict[str, Any]\n</code></pre> <p>Custom serialization to preserve stored values.</p> <p>Extends the parent class serialization to ensure proper serialization of all stored named values and their states.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional serialization options</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary containing serialized state</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"\n    Custom serialization to preserve stored values.\n\n    Extends the parent class serialization to ensure proper serialization\n    of all stored named values and their states.\n\n    Args:\n        **kwargs: Additional serialization options\n\n    Returns:\n        dict[str, Any]: Dictionary containing serialized state\n    \"\"\"\n    data = super().model_dump(**kwargs)\n    if 'objects' in data:\n        # Ensure each object's stored value is included\n        data['objects'] = [\n            obj.model_dump(**kwargs) if isinstance(obj, NamedValue) else obj\n            for obj in self.objects\n        ]\n    return data\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(**kwargs) -&gt; str\n</code></pre> <p>Custom JSON serialization of the value list.</p> <p>Serializes the NamedValueList instance and all contained NamedValue objects to a JSON string representation. Preserves the order of values and their complete state.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>JSON serialization options such as: - indent: Number of spaces for pretty printing - ensure_ascii: Escape non-ASCII characters - separators: Tuple of (item_sep, key_sep) for custom formatting</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON string representation of the list</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.append(NamedValue(\"x\", 1))\nvalue_list.append(NamedValue(\"y\", 2))\njson_str = value_list.model_dump_json(indent=2)\nprint(json_str)  # Pretty-printed JSON with ordered values\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def model_dump_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Custom JSON serialization of the value list.\n\n    Serializes the NamedValueList instance and all contained NamedValue\n    objects to a JSON string representation. Preserves the order of values\n    and their complete state.\n\n    Args:\n        **kwargs: JSON serialization options such as:\n            - indent: Number of spaces for pretty printing\n            - ensure_ascii: Escape non-ASCII characters\n            - separators: Tuple of (item_sep, key_sep) for custom formatting\n\n    Returns:\n        str: JSON string representation of the list\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.append(NamedValue(\"x\", 1))\n        value_list.append(NamedValue(\"y\", 2))\n        json_str = value_list.model_dump_json(indent=2)\n        print(json_str)  # Pretty-printed JSON with ordered values\n        ```\n    \"\"\"\n    # Separate JSON-specific kwargs from model_dump kwargs\n    json_kwargs = {k: v for k, v in kwargs.items() if k in {'indent', 'ensure_ascii', 'separators'}}\n    dump_kwargs = {k: v for k, v in kwargs.items() if k not in json_kwargs}\n\n    # Get model data\n    data = self.model_dump(**dump_kwargs)\n    # Serialize to JSON\n    return json.dumps(data, **json_kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(data: Any) -&gt; NamedValueList\n</code></pre> <p>Custom validation to restore stored values.</p> <p>Reconstructs a NamedValueList instance from serialized data, properly restoring all contained named values and their states.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Serialized data to deserialize</p> required <p>Returns:</p> Name Type Description <code>NamedValueList</code> <code>NamedValueList</code> <p>New instance with restored values</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate(cls, data: Any) -&gt; NamedValueList:\n    \"\"\"\n    Custom validation to restore stored values.\n\n    Reconstructs a NamedValueList instance from serialized data,\n    properly restoring all contained named values and their states.\n\n    Args:\n        data (Any): Serialized data to deserialize\n\n    Returns:\n        NamedValueList: New instance with restored values\n    \"\"\"\n    if not isinstance(data, dict):\n        return super().model_validate(data)\n\n    instance = cls()\n\n    # Process each object in the data\n    for obj_data in data.get('objects', []):\n        if isinstance(obj_data, dict):\n            obj_type = obj_data.get('type')\n            if obj_type:\n                # Get the appropriate class from registry\n                value_class = ObjectRegistry.get(cls._registry_category, obj_type)\n                # Create and validate the object\n                value_obj = value_class.model_validate(obj_data)\n                instance.append(value_obj)\n\n    return instance\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str, **kwargs) -&gt; NamedValueList\n</code></pre> <p>Custom JSON deserialization to NamedValueList instance.</p> <p>Reconstructs a NamedValueList instance from a JSON string representation, preserving the order of values and restoring their complete state.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>str</code> <p>JSON string containing serialized list data</p> required <code>**kwargs</code> <p>Additional validation options for nested objects</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NamedValueList</code> <code>NamedValueList</code> <p>New instance with all values restored in order</p> Example <pre><code>json_str = '''\n{\n    \"objects\": [\n        {\"name\": \"x\", \"type\": \"NamedValue\", \"stored_value\": 1},\n        {\"name\": \"y\", \"type\": \"NamedValue\", \"stored_value\": 2}\n    ]\n}\n'''\nvalue_list = NamedValueList.model_validate_json(json_str)\nprint([v.value for v in value_list])  # Outputs: [1, 2]\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>@classmethod\ndef model_validate_json(cls, json_data: str, **kwargs) -&gt; NamedValueList:\n    \"\"\"\n    Custom JSON deserialization to NamedValueList instance.\n\n    Reconstructs a NamedValueList instance from a JSON string representation,\n    preserving the order of values and restoring their complete state.\n\n    Args:\n        json_data (str): JSON string containing serialized list data\n        **kwargs: Additional validation options for nested objects\n\n    Returns:\n        NamedValueList: New instance with all values restored in order\n\n    Example:\n        ```python\n        json_str = '''\n        {\n            \"objects\": [\n                {\"name\": \"x\", \"type\": \"NamedValue\", \"stored_value\": 1},\n                {\"name\": \"y\", \"type\": \"NamedValue\", \"stored_value\": 2}\n            ]\n        }\n        '''\n        value_list = NamedValueList.model_validate_json(json_str)\n        print([v.value for v in value_list])  # Outputs: [1, 2]\n        ```\n    \"\"\"\n    data = json.loads(json_data)\n    return cls.model_validate(data, **kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.register_value","title":"register_value","text":"<pre><code>register_value(value: NamedValue) -&gt; Self\n</code></pre> <p>Register a named value to the list.</p> <p>Similar to append but uses the register_object method internally, which may perform additional validation.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>Named value to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The list instance for method chaining</p> Example <pre><code>value_list = NamedValueList()\nvalue_list.register_value(NamedValue(\"x\", 1))\n</code></pre> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_value(self, value: NamedValue) -&gt; Self:\n    \"\"\"\n    Register a named value to the list.\n\n    Similar to append but uses the register_object method internally,\n    which may perform additional validation.\n\n    Args:\n        value (NamedValue): Named value to register\n\n    Returns:\n        Self: The list instance for method chaining\n\n    Example:\n        ```python\n        value_list = NamedValueList()\n        value_list.register_value(NamedValue(\"x\", 1))\n        ```\n    \"\"\"\n    return self.register_object(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueState","title":"NamedValueState","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>State enumeration for NamedValue objects.</p> <p>This enum tracks whether a named value has been set or remains unset. Once set, values are typically frozen unless explicitly forced to change.</p> <p>Attributes:</p> Name Type Description <code>UNSET</code> <p>Indicates no value has been set yet</p> <code>SET</code> <p>Indicates value has been set and is frozen</p>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueState.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Get string representation for debugging.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The state value as a string (\"unset\" or \"set\")</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Get string representation for debugging.\n\n    Returns:\n        str: The state value as a string (\"unset\" or \"set\")\n    \"\"\"\n    return self.value  # Returns just \"unset\" or \"set\"\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueState.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Convert state to string representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The state value as a string (\"unset\" or \"set\")</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Convert state to string representation.\n\n    Returns:\n        str: The state value as a string (\"unset\" or \"set\")\n    \"\"\"\n    return self.value  # Returns just \"unset\" or \"set\"\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/","title":"custom_serde_definitions","text":""},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions","title":"custom_serde_definitions","text":"<p>Defines custom serialization and deserialization definitions for the process manager inputs.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.PandasDataFrame","title":"PandasDataFrame  <code>module-attribute</code>","text":"<pre><code>PandasDataFrame = Annotated[\n    DataFrame, BeforeValidator(to_dataframe), WrapSerializer(from_dataframe)\n]\n</code></pre> <p>Type alias for Pandas DataFrame objects that can be serialized and deserialized. This type alias is used to define the expected data structure when working with Pandas DataFrame objects in a way that allows them to be both serialized and deserialized using the <code>DataFrameSerDe</code> class. The <code>PandasDataFrame</code> type alias is defined as an Annotated type, which means it has two type arguments: <code>pd.DataFrame</code>, which specifies the expected data structure for this type, and a BeforeValidator and PlainSerializer, respectively. This allows you to use Pandas DataFrame objects in your code while ensuring that they can be serialized and deserialized using the <code>DataFrameSerDe</code> class.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.PandasSeries","title":"PandasSeries  <code>module-attribute</code>","text":"<pre><code>PandasSeries = Annotated[Series, BeforeValidator(to_series), WrapSerializer(from_series)]\n</code></pre> <p>Type alias for Pandas Series objects that can be serialized and deserialized. This type alias is used to define the expected data structure when working with Pandas Series objects in a way that allows them to be both serialized and deserialized using the <code>SeriesSerDe</code> class. The <code>PandasSeries</code> type alias is defined as an Annotated type, which means it has two type arguments: <code>pd.Series</code>, which specifies the expected data structure for this type, and a BeforeValidator and PlainSerializer, respectively. This allows you to use Pandas Series objects in your code while ensuring that they can be serialized and deserialized using the <code>SeriesSerDe</code> class.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe","title":"DataFrameSerDe","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to serialize and deserialize Pandas DataFrame objects.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>NDArray[Shape['*'], Any]</code> <p>Column names of the dataframe</p> <code>values</code> <code>NDArray[Shape['*, *'], Any]</code> <p>Values of the dataframe</p> <code>index</code> <code>NDArray[Shape['*'], Any]</code> <p>Index of the dataframe</p> <code>index_name</code> <code>int | str | None</code> <p>Name of the index</p> <code>column_names</code> <code>list[int | str | None]</code> <p>Names of the columns</p> <p>Methods:     as_dataframe(): Convert to Pandas DataFrame object     from_dict(data: dict) -&gt; DataFrameSerDe: Create a new instance from a dictionary     model_validate_json(json: str | bytes, loc: Any = None, prop: Any = None, cls: Any = None, **kwargs: Any) -&gt; Self: Validate and deserialize JSON data into the model.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe.as_dataframe","title":"as_dataframe","text":"<pre><code>as_dataframe()\n</code></pre> <p>Convert to Pandas DataFrame object.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame object from stored data</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def as_dataframe(self):\n    \"\"\"\n    Convert to Pandas DataFrame object.\n\n    Returns:\n        (pd.DataFrame): Pandas DataFrame object from stored data\n    \"\"\"\n    return pd.DataFrame(\n        self.values, \n        columns=pd.Index(self.columns, name=self.column_names), \n        index=pd.Index(self.index, name=self.index_name)\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(df: DataFrame, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)\n</code></pre> <p>Create a new instance from a Pandas DataFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Pandas DataFrame object to convert.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the Pandas DataFrame object.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dataframe(cls, df: pd.DataFrame, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo):\n    \"\"\"\n    Create a new instance from a Pandas DataFrame object.\n\n    Args:\n        df (pd.DataFrame): Pandas DataFrame object to convert.\n\n    Returns:\n        (cls): New instance created from the Pandas DataFrame object.\n    \"\"\"\n    return cls(\n        columns=df.columns.values,\n        values=df.values,\n        index=df.index.values,\n        index_name=df.index.name,\n        column_names=df.columns.name\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict)\n</code></pre> <p>Create a new instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>New DataFrame created from the dictionary.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a new instance from a dictionary.\n\n    Args:\n        d (dict): Dictionary containing the data.\n\n    Returns:\n        (pd.DataFrame): New DataFrame created from the dictionary.\n    \"\"\"\n    try:\n        return pd.DataFrame(\n            d['values'],\n            columns=pd.Index(d['columns'], name=d['column_names']),\n            index=pd.Index(d['index'], name=d['index_name'])\n        )\n    except:\n        raise ValueError(d)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe.to_dataframe","title":"to_dataframe  <code>classmethod</code>","text":"<pre><code>to_dataframe(input: DataFrame | dict | str)\n</code></pre> <p>Convert input to a Pandas DataFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DataFrame | dict | str</code> <p>Input data to convert.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame object from input data.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef to_dataframe(cls, input: pd.DataFrame | dict | str):\n    \"\"\"\n    Convert input to a Pandas DataFrame object.\n\n    Args:\n        input (pd.DataFrame | dict | str): Input data to convert.\n\n    Returns:\n        (pd.DataFrame): Pandas DataFrame object from input data.\n    \"\"\"\n    if isinstance(input, str):\n        return cls.model_validate_json(input).as_dataframe()\n    elif isinstance(input, dict):\n        return cls.from_dict(input)\n    elif isinstance(input, pd.DataFrame):\n        return input\n    else:\n        # breakpoint()\n        raise ValueError(input)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe","title":"SeriesSerDe","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to serialize and deserialize Pandas Series objects.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>int | str | None</code> <p>Name of the series</p> <code>values</code> <code>NDArray[Shape['*'], Any]</code> <p>Values of the series</p> <code>index</code> <code>NDArray[Shape['*'], Any]</code> <p>Index of the series</p> <code>index_name</code> <code>int | str | None</code> <p>Name of the index</p> <p>Methods:     as_series(): Convert to Pandas Series object     from_dict(data: dict) -&gt; SeriesSerDe: Create a new instance from a dictionary     model_validate_json(json: str | bytes, loc: Any = None, prop: Any = None, cls: Any = None, **kwargs: Any) -&gt; Self: Validate and deserialize JSON data into the model.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe.as_series","title":"as_series","text":"<pre><code>as_series()\n</code></pre> <p>Convert to Pandas Series object.</p> <p>Returns:</p> Type Description <code>Series</code> <p>Pandas Series object from stored data</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def as_series(self):\n    \"\"\"\n    Convert to Pandas Series object.\n\n    Returns:\n        (pd.Series): Pandas Series object from stored data\n    \"\"\"\n    return pd.Series(self.values, name=self.name, index=pd.Index(self.index, name=self.index_name))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict)\n</code></pre> <p>Create a new instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing the data.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the dictionary.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a new instance from a dictionary.\n\n    Args:\n        d (dict): Dictionary containing the data.\n\n    Returns:\n        (cls): New instance created from the dictionary.\n    \"\"\"\n    try:\n        return pd.Series(\n            d['values'], \n            name=d['name'],\n            index=pd.Index(\n                d['index'], \n                name=d['index_name'],\n            ),\n        )\n    except:\n        raise ValueError(d)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe.from_series","title":"from_series  <code>classmethod</code>","text":"<pre><code>from_series(series: Series, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)\n</code></pre> <p>Create a new instance from a Pandas Series object.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Pandas Series object to convert.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the Pandas Series object.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_series(cls, series: pd.Series, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo):\n    \"\"\"\n    Create a new instance from a Pandas Series object.\n\n    Args:\n        series (pd.Series): Pandas Series object to convert.\n\n    Returns:\n        (cls): New instance created from the Pandas Series object.\n    \"\"\"\n    return cls(\n        name=series.name,\n        values=series.values,\n        index=series.index.values,\n        index_name=series.index.name,\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe.to_series","title":"to_series  <code>classmethod</code>","text":"<pre><code>to_series(input: Series | dict | str)\n</code></pre> <p>Convert input to a Pandas Series object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Series | dict | str</code> <p>Input data to convert.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Pandas Series object from input data.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef to_series(cls, input: pd.Series | dict | str):\n    \"\"\"\n    Convert input to a Pandas Series object.\n\n    Args:\n        input (pd.Series | dict | str): Input data to convert.\n\n    Returns:\n        (pd.Series): Pandas Series object from input data.\n    \"\"\"\n    if isinstance(input, str):\n        print('str')\n        return cls.model_validate_json(input).as_series()\n    elif isinstance(input, dict):\n        print('dict')\n        return cls.from_dict(input)\n    elif isinstance(input, pd.Series):\n        print('series')\n        return input\n    else:\n        raise ValueError(input)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/","title":"pandantic","text":""},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic","title":"pandantic","text":"<p>Defines types for Pandas Series and DataFrame serialization and deserialization.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.PandasDataFrame","title":"PandasDataFrame  <code>module-attribute</code>","text":"<pre><code>PandasDataFrame = Annotated[\n    DataFrame, BeforeValidator(to_dataframe), WrapSerializer(from_dataframe)\n]\n</code></pre> <p>Type alias for Pandas DataFrame objects that can be serialized and deserialized. This type alias is used to define the expected data structure when working with Pandas DataFrame objects in a way that allows them to be both serialized and deserialized using the <code>DataFrameSerDe</code> class. The <code>PandasDataFrame</code> type alias is defined as an Annotated type, which means it has two type arguments: <code>pd.DataFrame</code>, which specifies the expected data structure for this type, and a BeforeValidator and PlainSerializer, respectively. This allows you to use Pandas DataFrame objects in your code while ensuring that they can be serialized and deserialized using the <code>DataFrameSerDe</code> class.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.PandasSeries","title":"PandasSeries  <code>module-attribute</code>","text":"<pre><code>PandasSeries = Annotated[Series, BeforeValidator(to_series), WrapSerializer(from_series)]\n</code></pre> <p>Type alias for Pandas Series objects that can be serialized and deserialized. This type alias is used to define the expected data structure when working with Pandas Series objects in a way that allows them to be both serialized and deserialized using the <code>SeriesSerDe</code> class. The <code>PandasSeries</code> type alias is defined as an Annotated type, which means it has two type arguments: <code>pd.Series</code>, which specifies the expected data structure for this type, and a BeforeValidator and PlainSerializer, respectively. This allows you to use Pandas Series objects in your code while ensuring that they can be serialized and deserialized using the <code>SeriesSerDe</code> class.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe","title":"DataFrameSerDe","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to serialize and deserialize Pandas DataFrame objects.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>NDArray[Shape['*'], Any]</code> <p>Column names of the dataframe</p> <code>values</code> <code>NDArray[Shape['*, *'], Any]</code> <p>Values of the dataframe</p> <code>index</code> <code>NDArray[Shape['*'], Any]</code> <p>Index of the dataframe</p> <code>index_name</code> <code>int | str | None</code> <p>Name of the index</p> <code>column_names</code> <code>list[int | str | None]</code> <p>Names of the columns</p> <p>Methods:     as_dataframe(): Convert to Pandas DataFrame object     from_dict(data: dict) -&gt; DataFrameSerDe: Create a new instance from a dictionary     model_validate_json(json: str | bytes, loc: Any = None, prop: Any = None, cls: Any = None, **kwargs: Any) -&gt; Self: Validate and deserialize JSON data into the model.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe.as_dataframe","title":"as_dataframe","text":"<pre><code>as_dataframe()\n</code></pre> <p>Convert to Pandas DataFrame object.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame object from stored data</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def as_dataframe(self):\n    \"\"\"\n    Convert to Pandas DataFrame object.\n\n    Returns:\n        (pd.DataFrame): Pandas DataFrame object from stored data\n    \"\"\"\n    return pd.DataFrame(\n        self.values, \n        columns=pd.Index(self.columns, name=self.column_names), \n        index=pd.Index(self.index, name=self.index_name)\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(df: DataFrame, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)\n</code></pre> <p>Create a new instance from a Pandas DataFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Pandas DataFrame object to convert.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the Pandas DataFrame object.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dataframe(cls, df: pd.DataFrame, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo):\n    \"\"\"\n    Create a new instance from a Pandas DataFrame object.\n\n    Args:\n        df (pd.DataFrame): Pandas DataFrame object to convert.\n\n    Returns:\n        (cls): New instance created from the Pandas DataFrame object.\n    \"\"\"\n    return cls(\n        columns=df.columns.values,\n        values=df.values,\n        index=df.index.values,\n        index_name=df.index.name,\n        column_names=df.columns.name\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict)\n</code></pre> <p>Create a new instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>New DataFrame created from the dictionary.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a new instance from a dictionary.\n\n    Args:\n        d (dict): Dictionary containing the data.\n\n    Returns:\n        (pd.DataFrame): New DataFrame created from the dictionary.\n    \"\"\"\n    try:\n        return pd.DataFrame(\n            d['values'],\n            columns=pd.Index(d['columns'], name=d['column_names']),\n            index=pd.Index(d['index'], name=d['index_name'])\n        )\n    except:\n        raise ValueError(d)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe.to_dataframe","title":"to_dataframe  <code>classmethod</code>","text":"<pre><code>to_dataframe(input: DataFrame | dict | str)\n</code></pre> <p>Convert input to a Pandas DataFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DataFrame | dict | str</code> <p>Input data to convert.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame object from input data.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef to_dataframe(cls, input: pd.DataFrame | dict | str):\n    \"\"\"\n    Convert input to a Pandas DataFrame object.\n\n    Args:\n        input (pd.DataFrame | dict | str): Input data to convert.\n\n    Returns:\n        (pd.DataFrame): Pandas DataFrame object from input data.\n    \"\"\"\n    if isinstance(input, str):\n        return cls.model_validate_json(input).as_dataframe()\n    elif isinstance(input, dict):\n        return cls.from_dict(input)\n    elif isinstance(input, pd.DataFrame):\n        return input\n    else:\n        # breakpoint()\n        raise ValueError(input)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe","title":"SeriesSerDe","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to serialize and deserialize Pandas Series objects.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>int | str | None</code> <p>Name of the series</p> <code>values</code> <code>NDArray[Shape['*'], Any]</code> <p>Values of the series</p> <code>index</code> <code>NDArray[Shape['*'], Any]</code> <p>Index of the series</p> <code>index_name</code> <code>int | str | None</code> <p>Name of the index</p> <p>Methods:     as_series(): Convert to Pandas Series object     from_dict(data: dict) -&gt; SeriesSerDe: Create a new instance from a dictionary     model_validate_json(json: str | bytes, loc: Any = None, prop: Any = None, cls: Any = None, **kwargs: Any) -&gt; Self: Validate and deserialize JSON data into the model.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe.as_series","title":"as_series","text":"<pre><code>as_series()\n</code></pre> <p>Convert to Pandas Series object.</p> <p>Returns:</p> Type Description <code>Series</code> <p>Pandas Series object from stored data</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def as_series(self):\n    \"\"\"\n    Convert to Pandas Series object.\n\n    Returns:\n        (pd.Series): Pandas Series object from stored data\n    \"\"\"\n    return pd.Series(self.values, name=self.name, index=pd.Index(self.index, name=self.index_name))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict)\n</code></pre> <p>Create a new instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing the data.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the dictionary.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a new instance from a dictionary.\n\n    Args:\n        d (dict): Dictionary containing the data.\n\n    Returns:\n        (cls): New instance created from the dictionary.\n    \"\"\"\n    try:\n        return pd.Series(\n            d['values'], \n            name=d['name'],\n            index=pd.Index(\n                d['index'], \n                name=d['index_name'],\n            ),\n        )\n    except:\n        raise ValueError(d)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe.from_series","title":"from_series  <code>classmethod</code>","text":"<pre><code>from_series(series: Series, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)\n</code></pre> <p>Create a new instance from a Pandas Series object.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Pandas Series object to convert.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the Pandas Series object.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_series(cls, series: pd.Series, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo):\n    \"\"\"\n    Create a new instance from a Pandas Series object.\n\n    Args:\n        series (pd.Series): Pandas Series object to convert.\n\n    Returns:\n        (cls): New instance created from the Pandas Series object.\n    \"\"\"\n    return cls(\n        name=series.name,\n        values=series.values,\n        index=series.index.values,\n        index_name=series.index.name,\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe.to_series","title":"to_series  <code>classmethod</code>","text":"<pre><code>to_series(input: Series | dict | str)\n</code></pre> <p>Convert input to a Pandas Series object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Series | dict | str</code> <p>Input data to convert.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Pandas Series object from input data.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef to_series(cls, input: pd.Series | dict | str):\n    \"\"\"\n    Convert input to a Pandas Series object.\n\n    Args:\n        input (pd.Series | dict | str): Input data to convert.\n\n    Returns:\n        (pd.Series): Pandas Series object from input data.\n    \"\"\"\n    if isinstance(input, str):\n        print('str')\n        return cls.model_validate_json(input).as_series()\n    elif isinstance(input, dict):\n        print('dict')\n        return cls.from_dict(input)\n    elif isinstance(input, pd.Series):\n        print('series')\n        return input\n    else:\n        raise ValueError(input)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.np_encoder","title":"np_encoder","text":"<pre><code>np_encoder(object)\n</code></pre> <p>JSON encoder function for numpy types.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Any</code> <p>Object to encode</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Encoded object</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def np_encoder(object):\n    \"\"\"\n    JSON encoder function for numpy types.\n\n    Args:\n        object (Any): Object to encode\n\n    Returns:\n        Any: Encoded object\n    \"\"\"\n    if isinstance(object, np.generic):\n        return object.item()\n    else:\n        return object\n</code></pre>"}]}
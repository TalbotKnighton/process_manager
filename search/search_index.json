{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Process Manager Documentation","text":"<p>Welcome to the Process Manager documentation. This documentation covers the design principles, implementation details, and API reference for the process management system.</p>"},{"location":"#core-components","title":"Core Components","text":"<ul> <li>Named Values: Type-safe value containers with validation</li> <li>Random Variables: Statistical distribution implementations</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Data Handlers</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Todo</p> <p>Add getting started guides and tutorials.</p>"},{"location":"named_values/","title":"NamedValue Design","text":"<p>The <code>NamedValue</code> class implements a type-safe container for named values with built-in validation and serialization support. It follows several key design principles to ensure robust and flexible value handling.</p>"},{"location":"named_values/#core-design-principles","title":"Core Design Principles","text":""},{"location":"named_values/#1-type-safety","title":"1. Type Safety","text":"<p>The <code>NamedValue</code> class uses Python's generic typing system to enforce type safety at both runtime and static analysis time:</p> <pre><code># Type-safe value container\narray_value = NamedValue[np.ndarray](\"my_array\", value=np.array([1, 2, 3]))\nint_value = NamedValue[int](\"my_int\", value=42)\n</code></pre> <p>Type safety is enforced through: - Generic type parameters (<code>NamedValue[T]</code>) - Runtime type validation - Automatic type conversion when possible - Clear error messages when types don't match</p>"},{"location":"named_values/#2-value-immutability","title":"2. Value Immutability","text":"<p>Values are immutable by default after initial setting to prevent accidental modifications:</p> <pre><code>value = NamedValue[int](\"counter\", 1)\nvalue.value = 2  # Raises ValueError - value is frozen\nvalue.force_set_value(2)  # Explicit override when needed\n</code></pre>"},{"location":"named_values/#3-flexible-type-conversion","title":"3. Flexible Type Conversion","text":"<p>The system attempts to convert values to the correct type when possible:</p> <pre><code># String to int conversion\nint_value = NamedValue[int](\"count\", \"123\")  # Automatically converts to int(123)\n\n# Float to int conversion\nint_value = NamedValue[int](\"count\", 123.0)  # Automatically converts to int(123)\n</code></pre>"},{"location":"named_values/#4-inheritance-support","title":"4. Inheritance Support","text":"<p>Two different patterns are supported for extending <code>NamedValue</code>:</p> <ol> <li> <p>Direct generic usage: <pre><code>value = NamedValue[int](\"my_int\", 42)\n</code></pre></p> </li> <li> <p>Subclass with custom behavior: <pre><code>class IntegerValue(NamedValue[int]):\n    def __init__(self, name: str, value: int = None):\n        super().__init__(name, value)\n</code></pre></p> </li> </ol>"},{"location":"named_values/#error-handling-design","title":"Error Handling Design","text":"<p>The class implements a sophisticated error handling system that distinguishes between different usage patterns:</p> <ol> <li> <p>Direct Usage Errors (TypeError): <pre><code># Raises TypeError with detailed type information\nvalue = NamedValue[int](\"test\", \"not an integer\")\n</code></pre></p> </li> <li> <p>Subclass Usage Errors (ValueError): <pre><code># Raises ValueError with user-friendly message\nclass IntegerValue(NamedValue[int]):\n    pass\nvalue = IntegerValue(\"test\", \"not an integer\")\n</code></pre></p> </li> </ol>"},{"location":"named_values/#testing-strategy","title":"Testing Strategy","text":"<p>The design principles are verified through comprehensive testing:</p>"},{"location":"named_values/#1-type-safety-tests","title":"1. Type Safety Tests","text":"<pre><code>def test_type_checking(self):\n    # Test with explicit type parameter\n    class IntValue(NamedValue[int]):\n        pass\n\n    # Valid integer assignment\n    int_value = IntValue(\"test\", 42)\n    assert int_value.value == 42\n\n    # Valid string that can be cast to int\n    str_int_value = IntValue(\"test2\", \"123\")\n    assert str_int_value.value == 123\n\n    # Invalid type that can't be cast\n    with pytest.raises(TypeError):\n        IntValue(\"test3\", \"not an integer\")\n</code></pre>"},{"location":"named_values/#2-inheritance-tests","title":"2. Inheritance Tests","text":"<pre><code>def test_type_casting_inheritance(self):\n    class IntegerValue(NamedValue[int]):\n        def __init__(self, name: str, value: int = None):\n            super().__init__(name, value)\n\n    # Test valid assignment\n    int_value = IntegerValue(\"test\", 42)\n    assert isinstance(int_value.value, int)\n\n    # Test type hints are preserved\n    with pytest.raises(ValueError):\n        IntegerValue(\"test\", \"not an integer\")\n</code></pre>"},{"location":"named_values/#3-value-immutability-tests","title":"3. Value Immutability Tests","text":"<pre><code>def test_value_immutability(self):\n    value = NamedValue[int](\"test\", 42)\n\n    # Cannot change value after setting\n    with pytest.raises(ValueError):\n        value.value = 43\n\n    # Can force change value when needed\n    value.force_set_value(43)\n    assert value.value == 43\n</code></pre>"},{"location":"named_values/#serialization-support","title":"Serialization Support","text":"<p>The class implements JSON serialization support through pydantic:</p> <pre><code>value = NamedValue[int](\"counter\", 42)\nserialized = value.model_dump_json()\ndeserialized = NamedValue.model_validate_json(serialized)\n</code></pre>"},{"location":"named_values/#usage-guidelines","title":"Usage Guidelines","text":"<ol> <li> <p>Use direct generic syntax for simple value containers: <pre><code>value = NamedValue[int](\"simple_counter\", 0)\n</code></pre></p> </li> <li> <p>Create subclasses for custom validation or behavior: <pre><code>class PositiveInteger(NamedValue[int]):\n    def _validate_type(self, value: Any) -&gt; int:\n        value = super()._validate_type(value)\n        if value &lt;= 0:\n            raise ValueError(\"Value must be positive\")\n        return value\n</code></pre></p> </li> <li> <p>Use <code>force_set_value()</code> only when value mutability is explicitly needed: <pre><code>value.force_set_value(new_value)  # Use with caution\n</code></pre></p> </li> </ol>"},{"location":"named_values/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always specify the type parameter for clarity: <pre><code># Good\nvalue = NamedValue[int](\"count\", 42)\n\n# Avoid\nvalue = NamedValue(\"count\", 42)  # Type defaults to Any\n</code></pre></p> </li> <li> <p>Use meaningful names that describe the value's purpose: <pre><code># Good\ncount = NamedValue[int](\"iteration_count\", 0)\n\n# Avoid\nx = NamedValue[int](\"x\", 0)  # Name is not descriptive\n</code></pre></p> </li> <li> <p>Handle type conversion errors appropriately: <pre><code>try:\n    value = NamedValue[int](\"count\", user_input)\nexcept (TypeError, ValueError) as e:\n    # Handle invalid input\n    pass\n</code></pre></p> </li> </ol> <p>By following these design principles and usage patterns, <code>NamedValue</code> provides a robust and type-safe way to manage named values in your application.</p>"},{"location":"python_metaclasses/","title":"Python Metaclasses Guide","text":""},{"location":"python_metaclasses/#core-concepts","title":"Core Concepts","text":"<ol> <li>A metaclass is a class for a class - it allows you to customize class creation</li> <li>Metaclasses are called when a class is defined, not when it's instantiated</li> <li>The metaclass can modify the class definition before it's created</li> </ol>"},{"location":"python_metaclasses/#key-rules","title":"Key Rules","text":""},{"location":"python_metaclasses/#1-inheritance-rules","title":"1. Inheritance Rules","text":"<ul> <li>Metaclasses are inherited by subclasses</li> <li>If a class has a metaclass, all its subclasses must be compatible with that metaclass</li> <li>When there are multiple metaclasses in the inheritance hierarchy, they must be compatible</li> </ul>"},{"location":"python_metaclasses/#2-creation-order","title":"2. Creation Order","text":"<pre><code>class MyMetaclass(type):\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        # 1. __new__ is called first\n        return super().__new__(mcs, name, bases, namespace)\n\n    def __init__(cls, name, bases, namespace, **kwargs):\n        # 2. __init__ is called after __new__\n        super().__init__(name, bases, namespace)\n\n    def __call__(cls, *args, **kwargs):\n        # 3. __call__ is called when creating instances\n        return super().__call__(*args, **kwargs)\n</code></pre>"},{"location":"python_metaclasses/#3-declaration-methods","title":"3. Declaration Methods","text":"<pre><code># Method 1: metaclass keyword\nclass MyClass(metaclass=MyMetaclass):\n    pass\n\n# Method 2: inheritance from a class with metaclass\nclass MyMetaclassBase(metaclass=MyMetaclass):\n    pass\nclass MyClass(MyMetaclassBase):\n    pass\n</code></pre>"},{"location":"python_metaclasses/#4-common-use-cases","title":"4. Common Use Cases","text":"<pre><code>class RegisterMeta(type):\n    registry = {}\n\n    def __new__(mcs, name, bases, namespace):\n        # Register all classes using this metaclass\n        cls = super().__new__(mcs, name, bases, namespace)\n        mcs.registry[name] = cls\n        return cls\n\nclass ValidatorMeta(type):\n    def __new__(mcs, name, bases, namespace):\n        # Add validation to all methods\n        for key, value in namespace.items():\n            if callable(value):\n                namespace[key] = validate(value)\n        return super().__new__(mcs, name, bases, namespace)\n</code></pre>"},{"location":"python_metaclasses/#5-working-with-other-metaclasses","title":"5. Working with Other Metaclasses","text":"<pre><code># Combining metaclasses\nclass CombinedMeta(MetaclassA, MetaclassB):\n    def __new__(mcs, name, bases, namespace):\n        # Call both metaclass's __new__\n        namespace = MetaclassA.__new__(mcs, name, bases, namespace)\n        return MetaclassB.__new__(mcs, name, bases, namespace)\n</code></pre>"},{"location":"python_metaclasses/#recommended-references","title":"Recommended References","text":""},{"location":"python_metaclasses/#1-official-python-documentation","title":"1. Official Python Documentation","text":"<ul> <li>Python Data Model</li> <li>Custom Metaclasses</li> </ul>"},{"location":"python_metaclasses/#2-books","title":"2. Books","text":"<ul> <li>\"Python in a Nutshell\" by Alex Martelli (O'Reilly)</li> <li>\"Fluent Python\" by Luciano Ramalho (O'Reilly)</li> </ul>"},{"location":"python_metaclasses/#3-real-world-example","title":"3. Real-world Example","text":"<pre><code>class RandomVariableMeta(type(BaseModel)):\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        # Automatically apply squeezable decorator\n        for method in ['sample', 'pdf', 'cdf']:\n            if method in namespace and callable(namespace[method]):\n                namespace[method] = squeezable(namespace[method])\n        return super().__new__(mcs, name, bases, namespace, **kwargs)\n</code></pre>"},{"location":"python_metaclasses/#common-gotchas","title":"Common Gotchas","text":"<ol> <li>Multiple Inheritance: Be careful when combining classes with different metaclasses</li> <li>Order of Operations: Remember metaclass code runs during class definition</li> <li>Performance: Metaclasses can impact class creation performance</li> <li>Complexity: They can make code harder to understand if overused</li> </ol>"},{"location":"python_metaclasses/#best-practices","title":"Best Practices","text":"<ol> <li>Use metaclasses sparingly - only when class decorators or inheritance won't suffice</li> <li>Document metaclass behavior clearly</li> <li>Keep metaclass logic simple and focused</li> <li>Consider alternatives like class decorators or descriptors first</li> </ol>"},{"location":"random_variables/","title":"Random Variable Design","text":"<p>The random variable system provides a flexible and type-safe way to define, sample, and manage random variables in simulations. It implements a hierarchical design pattern where specific distributions inherit from a base random variable class.</p>"},{"location":"random_variables/#core-design-principles","title":"Core Design Principles","text":""},{"location":"random_variables/#1-type-safety-and-validation","title":"1. Type Safety and Validation","text":"<p>The system uses Python's type hints and runtime validation to ensure distributions are configured correctly:</p> <pre><code># Type-safe parameter definitions\nclass NormalRandomVariable(RandomVariable[float]):\n    mean: float\n    std_dev: float = Field(gt=0)  # Validation that std_dev must be positive\n</code></pre>"},{"location":"random_variables/#2-inheritance-hierarchy","title":"2. Inheritance Hierarchy","text":"<p>A clear inheritance structure ensures consistent behavior across different distributions:</p> <pre><code>RandomVariable[T]  # Base class with generic type T\n    \u21b3 ContinuousRandomVariable  # For continuous distributions\n        \u21b3 NormalRandomVariable  # Specific normal distribution\n        \u21b3 UniformRandomVariable # Specific uniform distribution\n    \u21b3 DiscreteRandomVariable   # For discrete distributions\n        \u21b3 PoissonRandomVariable # Specific Poisson distribution\n</code></pre>"},{"location":"random_variables/#3-sampling-interface","title":"3. Sampling Interface","text":"<p>All random variables implement a consistent sampling interface:</p> <pre><code>class RandomVariable(Generic[T]):\n    def sample(self, size: Optional[int] = None) -&gt; T | NDArray:\n        \"\"\"Sample from the distribution.\"\"\"\n        raise NotImplementedError\n\n    def sample_to_list(self, size: int) -&gt; list[T]:\n        \"\"\"Sample multiple values into a list.\"\"\"\n        return list(self.sample(size))\n</code></pre>"},{"location":"random_variables/#4-parameter-validation","title":"4. Parameter Validation","text":"<p>Parameters are validated both at instantiation and runtime:</p> <pre><code>class UniformRandomVariable(ContinuousRandomVariable):\n    low: float\n    high: float\n\n    @field_validator(\"high\")\n    def validate_bounds(cls, high: float, info: ValidationInfo) -&gt; float:\n        low = info.data.get(\"low\", 0.0)\n        if high &lt;= low:\n            raise ValueError(\"high must be greater than low\")\n        return high\n</code></pre>"},{"location":"random_variables/#implementation-details","title":"Implementation Details","text":""},{"location":"random_variables/#1-normal-distribution","title":"1. Normal Distribution","text":"<pre><code>class NormalRandomVariable(ContinuousRandomVariable):\n    \"\"\"\n    Generates normally distributed random values.\n    \"\"\"\n    mean: float = 0.0\n    std_dev: float = Field(gt=0, default=1.0)\n\n    def sample(self, size: Optional[int] = None) -&gt; float | NDArray:\n        return np.random.normal(self.mean, self.std_dev, size)\n</code></pre>"},{"location":"random_variables/#2-uniform-distribution","title":"2. Uniform Distribution","text":"<pre><code>class UniformRandomVariable(ContinuousRandomVariable):\n    \"\"\"\n    Generates uniformly distributed random values.\n    \"\"\"\n    low: float = 0.0\n    high: float = 1.0\n\n    def sample(self, size: Optional[int] = None) -&gt; float | NDArray:\n        return np.random.uniform(self.low, self.high, size)\n</code></pre>"},{"location":"random_variables/#testing-strategy","title":"Testing Strategy","text":"<p>The testing approach verifies both the statistical properties and error handling of the distributions.</p>"},{"location":"random_variables/#1-statistical-property-tests","title":"1. Statistical Property Tests","text":"<pre><code>def test_normal_distribution_properties():\n    # Create normal distribution\n    normal = NormalRandomVariable(mean=10, std_dev=2)\n\n    # Sample large number of values\n    samples = normal.sample(10000)\n\n    # Check statistical properties\n    assert 9.8 &lt; np.mean(samples) &lt; 10.2  # Mean within range\n    assert 1.9 &lt; np.std(samples) &lt; 2.1    # Std dev within range\n</code></pre>"},{"location":"random_variables/#2-parameter-validation-tests","title":"2. Parameter Validation Tests","text":"<pre><code>def test_invalid_parameters():\n    # Test invalid standard deviation\n    with pytest.raises(ValidationError):\n        NormalRandomVariable(mean=0, std_dev=-1)\n\n    # Test invalid uniform bounds\n    with pytest.raises(ValidationError):\n        UniformRandomVariable(low=10, high=5)\n</code></pre>"},{"location":"random_variables/#3-sampling-interface-tests","title":"3. Sampling Interface Tests","text":"<pre><code>def test_sampling_interface():\n    normal = NormalRandomVariable(mean=0, std_dev=1)\n\n    # Test single sample\n    assert isinstance(normal.sample(), float)\n\n    # Test multiple samples\n    samples = normal.sample(10)\n    assert len(samples) == 10\n\n    # Test list conversion\n    sample_list = normal.sample_to_list(5)\n    assert isinstance(sample_list, list)\n    assert len(sample_list) == 5\n</code></pre>"},{"location":"random_variables/#usage-examples","title":"Usage Examples","text":""},{"location":"random_variables/#1-basic-usage","title":"1. Basic Usage","text":"<pre><code># Create a normal distribution\nnormal = NormalRandomVariable(mean=10, std_dev=2)\n\n# Single sample\nvalue = normal.sample()\n\n# Multiple samples\nvalues = normal.sample(100)\n</code></pre>"},{"location":"random_variables/#2-using-in-simulations","title":"2. Using in Simulations","text":"<pre><code># Define process variation\nprocess_var = NormalRandomVariable(mean=100, std_dev=5)\n\n# Simulate process\nmeasurements = process_var.sample_to_list(1000)\n</code></pre>"},{"location":"random_variables/#3-combining-distributions","title":"3. Combining Distributions","text":"<pre><code># Process with random failures\nbase_process = NormalRandomVariable(mean=100, std_dev=2)\nfailure_rate = PoissonRandomVariable(lambda_=0.1)\n\ndef simulate_process(n_steps: int) -&gt; list[float]:\n    measurements = base_process.sample_to_list(n_steps)\n    failures = failure_rate.sample_to_list(n_steps)\n    return [m if f == 0 else 0.0 for m, f in zip(measurements, failures)]\n</code></pre>"},{"location":"random_variables/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always validate distribution parameters: <pre><code># Good\nnormal = NormalRandomVariable(mean=0, std_dev=1.0)\n\n# Avoid\nnormal = NormalRandomVariable(mean=0, std_dev=-1.0)  # Will raise error\n</code></pre></p> </li> <li> <p>Use appropriate distribution types: <pre><code># Good - continuous values\nprocess_temp = NormalRandomVariable(mean=350, std_dev=5)\n\n# Good - discrete counts\ndefects = PoissonRandomVariable(lambda_=2.5)\n</code></pre></p> </li> <li> <p>Handle sampling errors appropriately: <pre><code>try:\n    samples = distribution.sample(1000)\nexcept ValueError as e:\n    # Handle sampling error\n    logger.error(f\"Sampling failed: {e}\")\n</code></pre></p> </li> <li> <p>Use type hints for clarity: <pre><code>def simulate_process(\n    distribution: RandomVariable[float],\n    n_samples: int\n) -&gt; NDArray:\n    return distribution.sample(n_samples)\n</code></pre></p> </li> </ol>"},{"location":"random_variables/#extended-features","title":"Extended Features","text":""},{"location":"random_variables/#1-distribution-composition","title":"1. Distribution Composition","text":"<p>The system supports combining distributions:</p> <pre><code>class CompositeRandomVariable(RandomVariable[float]):\n    distributions: list[RandomVariable[float]]\n    weights: list[float]\n\n    def sample(self, size: Optional[int] = None) -&gt; float | NDArray:\n        samples = [d.sample(size) for d in self.distributions]\n        return np.average(samples, weights=self.weights, axis=0)\n</code></pre>"},{"location":"random_variables/#2-serialization-support","title":"2. Serialization Support","text":"<p>Random variables can be serialized for storage or transmission:</p> <pre><code># Save distribution parameters\nnormal = NormalRandomVariable(mean=10, std_dev=2)\njson_data = normal.model_dump_json()\n\n# Recreate distribution\nloaded = NormalRandomVariable.model_validate_json(json_data)\n</code></pre> <p>This design provides a robust foundation for handling random variables in simulation and statistical applications while maintaining type safety and proper validation.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>process_manager<ul> <li>data_handlers<ul> <li>base</li> <li>custom_serde_definitions<ul> <li>pandantic</li> </ul> </li> <li>mixins</li> <li>random_variables</li> <li>values</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/process_manager/","title":"process_manager","text":""},{"location":"reference/process_manager/#process_manager","title":"process_manager","text":"<p>Tools for managing processes and doing them in parallel</p>"},{"location":"reference/process_manager/data_handlers/","title":"data_handlers","text":""},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers","title":"data_handlers","text":"<p>Data handlers for the process manager.</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution","title":"CategoricalDistribution","text":"<p>               Bases: <code>RandomVariable[T]</code></p> <p>Categorical distribution for discrete outcomes with specified probabilities.</p> <p>A categorical distribution (also called a discrete distribution) describes the probability of obtaining one of k possible outcomes. Each outcome has a probability between 0 and 1, and all probabilities must sum to 1.</p> <p>If probabilities are not specified, defaults to equal probabilities for all categories (uniform discrete distribution).</p> Key Properties <ul> <li>Support is finite set of categories</li> <li>PMF gives probability of each category</li> <li>CDF is step function</li> </ul> <p>Attributes:</p> Name Type Description <code>categories</code> <code>ndarray</code> <p>Array of possible outcomes (any type)</p> <code>probabilities</code> <code>ndarray</code> <p>Probability for each category</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p> <code>replace</code> <code>bool</code> <p>Whether or not to allow multiple draws of the same value (allowed if True)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If probabilities don't sum to 1</p> <code>ValueError</code> <p>If lengths of categories and probabilities don't match</p> <code>ValueError</code> <p>If any probability is negative</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the cumulative distribution function.</p> <p>For categorical distributions, this is a step function that increases at each category by that category's probability.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the cumulative distribution function.\n\n    For categorical distributions, this is a step function that\n    increases at each category by that category's probability.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return np.array([\n        np.sum(self.probabilities[self.categories &lt;= val])\n        for val in x\n    ])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the probability mass function (PMF).</p> <p>For categorical distributions, this gives the probability of each category occurring.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PMF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Probability of each input value</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the probability mass function (PMF).\n\n    For categorical distributions, this gives the probability of\n    each category occurring.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PMF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Probability of each input value\n    \"\"\"\n    return np.array([\n        self.probabilities[self.categories == val].item()\n        if val in self.categories else 0.0\n        for val in x\n    ])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Generate random samples from the categorical distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate. Defaults to 1.</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> Notes <p>The squeeze parameter is added automatically by the metaclass and does not appear in the function signature, but can be passed as a keyword argument.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>NDArray[Any,T]: Array of samples from the categories</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any,T]:\n    \"\"\"Generate random samples from the categorical distribution.\n\n    Args:\n        size (int, optional): Number of samples to generate. Defaults to 1.\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Notes:\n        The squeeze parameter is added automatically by the metaclass and does not appear\n        in the function signature, but can be passed as a keyword argument.\n\n    Returns:\n        NDArray[Any,T]: Array of samples from the categories\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.choice(self.categories, size=size, p=self.probabilities, replace=self.replace)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.CategoricalDistribution.validate_and_set_probabilities","title":"validate_and_set_probabilities","text":"<pre><code>validate_and_set_probabilities() -&gt; CategoricalDistribution\n</code></pre> <p>Validate probability values and set defaults if needed.</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>@model_validator(mode='after')\ndef validate_and_set_probabilities(self) -&gt; CategoricalDistribution:\n    \"\"\"Validate probability values and set defaults if needed.\"\"\"\n    if self.probabilities is None:\n        n_categories = len(self.categories)\n        self.probabilities = np.ones(n_categories) / n_categories\n        return self\n\n    if len(self.categories) != len(self.probabilities):\n        raise ValueError(\n            f\"Number of categories ({len(self.categories)}) must match \"\n            f\"number of probabilities ({len(self.probabilities)})\"\n        )\n    if not np.all(self.probabilities &gt;= 0):\n        raise ValueError(\"All probabilities must be non-negative\")\n    if not np.isclose(np.sum(self.probabilities), 1.0):\n        raise ValueError(\"Probabilities must sum to 1\")\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObject","title":"NamedObject","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for named objects with serialization support.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Name of object class type (computed field)</p> <code>name</code> <code>str</code> <p>Name of the object</p> Configuration <p>model_config (ConfigDict): Pydantic model configuration</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObject.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>Returns the name of the object type.</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObject.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(*, registry_category: str = None, **kwargs)\n</code></pre> <p>Register subclasses in appropriate registry category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init_subclass__(cls, *, registry_category: str = None, **kwargs):\n    \"\"\"Register subclasses in appropriate registry category.\"\"\"\n    super().__init_subclass__(**kwargs)\n    if registry_category:\n        cls._registry_category = registry_category\n    ObjectRegistry.register(cls._registry_category, cls)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash","title":"NamedObjectHash","text":"<pre><code>NamedObjectHash(**kwargs: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Dictionary of named objects with type checking and conflict prevention.</p> <p>Attributes:</p> Name Type Description <code>objects</code> <code>dict</code> <p>Dictionary of named objects</p> <p>Initialize with type-specific deserialization.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init__(self, **kwargs: Any):\n    \"\"\"Initialize with type-specific deserialization.\"\"\"\n    self._deserialize_objects(kwargs)\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.get_object","title":"get_object","text":"<pre><code>get_object(name: str) -&gt; NamedObject\n</code></pre> <p>Get object by name.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_object(self, name: str) -&gt; NamedObject:\n    \"\"\"Get object by name.\"\"\"\n    return self.objects[name]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.get_object_names","title":"get_object_names","text":"<pre><code>get_object_names() -&gt; Iterable[str]\n</code></pre> <p>Get names of all objects.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_object_names(self) -&gt; Iterable[str]:\n    \"\"\"Get names of all objects.\"\"\"\n    return self.objects.keys()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.get_objects","title":"get_objects","text":"<pre><code>get_objects() -&gt; Iterable[NamedObject]\n</code></pre> <p>Get all objects.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_objects(self) -&gt; Iterable[NamedObject]:\n    \"\"\"Get all objects.\"\"\"\n    return self.objects.values()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectHash.register_object","title":"register_object","text":"<pre><code>register_object(obj: NamedObject) -&gt; Self\n</code></pre> <p>Register a named object. Checks for naming conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>NamedObject</code> <p>Object to register</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If object with same name exists</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def register_object(self, obj: NamedObject) -&gt; Self:\n    \"\"\"\n    Register a named object. Checks for naming conflicts.\n\n    Args:\n        obj (NamedObject): Object to register\n\n    Raises:\n        ValueError: If object with same name exists\n    \"\"\"\n    if obj.name in self.objects:\n        raise ValueError(\n            f\"Naming conflict: An object named '{obj.name}' already exists.\"\n            f\"\\n\\tExisting: \\n{self.get_object(obj.name).model_dump_json(indent=4)}\"\n            f\"\\n\\tNew: \\n{obj.model_dump_json(indent=4)}\"\n        )\n    self.objects[obj.name] = obj\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList","title":"NamedObjectList","text":"<p>               Bases: <code>BaseModel</code></p> <p>List of named objects with type checking.</p> <p>Attributes:</p> Name Type Description <code>objects</code> <code>list</code> <p>List of named objects</p> Example <p>obj_list = NamedObjectList() obj_list.append(named_object) obj_list.extend([obj1, obj2, obj3])</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NamedObject\n</code></pre> <p>Get object by index.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NamedObject:\n    \"\"\"Get object by index.\"\"\"\n    return self.objects[idx]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterable[NamedObject]\n</code></pre> <p>Iterate over objects in list.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __iter__(self) -&gt; Iterable[NamedObject]:\n    \"\"\"Iterate over objects in list.\"\"\"\n    return iter(self.objects)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of objects in list.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of objects in list.\"\"\"\n    return len(self.objects)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.append","title":"append","text":"<pre><code>append(obj: NamedObject) -&gt; Self\n</code></pre> <p>Append a single object to the list.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>NamedObject</code> <p>Object to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def append(self, obj: NamedObject) -&gt; Self:\n    \"\"\"\n    Append a single object to the list.\n\n    Args:\n        obj (NamedObject): Object to append\n\n    Returns:\n        Self: Returns self for chaining\n    \"\"\"\n    self.objects.append(obj)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.extend","title":"extend","text":"<pre><code>extend(objects: Iterable[NamedObject]) -&gt; Self\n</code></pre> <p>Extend list with multiple objects.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>Iterable[NamedObject]</code> <p>Objects to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def extend(self, objects: Iterable[NamedObject]) -&gt; Self:\n    \"\"\"\n    Extend list with multiple objects.\n\n    Args:\n        objects (Iterable[NamedObject]): Objects to add\n\n    Returns:\n        Self: Returns self for chaining\n    \"\"\"\n    self.objects.extend(objects)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedObjectList.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(iterable: Iterable[NamedObject]) -&gt; Self\n</code></pre> <p>Create instance from an iterable of named objects.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[NamedObject]</code> <p>Objects to add to list</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>New instance containing the objects</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef from_iterable(cls, iterable: Iterable[NamedObject]) -&gt; Self:\n    \"\"\"\n    Create instance from an iterable of named objects.\n\n    Args:\n        iterable (Iterable[NamedObject]): Objects to add to list\n\n    Returns:\n        Self: New instance containing the objects\n    \"\"\"\n    return cls(objects=list(iterable))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue","title":"NamedValue","text":"<pre><code>NamedValue(name: str, value: T | None = None, **data)\n</code></pre> <p>               Bases: <code>NamedObject</code>, <code>Generic[T]</code></p> <p>Initialize a new NamedValue instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name identifier for this value</p> required <code>value</code> <code>T</code> <p>Initial value to set. If provided, this value becomes frozen after initialization. Defaults to None.</p> <code>None</code> <code>**data</code> <p>Additional keyword arguments passed to parent class</p> <code>{}</code> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __init__(self, name: str, value: T | None = None, **data):\n    \"\"\"\n    Initialize a new NamedValue instance.\n\n    Args:\n        name (str): The name identifier for this value\n        value (T, optional): Initial value to set. If provided,\n            this value becomes frozen after initialization. Defaults to None.\n        **data: Additional keyword arguments passed to parent class\n    \"\"\"\n    super().__init__(name=name, **data)\n    self._type = self._extract_value_type()\n\n    if value is not None:\n        self.value = value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: T\n</code></pre> <p>Get the stored value.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The currently stored value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to access the value before it has been set</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.append_to_value_list","title":"append_to_value_list","text":"<pre><code>append_to_value_list(l: NamedValueList) -&gt; Self\n</code></pre> <p>Appends self to given list.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>NamedValueList</code> <p>list to which self will be appended</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns instance of self for method chaining</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def append_to_value_list(self, l: NamedValueList) -&gt; Self:\n    \"\"\"\n    Appends self to given list.\n\n    Args:\n        l (NamedValueList): list to which self will be appended\n\n    Returns:\n        Self: returns instance of self for method chaining\n    \"\"\"\n    l.append(self)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.force_set_value","title":"force_set_value","text":"<pre><code>force_set_value(new_value: T) -&gt; None\n</code></pre> <p>Force set the value regardless of whether it was previously set.</p> <p>This method bypasses the frozen value protection but still performs type checking. It's primarily intended for internal use cases like value override systems.</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>T</code> <p>The new value to force set</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the expected type</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def force_set_value(self, new_value: T) -&gt; None:\n    \"\"\"\n    Force set the value regardless of whether it was previously set.\n\n    This method bypasses the frozen value protection but still performs type checking.\n    It's primarily intended for internal use cases like value override systems.\n\n    Args:\n        new_value (T): The new value to force set\n\n    Raises:\n        TypeError: If the value doesn't match the expected type\n    \"\"\"\n    self._stored_value = UNSET.token\n    self.value = new_value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValue.register_to_value_hash","title":"register_to_value_hash","text":"<pre><code>register_to_value_hash(h: NamedValueHash) -&gt; Self\n</code></pre> <p>Registers self to the NamedValueHash object.</p> <p>The hash may override this value's current value if there are value overrides defined in the hash. This is done using force_set_value() internally.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>NamedValueHash</code> <p>Hash to which self will be registered</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns instance of self for method chaining</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_to_value_hash(self, h: NamedValueHash) -&gt; Self:\n    \"\"\"\n    Registers self to the NamedValueHash object.\n\n    The hash may override this value's current value if there are\n    value overrides defined in the hash. This is done using force_set_value()\n    internally.\n\n    Args:\n        h (NamedValueHash): Hash to which self will be registered\n\n    Returns:\n        Self: returns instance of self for method chaining\n    \"\"\"\n    h.register_value(self)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash","title":"NamedValueHash","text":"<pre><code>NamedValueHash(**kwargs: Any)\n</code></pre> <p>               Bases: <code>NamedObjectHash</code></p> <p>Dictionary of named value instances.</p> <p>A type-safe dictionary for storing and managing NamedValue objects, using the name as the key of the value instance.</p> <p>Initialize with type-specific deserialization.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init__(self, **kwargs: Any):\n    \"\"\"Initialize with type-specific deserialization.\"\"\"\n    self._deserialize_objects(kwargs)\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_raw_value","title":"get_raw_value","text":"<pre><code>get_raw_value(name: str) -&gt; Any\n</code></pre> <p>Get the underlying value by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to retrieve</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The actual value stored in the named value</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_raw_value(self, name: str) -&gt; Any:\n    \"\"\"\n    Get the underlying value by name.\n\n    Args:\n        name (str): Name of the value to retrieve\n\n    Returns:\n        Any: The actual value stored in the named value\n    \"\"\"\n    return self.get_value(name).value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_raw_values","title":"get_raw_values","text":"<pre><code>get_raw_values() -&gt; Iterable[Any]\n</code></pre> <p>Get the underlying values of all named values.</p> <p>Returns:</p> Type Description <code>Iterable[Any]</code> <p>Iterable[Any]: The actual values stored in each NamedValue</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_raw_values(self) -&gt; Iterable[Any]:\n    \"\"\"\n    Get the underlying values of all named values.\n\n    Returns:\n        Iterable[Any]: The actual values stored in each NamedValue\n    \"\"\"\n    return (val.value for val in self.get_values())\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_value","title":"get_value","text":"<pre><code>get_value(name: str) -&gt; NamedValue\n</code></pre> <p>Get value by name.</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value(self, name: str) -&gt; NamedValue:\n    \"\"\"Get value by name.\"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_value_by_type","title":"get_value_by_type","text":"<pre><code>get_value_by_type(value_type: Type) -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all values of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>Type</code> <p>Type to filter values by</p> required <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: Values matching the specified type</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value_by_type(self, value_type: Type) -&gt; Iterable[NamedValue]:\n    \"\"\"\n    Get all values of a specific type.\n\n    Args:\n        value_type (Type): Type to filter values by\n\n    Returns:\n        Iterable[NamedValue]: Values matching the specified type\n    \"\"\"\n    return [val for val in self.get_values() if isinstance(val, value_type)]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_value_names","title":"get_value_names","text":"<pre><code>get_value_names() -&gt; Iterable[str]\n</code></pre> <p>Get names of all values.</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value_names(self) -&gt; Iterable[str]:\n    \"\"\"Get names of all values.\"\"\"\n    return self.get_object_names()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.get_values","title":"get_values","text":"<pre><code>get_values() -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all values.</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_values(self) -&gt; Iterable[NamedValue]:\n    \"\"\"Get all values.\"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.register_value","title":"register_value","text":"<pre><code>register_value(value: NamedValue) -&gt; Self\n</code></pre> <p>Register a named value. Checks for naming conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>The value to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a value with the same name exists</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_value(self, value: NamedValue) -&gt; Self:\n    \"\"\"\n    Register a named value. Checks for naming conflicts.\n\n    Args:\n        value (NamedValue): The value to register\n\n    Returns:\n        Self: Returns self for chaining\n\n    Raises:\n        ValueError: If a value with the same name exists\n    \"\"\"\n    return self.register_object(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueHash.set_raw_value","title":"set_raw_value","text":"<pre><code>set_raw_value(name: str, value: Any) -&gt; None\n</code></pre> <p>Set the underlying value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to update</p> required <code>value</code> <code>Any</code> <p>New value to set</p> required Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def set_raw_value(self, name: str, value: Any) -&gt; None:\n    \"\"\"\n    Set the underlying value.\n\n    Args:\n        name (str): Name of the value to update\n        value (Any): New value to set\n    \"\"\"\n    self.get_value(name).value = value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList","title":"NamedValueList","text":"<p>               Bases: <code>NamedObjectList</code></p> <p>List of named value instances. This class manages an ordered list of NamedValue objects, providing methods to add, access, and manage multiple named values while maintaining their order.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>objects</code> <code>List[SerializeAsAny[InstanceOf[NamedValue]]]</code> <p>List of named value objects</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NamedValue\n</code></pre> <p>Get a named value by its index in the list.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the named value to retrieve</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The named value at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> Example <p>value_list = NamedValueList() value_list.append(NamedValue(name=\"price\", value=10.5)) first_value = value_list[0] # Get first named value</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NamedValue:\n    \"\"\"Get a named value by its index in the list.\n\n    Args:\n        idx (int): Index of the named value to retrieve\n\n    Returns:\n        NamedValue: The named value at the specified index\n\n    Raises:\n        IndexError: If the index is out of range\n\n    Example:\n        &gt;&gt;&gt; value_list = NamedValueList()\n        &gt;&gt;&gt; value_list.append(NamedValue(name=\"price\", value=10.5))\n        &gt;&gt;&gt; first_value = value_list[0] # Get first named value\n    \"\"\"\n    return super().__getitem__(idx)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.append","title":"append","text":"<pre><code>append(value: NamedValue) -&gt; Self\n</code></pre> <p>Append a named value to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>Named value to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The NamedValueList instance for method chaining</p> Example <p>value_list = NamedValueList() named_value = NamedValue(name=\"price\", value=10.5) value_list.append(named_value)</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def append(self, value: NamedValue) -&gt; Self:\n    \"\"\"Append a named value to the end of the list.\n\n    Args:\n        value (NamedValue): Named value to append\n\n    Returns:\n        Self: The NamedValueList instance for method chaining\n\n    Example:\n        &gt;&gt;&gt; value_list = NamedValueList()\n        &gt;&gt;&gt; named_value = NamedValue(name=\"price\", value=10.5)\n        &gt;&gt;&gt; value_list.append(named_value)\n    \"\"\"\n    return super().append(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.extend","title":"extend","text":"<pre><code>extend(values: Iterable[NamedValue]) -&gt; Self\n</code></pre> <p>Extend the list with multiple named values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Iterable[NamedValue]</code> <p>Collection of named values to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The NamedValueList instance for method chaining</p> Example <p>value_list = NamedValueList() new_values = [ ...     NamedValue(name=\"price\", value=10.5), ...     NamedValue(name=\"quantity\", value=5) ... ] value_list.extend(new_values)</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def extend(self, values: Iterable[NamedValue]) -&gt; Self:\n    \"\"\"Extend the list with multiple named values.\n\n    Args:\n        values (Iterable[NamedValue]): Collection of named values to add\n\n    Returns:\n        Self: The NamedValueList instance for method chaining\n\n    Example:\n        &gt;&gt;&gt; value_list = NamedValueList()\n        &gt;&gt;&gt; new_values = [\n        ...     NamedValue(name=\"price\", value=10.5),\n        ...     NamedValue(name=\"quantity\", value=5)\n        ... ]\n        &gt;&gt;&gt; value_list.extend(new_values)\n    \"\"\"\n    return super().extend(values)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.get_value","title":"get_value","text":"<pre><code>get_value(name: str) -&gt; NamedValue\n</code></pre> <p>Get a registered named value by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the named value</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The requested named value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value(self, name: str) -&gt; NamedValue:\n    \"\"\"Get a registered named value by name.\n\n    Args:\n        name (str): Name of the named value\n\n    Returns:\n        NamedValue: The requested named value\n\n    Raises:\n        KeyError: If no value exists with the given name\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.get_values","title":"get_values","text":"<pre><code>get_values() -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all registered named values.</p> <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: Iterator over all registered values</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_values(self) -&gt; Iterable[NamedValue]:\n    \"\"\"Get all registered named values.\n\n    Returns:\n        Iterable[NamedValue]: Iterator over all registered values\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NamedValueList.register_value","title":"register_value","text":"<pre><code>register_value(value: NamedValue) -&gt; Self\n</code></pre> <p>Register a named value to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>Named value to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The NamedValueList instance</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_value(self, value: NamedValue) -&gt; Self:\n    \"\"\"Register a named value to the collection.\n\n    Args:\n        value (NamedValue): Named value to register\n\n    Returns:\n        Self: The NamedValueList instance\n    \"\"\"\n    return self.register_object(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NormalDistribution","title":"NormalDistribution","text":"<p>               Bases: <code>RandomVariable[float]</code></p> <p>Normal (Gaussian) distribution with mean \u03bc and standard deviation \u03c3.</p> <p>The normal distribution is a continuous probability distribution that is symmetric about its mean, showing the familiar bell-shaped curve.</p> Key Properties <ul> <li>Symmetric about the mean</li> <li>~68% of values lie within 1\u03c3 of \u03bc</li> <li>~95% lie within 2\u03c3 of \u03bc</li> <li>~99.7% lie within 3\u03c3 of \u03bc</li> </ul> <p>Attributes:</p> Name Type Description <code>mu</code> <code>float</code> <p>Mean (\u03bc) of the distribution</p> <code>sigma</code> <code>float</code> <p>Standard deviation (\u03c3) of the distribution</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NormalDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the normal cumulative distribution function.</p> <p>The CDF is computed using the error function: F(x) = 1/2 * (1 + erf((x-\u03bc)/(\u03c3\u221a2)))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the normal cumulative distribution function.\n\n    The CDF is computed using the error function:\n    F(x) = 1/2 * (1 + erf((x-\u03bc)/(\u03c3\u221a2)))\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return 0.5 * (1 + sp.erf((x - self.mu)/(self.sigma * np.sqrt(2))))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NormalDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the normal probability density function.</p> <p>The PDF is given by: f(x) = 1/(\u03c3\u221a(2\u03c0)) * exp(-(x-\u03bc)\u00b2/(2\u03c3\u00b2))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: PDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the normal probability density function.\n\n    The PDF is given by:\n    f(x) = 1/(\u03c3\u221a(2\u03c0)) * exp(-(x-\u03bc)\u00b2/(2\u03c3\u00b2))\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: PDF values at the input points\n    \"\"\"\n    return 1/(self.sigma * np.sqrt(2*np.pi)) * np.exp(-(x - self.mu)**2 / (2*self.sigma**2))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NormalDistribution.sample","title":"sample","text":"<pre><code>sample(size: int | tuple[int, ...] = 1, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Generate random samples from the normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int | tuple[int, ...]</code> <p>Number or shape of samples</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Array of samples from N(\u03bc, \u03c3)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int | tuple[int, ...] = 1, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Generate random samples from the normal distribution.\n\n    Args:\n        size (int | tuple[int, ...]): Number or shape of samples\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Array of samples from N(\u03bc, \u03c3)\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.normal(self.mu, self.sigma, size=size)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NumericDunders","title":"NumericDunders","text":"<p>A mixin class containing numeric dunder methods that can be applied to any class via composition</p> <p>Attributes:</p> Name Type Description <code>RESERVED_NAME</code> <code>str</code> <p>Name of the reserved attribute that holds the value</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.NumericDunders.get_value","title":"get_value  <code>classmethod</code>","text":"<pre><code>get_value(instance)\n</code></pre> <p>Get the value of the instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>Instance of the class</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Value of the instance stored in the reserved attribute or else returns the instance. For example, if the reserved attribute is 'value', then it returns <code>instance.value</code> else if the instance is just a float or an int or something like that, then it returns the instance itself.</p> Source code in <code>src/process_manager/data_handlers/mixins.py</code> <pre><code>@classmethod\ndef get_value(cls, instance):\n    \"\"\"\n    Get the value of the instance\n\n    Args:\n        instance (Any): Instance of the class\n\n    Returns:\n        Any: Value of the instance stored in the reserved attribute or else returns the instance.\n            For example, if the reserved attribute is 'value', then it returns `instance.value` else\n            if the instance is just a float or an int or something like that, then it returns the instance itself.\n    \"\"\"\n    return getattr(instance, cls.RESERVED_NAME, instance)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry","title":"ObjectRegistry","text":"<p>Generic registry for named object types.</p> <p>Stores object types for deserialization from JSON files. Types are stored at the class level for consistent access across modules.</p> <p>Types are stored at the class level for consistent access across modules.</p> <p>Methods:</p> Name Description <code>register</code> <p>Register an object type</p> <code>get</code> <p>Get an object type by name</p> <code>get_all</code> <p>Get all registered object types</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(category: str, name: str) -&gt; Type[NamedObject]\n</code></pre> <p>Get an object type by category and name.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get(cls, category: str, name: str) -&gt; Type[NamedObject]:\n    \"\"\"Get an object type by category and name.\"\"\"\n    registry = cls.get_registry(category)\n    if name not in registry:\n        raise ValueError(f\"{name} not found in {category} registry\")\n    return registry[name]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry.get_all","title":"get_all  <code>classmethod</code>","text":"<pre><code>get_all(category: str) -&gt; list[Type[NamedObject]]\n</code></pre> <p>Get all registered types for a category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get_all(cls, category: str) -&gt; list[Type[NamedObject]]:\n    \"\"\"Get all registered types for a category.\"\"\"\n    return list(cls.get_registry(category).values())\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry.get_registry","title":"get_registry  <code>classmethod</code>","text":"<pre><code>get_registry(category: str) -&gt; Dict[str, Type[NamedObject]]\n</code></pre> <p>Get or create registry for a category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get_registry(cls, category: str) -&gt; Dict[str, Type[NamedObject]]:\n    \"\"\"Get or create registry for a category.\"\"\"\n    # Get the actual string value if it's a PrivateAttr\n    if hasattr(category, 'default'):\n        category = category.default\n    if category not in cls._registries:\n        cls._registries[category] = {}\n    return cls._registries[category]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.ObjectRegistry.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(category: str, obj_type: Type[NamedObject]) -&gt; None\n</code></pre> <p>Register an object type in its category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef register(cls, category: str, obj_type: Type[NamedObject]) -&gt; None:\n    \"\"\"Register an object type in its category.\"\"\"\n    # Get the actual string value if it's a PrivateAttr\n    if hasattr(category, 'default'):\n        category = category.default\n    registry = cls.get_registry(category)\n    registry[obj_type.__name__] = obj_type\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable","title":"RandomVariable","text":"<p>               Bases: <code>NamedObject</code>, <code>Generic[T]</code></p> <p>Base class for random variables.</p> <p>This class provides a common interface for random variable implementations. Subclasses must implement sample(), pdf(), and cdf() methods. The metaclass ensures these methods support dimension control via the squeeze parameter.</p> <p>The class is generic over the type of values it produces (T), which must be a subtype of SerializableValue to ensure proper serialization behavior.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p> <code>name</code> <code>str</code> <p>Identifier for this random variable instance</p> Type Variables <p>T: The type of values produced by this random variable</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Evaluate cumulative distribution function at specified points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>CDF values at the input points</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Evaluate cumulative distribution function at specified points.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): CDF values at the input points\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Evaluate probability density function at specified points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>PDF values at the input points</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Evaluate probability density function at specified points.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): PDF values at the input points\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable.register_to_hash","title":"register_to_hash","text":"<pre><code>register_to_hash(\n    var_hash: RandomVariableHash, size: int = 1, sample: bool = True, squeeze: bool = True\n) -&gt; NamedValue[T | NDArray[Any, T]]\n</code></pre> <p>Register this random variable to a hash and return sampled values.</p> <p>This is a convenience method for adding a random variable to a collection and immediately sampling from it.</p> <p>Parameters:</p> Name Type Description Default <code>var_hash</code> <code>RandomVariableHash</code> <p>Hash object to register to</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>NamedValue[T | NDArray[Any, T]]</code> <p>Named value containing samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_to_hash(\n        self, \n        var_hash: RandomVariableHash, \n        size: int = 1, \n        sample: bool = True,\n        squeeze: bool = True,\n    ) -&gt; NamedValue[T|NDArray[Any,T]]:\n    \"\"\"Register this random variable to a hash and return sampled values.\n\n    This is a convenience method for adding a random variable to a collection\n    and immediately sampling from it.\n\n    Args:\n        var_hash (RandomVariableHash): Hash object to register to\n        size (int): Number of samples to generate\n\n    Returns:\n        (NamedValue[T|NDArray[Any,T]]): Named value containing samples\n    \"\"\"\n    return var_hash.register_variable(self, size=size, sample=sample, squeeze=squeeze)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariable.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Generate random samples from the categorical distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate. Defaults to 1.</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>Array of samples from the categories</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Generate random samples from the categorical distribution.\n\n    Args:\n        size (int): Number of samples to generate. Defaults to 1.\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): Array of samples from the categories\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableHash","title":"RandomVariableHash","text":"<pre><code>RandomVariableHash(**kwargs: Any)\n</code></pre> <p>               Bases: <code>NamedObjectHash</code></p> <p>Collection of random variables.</p> <p>This class manages a collection of RandomVariable objects, providing methods to register, retrieve and sample from multiple distributions.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <p>Initialize with type-specific deserialization.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init__(self, **kwargs: Any):\n    \"\"\"Initialize with type-specific deserialization.\"\"\"\n    self._deserialize_objects(kwargs)\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableHash.get_variables","title":"get_variables","text":"<pre><code>get_variables() -&gt; Iterable[RandomVariable]\n</code></pre> <p>Get all registered random variables.</p> <p>Returns:</p> Type Description <code>Iterable[RandomVariable]</code> <p>Iterable[RandomVariable]: Iterator over all registered variables</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variables(self) -&gt; Iterable[RandomVariable]:\n    \"\"\"Get all registered random variables.\n\n    Returns:\n        Iterable[RandomVariable]: Iterator over all registered variables\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableHash.register_variable","title":"register_variable","text":"<pre><code>register_variable(\n    var: RandomVariable, size: int = 1, sample: bool = True, squeeze: bool = True\n) -&gt; NamedValue[SerializableValue | NDArray[Any, SerializableValue]]\n</code></pre> <p>Register a random variable and return its samples wrapped in a NamedValue.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>RandomVariable</code> <p>Random variable to register</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>NamedValue[SerializableValue | NDArray[Any, SerializableValue]]</code> <p>NamedValue[SerializableValue|NDArray[Any,SerializableValue]]: Named value containing samples</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a variable with the same name already exists</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_variable(\n        self, \n        var: RandomVariable, \n        size: int = 1,\n        sample: bool = True,\n        squeeze: bool = True,\n    ) -&gt; NamedValue[SerializableValue|NDArray[Any,SerializableValue]]:\n    \"\"\"Register a random variable and return its samples wrapped in a NamedValue.\n\n    Args:\n        var (RandomVariable): Random variable to register\n        size (int): Number of samples to generate\n\n    Returns:\n        NamedValue[SerializableValue|NDArray[Any,SerializableValue]]: Named value containing samples\n\n    Raises:\n        ValueError: If a variable with the same name already exists\n    \"\"\"\n    if var.name in self.objects:\n        raise ValueError(f\"A variable with name '{var.name}' already exists in the collection\")\n\n    self.register_object(var)\n    if sample:\n        samples = var.sample(size=size)\n        if squeeze:\n            return NamedValue(name=var.name, value=samples.squeeze())\n        else:\n            return NamedValue(name=var.name, value=samples)\n    else:\n        return None\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableHash.sample_all","title":"sample_all","text":"<pre><code>sample_all(size: int = 1) -&gt; dict[str, ndarray]\n</code></pre> <p>Sample from all registered distributions.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate per distribution</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>dict[str, np.ndarray]: Dictionary mapping variable names to their samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample_all(self, size: int = 1) -&gt; dict[str, np.ndarray]:\n    \"\"\"Sample from all registered distributions.\n\n    Args:\n        size (int): Number of samples to generate per distribution\n\n    Returns:\n        dict[str, np.ndarray]: Dictionary mapping variable names to their samples\n    \"\"\"\n    return {name: var.sample(size) for name, var in self.objects.items()}\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList","title":"RandomVariableList","text":"<p>               Bases: <code>NamedObjectList</code></p> <p>List of random variables.</p> <p>This class manages an ordered list of RandomVariable objects, providing methods to add, access, and sample from multiple distributions while maintaining their order.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>objects</code> <code>List[SerializeAsAny[InstanceOf[RandomVariable]]]</code> <p>List of random variable objects</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; RandomVariable\n</code></pre> <p>Get a random variable by its index in the list.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the random variable to retrieve</p> required <p>Returns:</p> Name Type Description <code>RandomVariable</code> <code>RandomVariable</code> <p>The random variable at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; RandomVariable:\n    \"\"\"Get a random variable by its index in the list.\n\n    Args:\n        idx (int): Index of the random variable to retrieve\n\n    Returns:\n        RandomVariable: The random variable at the specified index\n\n    Raises:\n        IndexError: If the index is out of range\n    \"\"\"\n    return super().__getitem__(idx)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.append","title":"append","text":"<pre><code>append(variable: RandomVariable) -&gt; Self\n</code></pre> <p>Append a random variable to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>RandomVariable</code> <p>Random variable to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance for method chaining</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def append(self, variable: RandomVariable) -&gt; Self:\n    \"\"\"Append a random variable to the end of the list.\n\n    Args:\n        variable (RandomVariable): Random variable to append\n\n    Returns:\n        Self: The RandomVariableList instance for method chaining\n    \"\"\"\n    return super().append(variable)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.extend","title":"extend","text":"<pre><code>extend(variables: Iterable[RandomVariable]) -&gt; Self\n</code></pre> <p>Extend the list with multiple random variables.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Iterable[RandomVariable]</code> <p>Collection of random variables to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance for method chaining</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def extend(self, variables: Iterable[RandomVariable]) -&gt; Self:\n    \"\"\"Extend the list with multiple random variables.\n\n    Args:\n        variables (Iterable[RandomVariable]): Collection of random variables to add\n\n    Returns:\n        Self: The RandomVariableList instance for method chaining\n    \"\"\"\n    return super().extend(variables)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: str) -&gt; RandomVariable\n</code></pre> <p>Get a registered random variable by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the random variable</p> required <p>Returns:</p> Name Type Description <code>RandomVariable</code> <code>RandomVariable</code> <p>The requested random variable</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no variable exists with the given name</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variable(self, name: str) -&gt; RandomVariable:\n    \"\"\"Get a registered random variable by name.\n\n    Args:\n        name (str): Name of the random variable\n\n    Returns:\n        RandomVariable: The requested random variable\n\n    Raises:\n        KeyError: If no variable exists with the given name\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.get_variables","title":"get_variables","text":"<pre><code>get_variables() -&gt; Iterable[RandomVariable]\n</code></pre> <p>Get all registered random variables.</p> <p>Returns:</p> Type Description <code>Iterable[RandomVariable]</code> <p>Iterable[RandomVariable]: Iterator over all registered variables</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variables(self) -&gt; Iterable[RandomVariable]:\n    \"\"\"Get all registered random variables.\n\n    Returns:\n        Iterable[RandomVariable]: Iterator over all registered variables\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.register_variable","title":"register_variable","text":"<pre><code>register_variable(var: RandomVariable) -&gt; Self\n</code></pre> <p>Register a random variable to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>RandomVariable</code> <p>Random variable to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_variable(self, var: RandomVariable) -&gt; Self:\n    \"\"\"Register a random variable to the collection.\n\n    Args:\n        var (RandomVariable): Random variable to register\n\n    Returns:\n        Self: The RandomVariableList instance\n    \"\"\"\n    return self.register_object(var)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.RandomVariableList.sample_all","title":"sample_all","text":"<pre><code>sample_all(size: int = 1) -&gt; dict[str, ndarray]\n</code></pre> <p>Sample from all variables in the list.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate per variable</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>dict[str, np.ndarray]: Dictionary mapping variable names to their samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample_all(self, size: int = 1) -&gt; dict[str, np.ndarray]:\n    \"\"\"Sample from all variables in the list.\n\n    Args:\n        size (int): Number of samples to generate per variable\n\n    Returns:\n        dict[str, np.ndarray]: Dictionary mapping variable names to their samples\n    \"\"\"\n    return {var.name: var.sample(size) for var in self.objects}\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UNSET","title":"UNSET","text":"<p>               Bases: <code>Enum</code></p> <p>Sentinel value to indicate an unset value state.</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution","title":"UniformDistribution","text":"<p>               Bases: <code>RandomVariable[float]</code></p> <p>Continuous uniform distribution over an interval [low, high].</p> <p>The uniform distribution describes equal probability over a continuous interval. Any value between low and high is equally likely to be drawn.</p> Key Properties <ul> <li>Mean = (low + high)/2</li> <li>Variance = (high - low)\u00b2/12</li> <li>Constant PDF over [low, high]</li> <li>Linear CDF over [low, high]</li> </ul> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>Lower bound of the interval</p> <code>high</code> <code>float</code> <p>Upper bound of the interval</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the uniform cumulative distribution function.</p> <p>The CDF is: - 0 for x &lt; low - (x-low)/(high-low) for low \u2264 x \u2264 high - 1 for x &gt; high</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the uniform cumulative distribution function.\n\n    The CDF is:\n    - 0 for x &lt; low\n    - (x-low)/(high-low) for low \u2264 x \u2264 high\n    - 1 for x &gt; high\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return np.where(\n        x &lt; self.low,\n        0.0,\n        np.where(\n            x &gt; self.high,\n            1.0,\n            (x - self.low) / (self.high - self.low)\n        )\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the uniform probability density function.</p> <p>The PDF is 1/(high-low) for x in [low,high] and 0 elsewhere.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: PDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the uniform probability density function.\n\n    The PDF is 1/(high-low) for x in [low,high] and 0 elsewhere.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: PDF values at the input points\n    \"\"\"\n    return np.where(\n        (x &gt;= self.low) &amp; (x &lt;= self.high),\n        1.0 / (self.high - self.low),\n        0.0\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Generate random samples from the uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Array of samples from U(low,high)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Generate random samples from the uniform distribution.\n\n    Args:\n        size (int): Number of samples to generate\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Array of samples from U(low,high)\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.uniform(self.low, self.high, size=size)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/#process_manager.data_handlers.UniformDistribution.validate_bounds","title":"validate_bounds","text":"<pre><code>validate_bounds() -&gt; UniformDistribution\n</code></pre> <p>Validate that high &gt; low.</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>@model_validator(mode='after')\ndef validate_bounds(self) -&gt; UniformDistribution:\n    \"\"\"Validate that high &gt; low.\"\"\"\n    if self.high &lt;= self.low:\n        raise ValueError(f\"Upper bound ({self.high}) must be greater than lower bound ({self.low})\")\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/","title":"base","text":""},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base","title":"base","text":"<p>Base module for named objects and their collections. Provides common functionality for serialization and management of named objects.</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObject","title":"NamedObject","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for named objects with serialization support.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Name of object class type (computed field)</p> <code>name</code> <code>str</code> <p>Name of the object</p> Configuration <p>model_config (ConfigDict): Pydantic model configuration</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObject.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>Returns the name of the object type.</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObject.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(*, registry_category: str = None, **kwargs)\n</code></pre> <p>Register subclasses in appropriate registry category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init_subclass__(cls, *, registry_category: str = None, **kwargs):\n    \"\"\"Register subclasses in appropriate registry category.\"\"\"\n    super().__init_subclass__(**kwargs)\n    if registry_category:\n        cls._registry_category = registry_category\n    ObjectRegistry.register(cls._registry_category, cls)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash","title":"NamedObjectHash","text":"<pre><code>NamedObjectHash(**kwargs: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Dictionary of named objects with type checking and conflict prevention.</p> <p>Attributes:</p> Name Type Description <code>objects</code> <code>dict</code> <p>Dictionary of named objects</p> <p>Initialize with type-specific deserialization.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init__(self, **kwargs: Any):\n    \"\"\"Initialize with type-specific deserialization.\"\"\"\n    self._deserialize_objects(kwargs)\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.get_object","title":"get_object","text":"<pre><code>get_object(name: str) -&gt; NamedObject\n</code></pre> <p>Get object by name.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_object(self, name: str) -&gt; NamedObject:\n    \"\"\"Get object by name.\"\"\"\n    return self.objects[name]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.get_object_names","title":"get_object_names","text":"<pre><code>get_object_names() -&gt; Iterable[str]\n</code></pre> <p>Get names of all objects.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_object_names(self) -&gt; Iterable[str]:\n    \"\"\"Get names of all objects.\"\"\"\n    return self.objects.keys()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.get_objects","title":"get_objects","text":"<pre><code>get_objects() -&gt; Iterable[NamedObject]\n</code></pre> <p>Get all objects.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def get_objects(self) -&gt; Iterable[NamedObject]:\n    \"\"\"Get all objects.\"\"\"\n    return self.objects.values()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectHash.register_object","title":"register_object","text":"<pre><code>register_object(obj: NamedObject) -&gt; Self\n</code></pre> <p>Register a named object. Checks for naming conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>NamedObject</code> <p>Object to register</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If object with same name exists</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def register_object(self, obj: NamedObject) -&gt; Self:\n    \"\"\"\n    Register a named object. Checks for naming conflicts.\n\n    Args:\n        obj (NamedObject): Object to register\n\n    Raises:\n        ValueError: If object with same name exists\n    \"\"\"\n    if obj.name in self.objects:\n        raise ValueError(\n            f\"Naming conflict: An object named '{obj.name}' already exists.\"\n            f\"\\n\\tExisting: \\n{self.get_object(obj.name).model_dump_json(indent=4)}\"\n            f\"\\n\\tNew: \\n{obj.model_dump_json(indent=4)}\"\n        )\n    self.objects[obj.name] = obj\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList","title":"NamedObjectList","text":"<p>               Bases: <code>BaseModel</code></p> <p>List of named objects with type checking.</p> <p>Attributes:</p> Name Type Description <code>objects</code> <code>list</code> <p>List of named objects</p> Example <p>obj_list = NamedObjectList() obj_list.append(named_object) obj_list.extend([obj1, obj2, obj3])</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NamedObject\n</code></pre> <p>Get object by index.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NamedObject:\n    \"\"\"Get object by index.\"\"\"\n    return self.objects[idx]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterable[NamedObject]\n</code></pre> <p>Iterate over objects in list.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __iter__(self) -&gt; Iterable[NamedObject]:\n    \"\"\"Iterate over objects in list.\"\"\"\n    return iter(self.objects)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of objects in list.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of objects in list.\"\"\"\n    return len(self.objects)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.append","title":"append","text":"<pre><code>append(obj: NamedObject) -&gt; Self\n</code></pre> <p>Append a single object to the list.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>NamedObject</code> <p>Object to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def append(self, obj: NamedObject) -&gt; Self:\n    \"\"\"\n    Append a single object to the list.\n\n    Args:\n        obj (NamedObject): Object to append\n\n    Returns:\n        Self: Returns self for chaining\n    \"\"\"\n    self.objects.append(obj)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.extend","title":"extend","text":"<pre><code>extend(objects: Iterable[NamedObject]) -&gt; Self\n</code></pre> <p>Extend list with multiple objects.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>Iterable[NamedObject]</code> <p>Objects to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def extend(self, objects: Iterable[NamedObject]) -&gt; Self:\n    \"\"\"\n    Extend list with multiple objects.\n\n    Args:\n        objects (Iterable[NamedObject]): Objects to add\n\n    Returns:\n        Self: Returns self for chaining\n    \"\"\"\n    self.objects.extend(objects)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.NamedObjectList.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(iterable: Iterable[NamedObject]) -&gt; Self\n</code></pre> <p>Create instance from an iterable of named objects.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[NamedObject]</code> <p>Objects to add to list</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>New instance containing the objects</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef from_iterable(cls, iterable: Iterable[NamedObject]) -&gt; Self:\n    \"\"\"\n    Create instance from an iterable of named objects.\n\n    Args:\n        iterable (Iterable[NamedObject]): Objects to add to list\n\n    Returns:\n        Self: New instance containing the objects\n    \"\"\"\n    return cls(objects=list(iterable))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry","title":"ObjectRegistry","text":"<p>Generic registry for named object types.</p> <p>Stores object types for deserialization from JSON files. Types are stored at the class level for consistent access across modules.</p> <p>Types are stored at the class level for consistent access across modules.</p> <p>Methods:</p> Name Description <code>register</code> <p>Register an object type</p> <code>get</code> <p>Get an object type by name</p> <code>get_all</code> <p>Get all registered object types</p>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(category: str, name: str) -&gt; Type[NamedObject]\n</code></pre> <p>Get an object type by category and name.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get(cls, category: str, name: str) -&gt; Type[NamedObject]:\n    \"\"\"Get an object type by category and name.\"\"\"\n    registry = cls.get_registry(category)\n    if name not in registry:\n        raise ValueError(f\"{name} not found in {category} registry\")\n    return registry[name]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry.get_all","title":"get_all  <code>classmethod</code>","text":"<pre><code>get_all(category: str) -&gt; list[Type[NamedObject]]\n</code></pre> <p>Get all registered types for a category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get_all(cls, category: str) -&gt; list[Type[NamedObject]]:\n    \"\"\"Get all registered types for a category.\"\"\"\n    return list(cls.get_registry(category).values())\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry.get_registry","title":"get_registry  <code>classmethod</code>","text":"<pre><code>get_registry(category: str) -&gt; Dict[str, Type[NamedObject]]\n</code></pre> <p>Get or create registry for a category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef get_registry(cls, category: str) -&gt; Dict[str, Type[NamedObject]]:\n    \"\"\"Get or create registry for a category.\"\"\"\n    # Get the actual string value if it's a PrivateAttr\n    if hasattr(category, 'default'):\n        category = category.default\n    if category not in cls._registries:\n        cls._registries[category] = {}\n    return cls._registries[category]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/base/#process_manager.data_handlers.base.ObjectRegistry.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(category: str, obj_type: Type[NamedObject]) -&gt; None\n</code></pre> <p>Register an object type in its category.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>@classmethod\ndef register(cls, category: str, obj_type: Type[NamedObject]) -&gt; None:\n    \"\"\"Register an object type in its category.\"\"\"\n    # Get the actual string value if it's a PrivateAttr\n    if hasattr(category, 'default'):\n        category = category.default\n    registry = cls.get_registry(category)\n    registry[obj_type.__name__] = obj_type\n</code></pre>"},{"location":"reference/process_manager/data_handlers/mixins/","title":"mixins","text":""},{"location":"reference/process_manager/data_handlers/mixins/#process_manager.data_handlers.mixins","title":"mixins","text":"<p>Defines inputs</p>"},{"location":"reference/process_manager/data_handlers/mixins/#process_manager.data_handlers.mixins.ArrayDunders","title":"ArrayDunders","text":"<p>               Bases: <code>NumericDunders</code></p> <p>A mixin class that extends NumericDunders with additional array-like behavior.</p>"},{"location":"reference/process_manager/data_handlers/mixins/#process_manager.data_handlers.mixins.NumericDunders","title":"NumericDunders","text":"<p>A mixin class containing numeric dunder methods that can be applied to any class via composition</p> <p>Attributes:</p> Name Type Description <code>RESERVED_NAME</code> <code>str</code> <p>Name of the reserved attribute that holds the value</p>"},{"location":"reference/process_manager/data_handlers/mixins/#process_manager.data_handlers.mixins.NumericDunders.get_value","title":"get_value  <code>classmethod</code>","text":"<pre><code>get_value(instance)\n</code></pre> <p>Get the value of the instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>Instance of the class</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Value of the instance stored in the reserved attribute or else returns the instance. For example, if the reserved attribute is 'value', then it returns <code>instance.value</code> else if the instance is just a float or an int or something like that, then it returns the instance itself.</p> Source code in <code>src/process_manager/data_handlers/mixins.py</code> <pre><code>@classmethod\ndef get_value(cls, instance):\n    \"\"\"\n    Get the value of the instance\n\n    Args:\n        instance (Any): Instance of the class\n\n    Returns:\n        Any: Value of the instance stored in the reserved attribute or else returns the instance.\n            For example, if the reserved attribute is 'value', then it returns `instance.value` else\n            if the instance is just a float or an int or something like that, then it returns the instance itself.\n    \"\"\"\n    return getattr(instance, cls.RESERVED_NAME, instance)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/","title":"random_variables","text":""},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables","title":"random_variables","text":"<p>Random Variable Implementations for Process Analysis.</p> <p>This module provides a framework for working with random variables and probability distributions in a type-safe, numerically stable way. It includes implementations of common distributions (Normal, Uniform, Categorical) and infrastructure for managing collections of random variables.</p> <p>The module uses a metaclass-based approach to ensure consistent handling of array dimensions across all distributions, making it easy to work with both scalar and vector-valued random variables.</p> Key Features <ul> <li>Type-safe implementations of common probability distributions</li> <li>Automatic dimension handling via the squeezable decorator</li> <li>Support for reproducible sampling via seed management</li> <li>Collections for managing groups of random variables</li> <li>Serialization support via pydantic</li> </ul>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution","title":"CategoricalDistribution","text":"<p>               Bases: <code>RandomVariable[T]</code></p> <p>Categorical distribution for discrete outcomes with specified probabilities.</p> <p>A categorical distribution (also called a discrete distribution) describes the probability of obtaining one of k possible outcomes. Each outcome has a probability between 0 and 1, and all probabilities must sum to 1.</p> <p>If probabilities are not specified, defaults to equal probabilities for all categories (uniform discrete distribution).</p> Key Properties <ul> <li>Support is finite set of categories</li> <li>PMF gives probability of each category</li> <li>CDF is step function</li> </ul> <p>Attributes:</p> Name Type Description <code>categories</code> <code>ndarray</code> <p>Array of possible outcomes (any type)</p> <code>probabilities</code> <code>ndarray</code> <p>Probability for each category</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p> <code>replace</code> <code>bool</code> <p>Whether or not to allow multiple draws of the same value (allowed if True)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If probabilities don't sum to 1</p> <code>ValueError</code> <p>If lengths of categories and probabilities don't match</p> <code>ValueError</code> <p>If any probability is negative</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the cumulative distribution function.</p> <p>For categorical distributions, this is a step function that increases at each category by that category's probability.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the cumulative distribution function.\n\n    For categorical distributions, this is a step function that\n    increases at each category by that category's probability.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return np.array([\n        np.sum(self.probabilities[self.categories &lt;= val])\n        for val in x\n    ])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the probability mass function (PMF).</p> <p>For categorical distributions, this gives the probability of each category occurring.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PMF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Probability of each input value</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the probability mass function (PMF).\n\n    For categorical distributions, this gives the probability of\n    each category occurring.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PMF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Probability of each input value\n    \"\"\"\n    return np.array([\n        self.probabilities[self.categories == val].item()\n        if val in self.categories else 0.0\n        for val in x\n    ])\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Generate random samples from the categorical distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate. Defaults to 1.</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> Notes <p>The squeeze parameter is added automatically by the metaclass and does not appear in the function signature, but can be passed as a keyword argument.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>NDArray[Any,T]: Array of samples from the categories</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any,T]:\n    \"\"\"Generate random samples from the categorical distribution.\n\n    Args:\n        size (int, optional): Number of samples to generate. Defaults to 1.\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Notes:\n        The squeeze parameter is added automatically by the metaclass and does not appear\n        in the function signature, but can be passed as a keyword argument.\n\n    Returns:\n        NDArray[Any,T]: Array of samples from the categories\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.choice(self.categories, size=size, p=self.probabilities, replace=self.replace)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.CategoricalDistribution.validate_and_set_probabilities","title":"validate_and_set_probabilities","text":"<pre><code>validate_and_set_probabilities() -&gt; CategoricalDistribution\n</code></pre> <p>Validate probability values and set defaults if needed.</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>@model_validator(mode='after')\ndef validate_and_set_probabilities(self) -&gt; CategoricalDistribution:\n    \"\"\"Validate probability values and set defaults if needed.\"\"\"\n    if self.probabilities is None:\n        n_categories = len(self.categories)\n        self.probabilities = np.ones(n_categories) / n_categories\n        return self\n\n    if len(self.categories) != len(self.probabilities):\n        raise ValueError(\n            f\"Number of categories ({len(self.categories)}) must match \"\n            f\"number of probabilities ({len(self.probabilities)})\"\n        )\n    if not np.all(self.probabilities &gt;= 0):\n        raise ValueError(\"All probabilities must be non-negative\")\n    if not np.isclose(np.sum(self.probabilities), 1.0):\n        raise ValueError(\"Probabilities must sum to 1\")\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.NormalDistribution","title":"NormalDistribution","text":"<p>               Bases: <code>RandomVariable[float]</code></p> <p>Normal (Gaussian) distribution with mean \u03bc and standard deviation \u03c3.</p> <p>The normal distribution is a continuous probability distribution that is symmetric about its mean, showing the familiar bell-shaped curve.</p> Key Properties <ul> <li>Symmetric about the mean</li> <li>~68% of values lie within 1\u03c3 of \u03bc</li> <li>~95% lie within 2\u03c3 of \u03bc</li> <li>~99.7% lie within 3\u03c3 of \u03bc</li> </ul> <p>Attributes:</p> Name Type Description <code>mu</code> <code>float</code> <p>Mean (\u03bc) of the distribution</p> <code>sigma</code> <code>float</code> <p>Standard deviation (\u03c3) of the distribution</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.NormalDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the normal cumulative distribution function.</p> <p>The CDF is computed using the error function: F(x) = 1/2 * (1 + erf((x-\u03bc)/(\u03c3\u221a2)))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the normal cumulative distribution function.\n\n    The CDF is computed using the error function:\n    F(x) = 1/2 * (1 + erf((x-\u03bc)/(\u03c3\u221a2)))\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return 0.5 * (1 + sp.erf((x - self.mu)/(self.sigma * np.sqrt(2))))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.NormalDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the normal probability density function.</p> <p>The PDF is given by: f(x) = 1/(\u03c3\u221a(2\u03c0)) * exp(-(x-\u03bc)\u00b2/(2\u03c3\u00b2))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: PDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the normal probability density function.\n\n    The PDF is given by:\n    f(x) = 1/(\u03c3\u221a(2\u03c0)) * exp(-(x-\u03bc)\u00b2/(2\u03c3\u00b2))\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: PDF values at the input points\n    \"\"\"\n    return 1/(self.sigma * np.sqrt(2*np.pi)) * np.exp(-(x - self.mu)**2 / (2*self.sigma**2))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.NormalDistribution.sample","title":"sample","text":"<pre><code>sample(size: int | tuple[int, ...] = 1, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Generate random samples from the normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int | tuple[int, ...]</code> <p>Number or shape of samples</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Array of samples from N(\u03bc, \u03c3)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int | tuple[int, ...] = 1, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Generate random samples from the normal distribution.\n\n    Args:\n        size (int | tuple[int, ...]): Number or shape of samples\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Array of samples from N(\u03bc, \u03c3)\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.normal(self.mu, self.sigma, size=size)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable","title":"RandomVariable","text":"<p>               Bases: <code>NamedObject</code>, <code>Generic[T]</code></p> <p>Base class for random variables.</p> <p>This class provides a common interface for random variable implementations. Subclasses must implement sample(), pdf(), and cdf() methods. The metaclass ensures these methods support dimension control via the squeeze parameter.</p> <p>The class is generic over the type of values it produces (T), which must be a subtype of SerializableValue to ensure proper serialization behavior.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p> <code>name</code> <code>str</code> <p>Identifier for this random variable instance</p> Type Variables <p>T: The type of values produced by this random variable</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Evaluate cumulative distribution function at specified points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>CDF values at the input points</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Evaluate cumulative distribution function at specified points.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): CDF values at the input points\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Evaluate probability density function at specified points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>PDF values at the input points</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Evaluate probability density function at specified points.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): PDF values at the input points\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable.register_to_hash","title":"register_to_hash","text":"<pre><code>register_to_hash(\n    var_hash: RandomVariableHash, size: int = 1, sample: bool = True, squeeze: bool = True\n) -&gt; NamedValue[T | NDArray[Any, T]]\n</code></pre> <p>Register this random variable to a hash and return sampled values.</p> <p>This is a convenience method for adding a random variable to a collection and immediately sampling from it.</p> <p>Parameters:</p> Name Type Description Default <code>var_hash</code> <code>RandomVariableHash</code> <p>Hash object to register to</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>NamedValue[T | NDArray[Any, T]]</code> <p>Named value containing samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_to_hash(\n        self, \n        var_hash: RandomVariableHash, \n        size: int = 1, \n        sample: bool = True,\n        squeeze: bool = True,\n    ) -&gt; NamedValue[T|NDArray[Any,T]]:\n    \"\"\"Register this random variable to a hash and return sampled values.\n\n    This is a convenience method for adding a random variable to a collection\n    and immediately sampling from it.\n\n    Args:\n        var_hash (RandomVariableHash): Hash object to register to\n        size (int): Number of samples to generate\n\n    Returns:\n        (NamedValue[T|NDArray[Any,T]]): Named value containing samples\n    \"\"\"\n    return var_hash.register_variable(self, size=size, sample=sample, squeeze=squeeze)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariable.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, T]\n</code></pre> <p>Generate random samples from the categorical distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate. Defaults to 1.</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, T]</code> <p>Array of samples from the categories</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any, T]:\n    \"\"\"Generate random samples from the categorical distribution.\n\n    Args:\n        size (int): Number of samples to generate. Defaults to 1.\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        (NDArray[Any, T]): Array of samples from the categories\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableHash","title":"RandomVariableHash","text":"<pre><code>RandomVariableHash(**kwargs: Any)\n</code></pre> <p>               Bases: <code>NamedObjectHash</code></p> <p>Collection of random variables.</p> <p>This class manages a collection of RandomVariable objects, providing methods to register, retrieve and sample from multiple distributions.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <p>Initialize with type-specific deserialization.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init__(self, **kwargs: Any):\n    \"\"\"Initialize with type-specific deserialization.\"\"\"\n    self._deserialize_objects(kwargs)\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableHash.get_variables","title":"get_variables","text":"<pre><code>get_variables() -&gt; Iterable[RandomVariable]\n</code></pre> <p>Get all registered random variables.</p> <p>Returns:</p> Type Description <code>Iterable[RandomVariable]</code> <p>Iterable[RandomVariable]: Iterator over all registered variables</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variables(self) -&gt; Iterable[RandomVariable]:\n    \"\"\"Get all registered random variables.\n\n    Returns:\n        Iterable[RandomVariable]: Iterator over all registered variables\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableHash.register_variable","title":"register_variable","text":"<pre><code>register_variable(\n    var: RandomVariable, size: int = 1, sample: bool = True, squeeze: bool = True\n) -&gt; NamedValue[SerializableValue | NDArray[Any, SerializableValue]]\n</code></pre> <p>Register a random variable and return its samples wrapped in a NamedValue.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>RandomVariable</code> <p>Random variable to register</p> required <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>NamedValue[SerializableValue | NDArray[Any, SerializableValue]]</code> <p>NamedValue[SerializableValue|NDArray[Any,SerializableValue]]: Named value containing samples</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a variable with the same name already exists</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_variable(\n        self, \n        var: RandomVariable, \n        size: int = 1,\n        sample: bool = True,\n        squeeze: bool = True,\n    ) -&gt; NamedValue[SerializableValue|NDArray[Any,SerializableValue]]:\n    \"\"\"Register a random variable and return its samples wrapped in a NamedValue.\n\n    Args:\n        var (RandomVariable): Random variable to register\n        size (int): Number of samples to generate\n\n    Returns:\n        NamedValue[SerializableValue|NDArray[Any,SerializableValue]]: Named value containing samples\n\n    Raises:\n        ValueError: If a variable with the same name already exists\n    \"\"\"\n    if var.name in self.objects:\n        raise ValueError(f\"A variable with name '{var.name}' already exists in the collection\")\n\n    self.register_object(var)\n    if sample:\n        samples = var.sample(size=size)\n        if squeeze:\n            return NamedValue(name=var.name, value=samples.squeeze())\n        else:\n            return NamedValue(name=var.name, value=samples)\n    else:\n        return None\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableHash.sample_all","title":"sample_all","text":"<pre><code>sample_all(size: int = 1) -&gt; dict[str, ndarray]\n</code></pre> <p>Sample from all registered distributions.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate per distribution</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>dict[str, np.ndarray]: Dictionary mapping variable names to their samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample_all(self, size: int = 1) -&gt; dict[str, np.ndarray]:\n    \"\"\"Sample from all registered distributions.\n\n    Args:\n        size (int): Number of samples to generate per distribution\n\n    Returns:\n        dict[str, np.ndarray]: Dictionary mapping variable names to their samples\n    \"\"\"\n    return {name: var.sample(size) for name, var in self.objects.items()}\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList","title":"RandomVariableList","text":"<p>               Bases: <code>NamedObjectList</code></p> <p>List of random variables.</p> <p>This class manages an ordered list of RandomVariable objects, providing methods to add, access, and sample from multiple distributions while maintaining their order.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>objects</code> <code>List[SerializeAsAny[InstanceOf[RandomVariable]]]</code> <p>List of random variable objects</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; RandomVariable\n</code></pre> <p>Get a random variable by its index in the list.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the random variable to retrieve</p> required <p>Returns:</p> Name Type Description <code>RandomVariable</code> <code>RandomVariable</code> <p>The random variable at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; RandomVariable:\n    \"\"\"Get a random variable by its index in the list.\n\n    Args:\n        idx (int): Index of the random variable to retrieve\n\n    Returns:\n        RandomVariable: The random variable at the specified index\n\n    Raises:\n        IndexError: If the index is out of range\n    \"\"\"\n    return super().__getitem__(idx)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.append","title":"append","text":"<pre><code>append(variable: RandomVariable) -&gt; Self\n</code></pre> <p>Append a random variable to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>RandomVariable</code> <p>Random variable to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance for method chaining</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def append(self, variable: RandomVariable) -&gt; Self:\n    \"\"\"Append a random variable to the end of the list.\n\n    Args:\n        variable (RandomVariable): Random variable to append\n\n    Returns:\n        Self: The RandomVariableList instance for method chaining\n    \"\"\"\n    return super().append(variable)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.extend","title":"extend","text":"<pre><code>extend(variables: Iterable[RandomVariable]) -&gt; Self\n</code></pre> <p>Extend the list with multiple random variables.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>Iterable[RandomVariable]</code> <p>Collection of random variables to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance for method chaining</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def extend(self, variables: Iterable[RandomVariable]) -&gt; Self:\n    \"\"\"Extend the list with multiple random variables.\n\n    Args:\n        variables (Iterable[RandomVariable]): Collection of random variables to add\n\n    Returns:\n        Self: The RandomVariableList instance for method chaining\n    \"\"\"\n    return super().extend(variables)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: str) -&gt; RandomVariable\n</code></pre> <p>Get a registered random variable by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the random variable</p> required <p>Returns:</p> Name Type Description <code>RandomVariable</code> <code>RandomVariable</code> <p>The requested random variable</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no variable exists with the given name</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variable(self, name: str) -&gt; RandomVariable:\n    \"\"\"Get a registered random variable by name.\n\n    Args:\n        name (str): Name of the random variable\n\n    Returns:\n        RandomVariable: The requested random variable\n\n    Raises:\n        KeyError: If no variable exists with the given name\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.get_variables","title":"get_variables","text":"<pre><code>get_variables() -&gt; Iterable[RandomVariable]\n</code></pre> <p>Get all registered random variables.</p> <p>Returns:</p> Type Description <code>Iterable[RandomVariable]</code> <p>Iterable[RandomVariable]: Iterator over all registered variables</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def get_variables(self) -&gt; Iterable[RandomVariable]:\n    \"\"\"Get all registered random variables.\n\n    Returns:\n        Iterable[RandomVariable]: Iterator over all registered variables\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.register_variable","title":"register_variable","text":"<pre><code>register_variable(var: RandomVariable) -&gt; Self\n</code></pre> <p>Register a random variable to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>RandomVariable</code> <p>Random variable to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The RandomVariableList instance</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def register_variable(self, var: RandomVariable) -&gt; Self:\n    \"\"\"Register a random variable to the collection.\n\n    Args:\n        var (RandomVariable): Random variable to register\n\n    Returns:\n        Self: The RandomVariableList instance\n    \"\"\"\n    return self.register_object(var)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableList.sample_all","title":"sample_all","text":"<pre><code>sample_all(size: int = 1) -&gt; dict[str, ndarray]\n</code></pre> <p>Sample from all variables in the list.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate per variable</p> <code>1</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>dict[str, np.ndarray]: Dictionary mapping variable names to their samples</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample_all(self, size: int = 1) -&gt; dict[str, np.ndarray]:\n    \"\"\"Sample from all variables in the list.\n\n    Args:\n        size (int): Number of samples to generate per variable\n\n    Returns:\n        dict[str, np.ndarray]: Dictionary mapping variable names to their samples\n    \"\"\"\n    return {var.name: var.sample(size) for var in self.objects}\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.RandomVariableMeta","title":"RandomVariableMeta","text":"<p>               Bases: <code>type(BaseModel)</code></p> <p>Metaclass for random variable implementations that automatically adds array handling functionality.</p> <p>This metaclass inherits from pydantic's model metaclass to maintain compatibility with the  BaseModel validation system while adding automatic array handling capabilities to all random  variable implementations.</p> Key Features <ul> <li>Automatically applies the <code>squeezable</code> decorator to sample(), pdf(), and cdf() methods</li> <li>Maintains compatibility with pydantic's model validation system</li> <li>Ensures consistent array handling across all random variable implementations</li> </ul> The metaclass processes each new random variable class during its creation by <ol> <li>Identifying the standard distribution methods (sample, pdf, cdf)</li> <li>If these methods are defined in the class (not inherited), wrapping them with    the squeezable decorator</li> <li>Preserving the original method docstrings while adding squeeze parameter documentation</li> </ol> Example <pre><code>class NormalDistribution(RandomVariable[float]):\n    def sample(self, size: int = 1) -&gt; NDArray[Any, float]:\n        # Method will automatically get squeeze functionality\n        # and accept an optional `bool` defaulting to `squeeze=True`\n        return rng.normal(self.mu, self.sigma, size=size)\n</code></pre> Technical Details <ul> <li>Inherits from type(BaseModel) to maintain pydantic compatibility</li> <li>Uses new to modify class attributes during class creation</li> <li>Preserves method signatures while adding the squeeze parameter</li> <li>Ensures proper type hints and docstring updates</li> </ul> Notes <ul> <li>The squeezable decorator adds a <code>squeeze</code> parameter to wrapped methods</li> <li>When squeeze=True (default), output arrays are squeezed and 0-d arrays   are converted to scalar values</li> <li>Original method behavior is preserved when squeeze=False</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mcs</code> <p>The metaclass instance</p> required <code>name</code> <code>str</code> <p>Name of the class being created</p> required <code>bases</code> <code>tuple</code> <p>Base classes</p> required <code>namespace</code> <code>dict</code> <p>Class namespace dictionary</p> required <code>**kwargs</code> <p>Additional keyword arguments passed to type(BaseModel)</p> required <p>Returns:</p> Type Description <code>type</code> <p>The created class with enhanced array handling capabilities</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution","title":"UniformDistribution","text":"<p>               Bases: <code>RandomVariable[float]</code></p> <p>Continuous uniform distribution over an interval [low, high].</p> <p>The uniform distribution describes equal probability over a continuous interval. Any value between low and high is equally likely to be drawn.</p> Key Properties <ul> <li>Mean = (low + high)/2</li> <li>Variance = (high - low)\u00b2/12</li> <li>Constant PDF over [low, high]</li> <li>Linear CDF over [low, high]</li> </ul> <p>Attributes:</p> Name Type Description <code>low</code> <code>float</code> <p>Lower bound of the interval</p> <code>high</code> <code>float</code> <p>Upper bound of the interval</p> <code>name</code> <code>str</code> <p>Identifier for this distribution instance</p> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible sampling</p>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution.cdf","title":"cdf","text":"<pre><code>cdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the uniform cumulative distribution function.</p> <p>The CDF is: - 0 for x &lt; low - (x-low)/(high-low) for low \u2264 x \u2264 high - 1 for x &gt; high</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the CDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: CDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def cdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the uniform cumulative distribution function.\n\n    The CDF is:\n    - 0 for x &lt; low\n    - (x-low)/(high-low) for low \u2264 x \u2264 high\n    - 1 for x &gt; high\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the CDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: CDF values at the input points\n    \"\"\"\n    return np.where(\n        x &lt; self.low,\n        0.0,\n        np.where(\n            x &gt; self.high,\n            1.0,\n            (x - self.low) / (self.high - self.low)\n        )\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution.pdf","title":"pdf","text":"<pre><code>pdf(x: ndarray, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Evaluate the uniform probability density function.</p> <p>The PDF is 1/(high-low) for x in [low,high] and 0 elsewhere.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Points at which to evaluate the PDF</p> required <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: PDF values at the input points</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def pdf(self, x: np.ndarray, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Evaluate the uniform probability density function.\n\n    The PDF is 1/(high-low) for x in [low,high] and 0 elsewhere.\n\n    Args:\n        x (np.ndarray): Points at which to evaluate the PDF\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: PDF values at the input points\n    \"\"\"\n    return np.where(\n        (x &gt;= self.low) &amp; (x &lt;= self.high),\n        1.0 / (self.high - self.low),\n        0.0\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution.sample","title":"sample","text":"<pre><code>sample(size: int = 1, **kwargs) -&gt; NDArray[Any, float]\n</code></pre> <p>Generate random samples from the uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of samples to generate</p> <code>1</code> <p>Other Parameters:</p> Name Type Description <code>squeeze</code> <code>bool</code> <p>Whether to remove unnecessary dimensions. Added by RandomVariableMeta. Defaults is <code>True</code>.</p> <p>Returns:</p> Type Description <code>NDArray[Any, float]</code> <p>NDArray[Any,float]: Array of samples from U(low,high)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def sample(self, size: int = 1, **kwargs) -&gt; NDArray[Any,float]:\n    \"\"\"Generate random samples from the uniform distribution.\n\n    Args:\n        size (int): Number of samples to generate\n\n    Other Parameters:\n        squeeze (bool, optional): Whether to remove unnecessary dimensions.\n            Added by RandomVariableMeta. Defaults is `True`.\n\n    Returns:\n        NDArray[Any,float]: Array of samples from U(low,high)\n    \"\"\"\n    rng = np.random.default_rng(self.seed)\n    return rng.uniform(self.low, self.high, size=size)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.UniformDistribution.validate_bounds","title":"validate_bounds","text":"<pre><code>validate_bounds() -&gt; UniformDistribution\n</code></pre> <p>Validate that high &gt; low.</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>@model_validator(mode='after')\ndef validate_bounds(self) -&gt; UniformDistribution:\n    \"\"\"Validate that high &gt; low.\"\"\"\n    if self.high &lt;= self.low:\n        raise ValueError(f\"Upper bound ({self.high}) must be greater than lower bound ({self.low})\")\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/random_variables/#process_manager.data_handlers.random_variables.squeezable","title":"squeezable","text":"<pre><code>squeezable(func: Callable[P, R], squeeze_by_default: bool = False) -&gt; Callable[P, R]\n</code></pre> <p>Decorator that makes a function's output array squeezable via an added keyword argument <code>squeeze</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to be decorated.</p> required <code>squeeze_by_default</code> <code>bool</code> <p>Whether or not to squeeze by default</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[P, R]</code> <p>A new function that  squeezes the output of <code>func</code> if added keyword <code>squeeze</code> is True (default)</p> Source code in <code>src/process_manager/data_handlers/random_variables.py</code> <pre><code>def squeezable(func: Callable[P, R], squeeze_by_default: bool = False) -&gt; Callable[P, R]:\n    \"\"\"\n    Decorator that makes a function's output array squeezable\n    via an added keyword argument `squeeze`.\n\n    Args:\n        func (Callable[P, R]): The function to be decorated.\n        squeeze_by_default (bool): Whether or not to squeeze by default\n\n    Returns:\n        (Callable[P, R]): A new function that \n            squeezes the output of `func` if added keyword `squeeze` is True (default)\n    \"\"\"\n    # Get the original signature\n    sig = inspect.signature(func)\n\n    # Create new parameters list with correct ordering\n    parameters = []\n    has_var_kwargs = False\n\n    # First add all non-variadic parameters\n    for param in sig.parameters.values():\n        if param.kind != Parameter.VAR_KEYWORD:\n            parameters.append(param)\n        else:\n            has_var_kwargs = True\n\n    # Add squeeze parameter as keyword-only\n    parameters.append(\n        Parameter(\n            'squeeze',\n            Parameter.KEYWORD_ONLY,\n            default=squeeze_by_default,\n            annotation=bool\n        )\n    )\n\n    # Add var_kwargs at the end if it exists\n    if has_var_kwargs:\n        parameters.append(\n            Parameter(\n                'kwargs',\n                Parameter.VAR_KEYWORD\n            )\n        )\n\n    # Create new signature\n    new_sig = sig.replace(parameters=parameters)\n\n    @wraps(func)\n    def wrapper(*args: P.args, squeeze: bool = squeeze_by_default, **kwargs: P.kwargs) -&gt; R:\n        result = func(*args, **kwargs)\n        if squeeze:\n            result = result.squeeze()\n            if isinstance(result, np.ndarray) and result.ndim == 0:\n                result = result.item()\n        return result\n\n    # Update the wrapper's signature\n    wrapper.__signature__ = new_sig\n    return wrapper\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/","title":"values","text":""},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values","title":"values","text":"<p>Module for generating, sorting, and managing named values. This uses pydantic dataclasses for JSON serialization to avoid overloading system memory.</p>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueTypeVar","title":"NamedValueTypeVar  <code>module-attribute</code>","text":"<pre><code>NamedValueTypeVar = TypeVar('NamedValueType', bound=NamedValue)\n</code></pre> <p>Type variable for NamedValueTypeVar. This type variable is used to define generic types that can be bound to any subclass of NamedValue.</p>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue","title":"NamedValue","text":"<pre><code>NamedValue(name: str, value: T | None = None, **data)\n</code></pre> <p>               Bases: <code>NamedObject</code>, <code>Generic[T]</code></p> <p>Initialize a new NamedValue instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name identifier for this value</p> required <code>value</code> <code>T</code> <p>Initial value to set. If provided, this value becomes frozen after initialization. Defaults to None.</p> <code>None</code> <code>**data</code> <p>Additional keyword arguments passed to parent class</p> <code>{}</code> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __init__(self, name: str, value: T | None = None, **data):\n    \"\"\"\n    Initialize a new NamedValue instance.\n\n    Args:\n        name (str): The name identifier for this value\n        value (T, optional): Initial value to set. If provided,\n            this value becomes frozen after initialization. Defaults to None.\n        **data: Additional keyword arguments passed to parent class\n    \"\"\"\n    super().__init__(name=name, **data)\n    self._type = self._extract_value_type()\n\n    if value is not None:\n        self.value = value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: T\n</code></pre> <p>Get the stored value.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The currently stored value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to access the value before it has been set</p>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.append_to_value_list","title":"append_to_value_list","text":"<pre><code>append_to_value_list(l: NamedValueList) -&gt; Self\n</code></pre> <p>Appends self to given list.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>NamedValueList</code> <p>list to which self will be appended</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns instance of self for method chaining</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def append_to_value_list(self, l: NamedValueList) -&gt; Self:\n    \"\"\"\n    Appends self to given list.\n\n    Args:\n        l (NamedValueList): list to which self will be appended\n\n    Returns:\n        Self: returns instance of self for method chaining\n    \"\"\"\n    l.append(self)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.force_set_value","title":"force_set_value","text":"<pre><code>force_set_value(new_value: T) -&gt; None\n</code></pre> <p>Force set the value regardless of whether it was previously set.</p> <p>This method bypasses the frozen value protection but still performs type checking. It's primarily intended for internal use cases like value override systems.</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>T</code> <p>The new value to force set</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value doesn't match the expected type</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def force_set_value(self, new_value: T) -&gt; None:\n    \"\"\"\n    Force set the value regardless of whether it was previously set.\n\n    This method bypasses the frozen value protection but still performs type checking.\n    It's primarily intended for internal use cases like value override systems.\n\n    Args:\n        new_value (T): The new value to force set\n\n    Raises:\n        TypeError: If the value doesn't match the expected type\n    \"\"\"\n    self._stored_value = UNSET.token\n    self.value = new_value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValue.register_to_value_hash","title":"register_to_value_hash","text":"<pre><code>register_to_value_hash(h: NamedValueHash) -&gt; Self\n</code></pre> <p>Registers self to the NamedValueHash object.</p> <p>The hash may override this value's current value if there are value overrides defined in the hash. This is done using force_set_value() internally.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>NamedValueHash</code> <p>Hash to which self will be registered</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>returns instance of self for method chaining</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_to_value_hash(self, h: NamedValueHash) -&gt; Self:\n    \"\"\"\n    Registers self to the NamedValueHash object.\n\n    The hash may override this value's current value if there are\n    value overrides defined in the hash. This is done using force_set_value()\n    internally.\n\n    Args:\n        h (NamedValueHash): Hash to which self will be registered\n\n    Returns:\n        Self: returns instance of self for method chaining\n    \"\"\"\n    h.register_value(self)\n    return self\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash","title":"NamedValueHash","text":"<pre><code>NamedValueHash(**kwargs: Any)\n</code></pre> <p>               Bases: <code>NamedObjectHash</code></p> <p>Dictionary of named value instances.</p> <p>A type-safe dictionary for storing and managing NamedValue objects, using the name as the key of the value instance.</p> <p>Initialize with type-specific deserialization.</p> Source code in <code>src/process_manager/data_handlers/base.py</code> <pre><code>def __init__(self, **kwargs: Any):\n    \"\"\"Initialize with type-specific deserialization.\"\"\"\n    self._deserialize_objects(kwargs)\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_raw_value","title":"get_raw_value","text":"<pre><code>get_raw_value(name: str) -&gt; Any\n</code></pre> <p>Get the underlying value by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to retrieve</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The actual value stored in the named value</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_raw_value(self, name: str) -&gt; Any:\n    \"\"\"\n    Get the underlying value by name.\n\n    Args:\n        name (str): Name of the value to retrieve\n\n    Returns:\n        Any: The actual value stored in the named value\n    \"\"\"\n    return self.get_value(name).value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_raw_values","title":"get_raw_values","text":"<pre><code>get_raw_values() -&gt; Iterable[Any]\n</code></pre> <p>Get the underlying values of all named values.</p> <p>Returns:</p> Type Description <code>Iterable[Any]</code> <p>Iterable[Any]: The actual values stored in each NamedValue</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_raw_values(self) -&gt; Iterable[Any]:\n    \"\"\"\n    Get the underlying values of all named values.\n\n    Returns:\n        Iterable[Any]: The actual values stored in each NamedValue\n    \"\"\"\n    return (val.value for val in self.get_values())\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_value","title":"get_value","text":"<pre><code>get_value(name: str) -&gt; NamedValue\n</code></pre> <p>Get value by name.</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value(self, name: str) -&gt; NamedValue:\n    \"\"\"Get value by name.\"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_value_by_type","title":"get_value_by_type","text":"<pre><code>get_value_by_type(value_type: Type) -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all values of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>Type</code> <p>Type to filter values by</p> required <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: Values matching the specified type</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value_by_type(self, value_type: Type) -&gt; Iterable[NamedValue]:\n    \"\"\"\n    Get all values of a specific type.\n\n    Args:\n        value_type (Type): Type to filter values by\n\n    Returns:\n        Iterable[NamedValue]: Values matching the specified type\n    \"\"\"\n    return [val for val in self.get_values() if isinstance(val, value_type)]\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_value_names","title":"get_value_names","text":"<pre><code>get_value_names() -&gt; Iterable[str]\n</code></pre> <p>Get names of all values.</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value_names(self) -&gt; Iterable[str]:\n    \"\"\"Get names of all values.\"\"\"\n    return self.get_object_names()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.get_values","title":"get_values","text":"<pre><code>get_values() -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all values.</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_values(self) -&gt; Iterable[NamedValue]:\n    \"\"\"Get all values.\"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.register_value","title":"register_value","text":"<pre><code>register_value(value: NamedValue) -&gt; Self\n</code></pre> <p>Register a named value. Checks for naming conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>The value to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Returns self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a value with the same name exists</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_value(self, value: NamedValue) -&gt; Self:\n    \"\"\"\n    Register a named value. Checks for naming conflicts.\n\n    Args:\n        value (NamedValue): The value to register\n\n    Returns:\n        Self: Returns self for chaining\n\n    Raises:\n        ValueError: If a value with the same name exists\n    \"\"\"\n    return self.register_object(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueHash.set_raw_value","title":"set_raw_value","text":"<pre><code>set_raw_value(name: str, value: Any) -&gt; None\n</code></pre> <p>Set the underlying value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the value to update</p> required <code>value</code> <code>Any</code> <p>New value to set</p> required Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def set_raw_value(self, name: str, value: Any) -&gt; None:\n    \"\"\"\n    Set the underlying value.\n\n    Args:\n        name (str): Name of the value to update\n        value (Any): New value to set\n    \"\"\"\n    self.get_value(name).value = value\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList","title":"NamedValueList","text":"<p>               Bases: <code>NamedObjectList</code></p> <p>List of named value instances. This class manages an ordered list of NamedValue objects, providing methods to add, access, and manage multiple named values while maintaining their order.</p> <p>Attributes:</p> Name Type Description <code>_registry_category</code> <code>str</code> <p>Category name for object registration</p> <code>objects</code> <code>List[SerializeAsAny[InstanceOf[NamedValue]]]</code> <p>List of named value objects</p>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: int) -&gt; NamedValue\n</code></pre> <p>Get a named value by its index in the list.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the named value to retrieve</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The named value at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> Example <p>value_list = NamedValueList() value_list.append(NamedValue(name=\"price\", value=10.5)) first_value = value_list[0] # Get first named value</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; NamedValue:\n    \"\"\"Get a named value by its index in the list.\n\n    Args:\n        idx (int): Index of the named value to retrieve\n\n    Returns:\n        NamedValue: The named value at the specified index\n\n    Raises:\n        IndexError: If the index is out of range\n\n    Example:\n        &gt;&gt;&gt; value_list = NamedValueList()\n        &gt;&gt;&gt; value_list.append(NamedValue(name=\"price\", value=10.5))\n        &gt;&gt;&gt; first_value = value_list[0] # Get first named value\n    \"\"\"\n    return super().__getitem__(idx)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.append","title":"append","text":"<pre><code>append(value: NamedValue) -&gt; Self\n</code></pre> <p>Append a named value to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>Named value to append</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The NamedValueList instance for method chaining</p> Example <p>value_list = NamedValueList() named_value = NamedValue(name=\"price\", value=10.5) value_list.append(named_value)</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def append(self, value: NamedValue) -&gt; Self:\n    \"\"\"Append a named value to the end of the list.\n\n    Args:\n        value (NamedValue): Named value to append\n\n    Returns:\n        Self: The NamedValueList instance for method chaining\n\n    Example:\n        &gt;&gt;&gt; value_list = NamedValueList()\n        &gt;&gt;&gt; named_value = NamedValue(name=\"price\", value=10.5)\n        &gt;&gt;&gt; value_list.append(named_value)\n    \"\"\"\n    return super().append(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.extend","title":"extend","text":"<pre><code>extend(values: Iterable[NamedValue]) -&gt; Self\n</code></pre> <p>Extend the list with multiple named values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Iterable[NamedValue]</code> <p>Collection of named values to add</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The NamedValueList instance for method chaining</p> Example <p>value_list = NamedValueList() new_values = [ ...     NamedValue(name=\"price\", value=10.5), ...     NamedValue(name=\"quantity\", value=5) ... ] value_list.extend(new_values)</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def extend(self, values: Iterable[NamedValue]) -&gt; Self:\n    \"\"\"Extend the list with multiple named values.\n\n    Args:\n        values (Iterable[NamedValue]): Collection of named values to add\n\n    Returns:\n        Self: The NamedValueList instance for method chaining\n\n    Example:\n        &gt;&gt;&gt; value_list = NamedValueList()\n        &gt;&gt;&gt; new_values = [\n        ...     NamedValue(name=\"price\", value=10.5),\n        ...     NamedValue(name=\"quantity\", value=5)\n        ... ]\n        &gt;&gt;&gt; value_list.extend(new_values)\n    \"\"\"\n    return super().extend(values)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.get_value","title":"get_value","text":"<pre><code>get_value(name: str) -&gt; NamedValue\n</code></pre> <p>Get a registered named value by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the named value</p> required <p>Returns:</p> Name Type Description <code>NamedValue</code> <code>NamedValue</code> <p>The requested named value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no value exists with the given name</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_value(self, name: str) -&gt; NamedValue:\n    \"\"\"Get a registered named value by name.\n\n    Args:\n        name (str): Name of the named value\n\n    Returns:\n        NamedValue: The requested named value\n\n    Raises:\n        KeyError: If no value exists with the given name\n    \"\"\"\n    return self.get_object(name)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.get_values","title":"get_values","text":"<pre><code>get_values() -&gt; Iterable[NamedValue]\n</code></pre> <p>Get all registered named values.</p> <p>Returns:</p> Type Description <code>Iterable[NamedValue]</code> <p>Iterable[NamedValue]: Iterator over all registered values</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def get_values(self) -&gt; Iterable[NamedValue]:\n    \"\"\"Get all registered named values.\n\n    Returns:\n        Iterable[NamedValue]: Iterator over all registered values\n    \"\"\"\n    return self.get_objects()\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.NamedValueList.register_value","title":"register_value","text":"<pre><code>register_value(value: NamedValue) -&gt; Self\n</code></pre> <p>Register a named value to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NamedValue</code> <p>Named value to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The NamedValueList instance</p> Source code in <code>src/process_manager/data_handlers/values.py</code> <pre><code>def register_value(self, value: NamedValue) -&gt; Self:\n    \"\"\"Register a named value to the collection.\n\n    Args:\n        value (NamedValue): Named value to register\n\n    Returns:\n        Self: The NamedValueList instance\n    \"\"\"\n    return self.register_object(value)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/values/#process_manager.data_handlers.values.UNSET","title":"UNSET","text":"<p>               Bases: <code>Enum</code></p> <p>Sentinel value to indicate an unset value state.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/","title":"custom_serde_definitions","text":""},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions","title":"custom_serde_definitions","text":"<p>Defines custom serialization and deserialization definitions for the process manager inputs.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.PandasDataFrame","title":"PandasDataFrame  <code>module-attribute</code>","text":"<pre><code>PandasDataFrame = Annotated[\n    DataFrame, BeforeValidator(to_dataframe), WrapSerializer(from_dataframe)\n]\n</code></pre> <p>Type alias for Pandas DataFrame objects that can be serialized and deserialized. This type alias is used to define the expected data structure when working with Pandas DataFrame objects in a way that allows them to be both serialized and deserialized using the <code>DataFrameSerDe</code> class. The <code>PandasDataFrame</code> type alias is defined as an Annotated type, which means it has two type arguments: <code>pd.DataFrame</code>, which specifies the expected data structure for this type, and a BeforeValidator and PlainSerializer, respectively. This allows you to use Pandas DataFrame objects in your code while ensuring that they can be serialized and deserialized using the <code>DataFrameSerDe</code> class.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.PandasSeries","title":"PandasSeries  <code>module-attribute</code>","text":"<pre><code>PandasSeries = Annotated[Series, BeforeValidator(to_series), WrapSerializer(from_series)]\n</code></pre> <p>Type alias for Pandas Series objects that can be serialized and deserialized. This type alias is used to define the expected data structure when working with Pandas Series objects in a way that allows them to be both serialized and deserialized using the <code>SeriesSerDe</code> class. The <code>PandasSeries</code> type alias is defined as an Annotated type, which means it has two type arguments: <code>pd.Series</code>, which specifies the expected data structure for this type, and a BeforeValidator and PlainSerializer, respectively. This allows you to use Pandas Series objects in your code while ensuring that they can be serialized and deserialized using the <code>SeriesSerDe</code> class.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe","title":"DataFrameSerDe","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to serialize and deserialize Pandas DataFrame objects.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>NDArray[Shape['*'], Any]</code> <p>Column names of the dataframe</p> <code>values</code> <code>NDArray[Shape['*, *'], Any]</code> <p>Values of the dataframe</p> <code>index</code> <code>NDArray[Shape['*'], Any]</code> <p>Index of the dataframe</p> <code>index_name</code> <code>int | str | None</code> <p>Name of the index</p> <code>column_names</code> <code>list[int | str | None]</code> <p>Names of the columns</p> <p>Methods:     as_dataframe(): Convert to Pandas DataFrame object     from_dict(data: dict) -&gt; DataFrameSerDe: Create a new instance from a dictionary     model_validate_json(json: str | bytes, loc: Any = None, prop: Any = None, cls: Any = None, **kwargs: Any) -&gt; Self: Validate and deserialize JSON data into the model.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe.as_dataframe","title":"as_dataframe","text":"<pre><code>as_dataframe()\n</code></pre> <p>Convert to Pandas DataFrame object.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame object from stored data</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def as_dataframe(self):\n    \"\"\"\n    Convert to Pandas DataFrame object.\n\n    Returns:\n        (pd.DataFrame): Pandas DataFrame object from stored data\n    \"\"\"\n    return pd.DataFrame(\n        self.values, \n        columns=pd.Index(self.columns, name=self.column_names), \n        index=pd.Index(self.index, name=self.index_name)\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(df: DataFrame, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)\n</code></pre> <p>Create a new instance from a Pandas DataFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Pandas DataFrame object to convert.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the Pandas DataFrame object.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dataframe(cls, df: pd.DataFrame, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo):\n    \"\"\"\n    Create a new instance from a Pandas DataFrame object.\n\n    Args:\n        df (pd.DataFrame): Pandas DataFrame object to convert.\n\n    Returns:\n        (cls): New instance created from the Pandas DataFrame object.\n    \"\"\"\n    return cls(\n        columns=df.columns.values,\n        values=df.values,\n        index=df.index.values,\n        index_name=df.index.name,\n        column_names=df.columns.name\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict)\n</code></pre> <p>Create a new instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>New DataFrame created from the dictionary.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a new instance from a dictionary.\n\n    Args:\n        d (dict): Dictionary containing the data.\n\n    Returns:\n        (pd.DataFrame): New DataFrame created from the dictionary.\n    \"\"\"\n    try:\n        return pd.DataFrame(\n            d['values'],\n            columns=pd.Index(d['columns'], name=d['column_names']),\n            index=pd.Index(d['index'], name=d['index_name'])\n        )\n    except:\n        raise ValueError(d)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.DataFrameSerDe.to_dataframe","title":"to_dataframe  <code>classmethod</code>","text":"<pre><code>to_dataframe(input: DataFrame | dict | str)\n</code></pre> <p>Convert input to a Pandas DataFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DataFrame | dict | str</code> <p>Input data to convert.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame object from input data.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef to_dataframe(cls, input: pd.DataFrame | dict | str):\n    \"\"\"\n    Convert input to a Pandas DataFrame object.\n\n    Args:\n        input (pd.DataFrame | dict | str): Input data to convert.\n\n    Returns:\n        (pd.DataFrame): Pandas DataFrame object from input data.\n    \"\"\"\n    if isinstance(input, str):\n        return cls.model_validate_json(input).as_dataframe()\n    elif isinstance(input, dict):\n        return cls.from_dict(input)\n    elif isinstance(input, pd.DataFrame):\n        return input\n    else:\n        # breakpoint()\n        raise ValueError(input)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe","title":"SeriesSerDe","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to serialize and deserialize Pandas Series objects.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>int | str | None</code> <p>Name of the series</p> <code>values</code> <code>NDArray[Shape['*'], Any]</code> <p>Values of the series</p> <code>index</code> <code>NDArray[Shape['*'], Any]</code> <p>Index of the series</p> <code>index_name</code> <code>int | str | None</code> <p>Name of the index</p> <p>Methods:     as_series(): Convert to Pandas Series object     from_dict(data: dict) -&gt; SeriesSerDe: Create a new instance from a dictionary     model_validate_json(json: str | bytes, loc: Any = None, prop: Any = None, cls: Any = None, **kwargs: Any) -&gt; Self: Validate and deserialize JSON data into the model.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe.as_series","title":"as_series","text":"<pre><code>as_series()\n</code></pre> <p>Convert to Pandas Series object.</p> <p>Returns:</p> Type Description <code>Series</code> <p>Pandas Series object from stored data</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def as_series(self):\n    \"\"\"\n    Convert to Pandas Series object.\n\n    Returns:\n        (pd.Series): Pandas Series object from stored data\n    \"\"\"\n    return pd.Series(self.values, name=self.name, index=pd.Index(self.index, name=self.index_name))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict)\n</code></pre> <p>Create a new instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing the data.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the dictionary.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a new instance from a dictionary.\n\n    Args:\n        d (dict): Dictionary containing the data.\n\n    Returns:\n        (cls): New instance created from the dictionary.\n    \"\"\"\n    try:\n        return pd.Series(\n            d['values'], \n            name=d['name'],\n            index=pd.Index(\n                d['index'], \n                name=d['index_name'],\n            ),\n        )\n    except:\n        raise ValueError(d)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe.from_series","title":"from_series  <code>classmethod</code>","text":"<pre><code>from_series(series: Series, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)\n</code></pre> <p>Create a new instance from a Pandas Series object.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Pandas Series object to convert.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the Pandas Series object.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_series(cls, series: pd.Series, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo):\n    \"\"\"\n    Create a new instance from a Pandas Series object.\n\n    Args:\n        series (pd.Series): Pandas Series object to convert.\n\n    Returns:\n        (cls): New instance created from the Pandas Series object.\n    \"\"\"\n    return cls(\n        name=series.name,\n        values=series.values,\n        index=series.index.values,\n        index_name=series.index.name,\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/#process_manager.data_handlers.custom_serde_definitions.SeriesSerDe.to_series","title":"to_series  <code>classmethod</code>","text":"<pre><code>to_series(input: Series | dict | str)\n</code></pre> <p>Convert input to a Pandas Series object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Series | dict | str</code> <p>Input data to convert.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Pandas Series object from input data.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef to_series(cls, input: pd.Series | dict | str):\n    \"\"\"\n    Convert input to a Pandas Series object.\n\n    Args:\n        input (pd.Series | dict | str): Input data to convert.\n\n    Returns:\n        (pd.Series): Pandas Series object from input data.\n    \"\"\"\n    if isinstance(input, str):\n        print('str')\n        return cls.model_validate_json(input).as_series()\n    elif isinstance(input, dict):\n        print('dict')\n        return cls.from_dict(input)\n    elif isinstance(input, pd.Series):\n        print('series')\n        return input\n    else:\n        raise ValueError(input)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/","title":"pandantic","text":""},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic","title":"pandantic","text":"<p>Defines types for Pandas Series and DataFrame serialization and deserialization.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.PandasDataFrame","title":"PandasDataFrame  <code>module-attribute</code>","text":"<pre><code>PandasDataFrame = Annotated[\n    DataFrame, BeforeValidator(to_dataframe), WrapSerializer(from_dataframe)\n]\n</code></pre> <p>Type alias for Pandas DataFrame objects that can be serialized and deserialized. This type alias is used to define the expected data structure when working with Pandas DataFrame objects in a way that allows them to be both serialized and deserialized using the <code>DataFrameSerDe</code> class. The <code>PandasDataFrame</code> type alias is defined as an Annotated type, which means it has two type arguments: <code>pd.DataFrame</code>, which specifies the expected data structure for this type, and a BeforeValidator and PlainSerializer, respectively. This allows you to use Pandas DataFrame objects in your code while ensuring that they can be serialized and deserialized using the <code>DataFrameSerDe</code> class.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.PandasSeries","title":"PandasSeries  <code>module-attribute</code>","text":"<pre><code>PandasSeries = Annotated[Series, BeforeValidator(to_series), WrapSerializer(from_series)]\n</code></pre> <p>Type alias for Pandas Series objects that can be serialized and deserialized. This type alias is used to define the expected data structure when working with Pandas Series objects in a way that allows them to be both serialized and deserialized using the <code>SeriesSerDe</code> class. The <code>PandasSeries</code> type alias is defined as an Annotated type, which means it has two type arguments: <code>pd.Series</code>, which specifies the expected data structure for this type, and a BeforeValidator and PlainSerializer, respectively. This allows you to use Pandas Series objects in your code while ensuring that they can be serialized and deserialized using the <code>SeriesSerDe</code> class.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe","title":"DataFrameSerDe","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to serialize and deserialize Pandas DataFrame objects.</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>NDArray[Shape['*'], Any]</code> <p>Column names of the dataframe</p> <code>values</code> <code>NDArray[Shape['*, *'], Any]</code> <p>Values of the dataframe</p> <code>index</code> <code>NDArray[Shape['*'], Any]</code> <p>Index of the dataframe</p> <code>index_name</code> <code>int | str | None</code> <p>Name of the index</p> <code>column_names</code> <code>list[int | str | None]</code> <p>Names of the columns</p> <p>Methods:     as_dataframe(): Convert to Pandas DataFrame object     from_dict(data: dict) -&gt; DataFrameSerDe: Create a new instance from a dictionary     model_validate_json(json: str | bytes, loc: Any = None, prop: Any = None, cls: Any = None, **kwargs: Any) -&gt; Self: Validate and deserialize JSON data into the model.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe.as_dataframe","title":"as_dataframe","text":"<pre><code>as_dataframe()\n</code></pre> <p>Convert to Pandas DataFrame object.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame object from stored data</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def as_dataframe(self):\n    \"\"\"\n    Convert to Pandas DataFrame object.\n\n    Returns:\n        (pd.DataFrame): Pandas DataFrame object from stored data\n    \"\"\"\n    return pd.DataFrame(\n        self.values, \n        columns=pd.Index(self.columns, name=self.column_names), \n        index=pd.Index(self.index, name=self.index_name)\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(df: DataFrame, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)\n</code></pre> <p>Create a new instance from a Pandas DataFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Pandas DataFrame object to convert.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the Pandas DataFrame object.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dataframe(cls, df: pd.DataFrame, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo):\n    \"\"\"\n    Create a new instance from a Pandas DataFrame object.\n\n    Args:\n        df (pd.DataFrame): Pandas DataFrame object to convert.\n\n    Returns:\n        (cls): New instance created from the Pandas DataFrame object.\n    \"\"\"\n    return cls(\n        columns=df.columns.values,\n        values=df.values,\n        index=df.index.values,\n        index_name=df.index.name,\n        column_names=df.columns.name\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict)\n</code></pre> <p>Create a new instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing the data.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>New DataFrame created from the dictionary.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a new instance from a dictionary.\n\n    Args:\n        d (dict): Dictionary containing the data.\n\n    Returns:\n        (pd.DataFrame): New DataFrame created from the dictionary.\n    \"\"\"\n    try:\n        return pd.DataFrame(\n            d['values'],\n            columns=pd.Index(d['columns'], name=d['column_names']),\n            index=pd.Index(d['index'], name=d['index_name'])\n        )\n    except:\n        raise ValueError(d)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.DataFrameSerDe.to_dataframe","title":"to_dataframe  <code>classmethod</code>","text":"<pre><code>to_dataframe(input: DataFrame | dict | str)\n</code></pre> <p>Convert input to a Pandas DataFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DataFrame | dict | str</code> <p>Input data to convert.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame object from input data.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef to_dataframe(cls, input: pd.DataFrame | dict | str):\n    \"\"\"\n    Convert input to a Pandas DataFrame object.\n\n    Args:\n        input (pd.DataFrame | dict | str): Input data to convert.\n\n    Returns:\n        (pd.DataFrame): Pandas DataFrame object from input data.\n    \"\"\"\n    if isinstance(input, str):\n        return cls.model_validate_json(input).as_dataframe()\n    elif isinstance(input, dict):\n        return cls.from_dict(input)\n    elif isinstance(input, pd.DataFrame):\n        return input\n    else:\n        # breakpoint()\n        raise ValueError(input)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe","title":"SeriesSerDe","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to serialize and deserialize Pandas Series objects.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>int | str | None</code> <p>Name of the series</p> <code>values</code> <code>NDArray[Shape['*'], Any]</code> <p>Values of the series</p> <code>index</code> <code>NDArray[Shape['*'], Any]</code> <p>Index of the series</p> <code>index_name</code> <code>int | str | None</code> <p>Name of the index</p> <p>Methods:     as_series(): Convert to Pandas Series object     from_dict(data: dict) -&gt; SeriesSerDe: Create a new instance from a dictionary     model_validate_json(json: str | bytes, loc: Any = None, prop: Any = None, cls: Any = None, **kwargs: Any) -&gt; Self: Validate and deserialize JSON data into the model.</p>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe.as_series","title":"as_series","text":"<pre><code>as_series()\n</code></pre> <p>Convert to Pandas Series object.</p> <p>Returns:</p> Type Description <code>Series</code> <p>Pandas Series object from stored data</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def as_series(self):\n    \"\"\"\n    Convert to Pandas Series object.\n\n    Returns:\n        (pd.Series): Pandas Series object from stored data\n    \"\"\"\n    return pd.Series(self.values, name=self.name, index=pd.Index(self.index, name=self.index_name))\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict)\n</code></pre> <p>Create a new instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing the data.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the dictionary.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a new instance from a dictionary.\n\n    Args:\n        d (dict): Dictionary containing the data.\n\n    Returns:\n        (cls): New instance created from the dictionary.\n    \"\"\"\n    try:\n        return pd.Series(\n            d['values'], \n            name=d['name'],\n            index=pd.Index(\n                d['index'], \n                name=d['index_name'],\n            ),\n        )\n    except:\n        raise ValueError(d)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe.from_series","title":"from_series  <code>classmethod</code>","text":"<pre><code>from_series(series: Series, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)\n</code></pre> <p>Create a new instance from a Pandas Series object.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Pandas Series object to convert.</p> required <p>Returns:</p> Type Description <code>cls</code> <p>New instance created from the Pandas Series object.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef from_series(cls, series: pd.Series, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo):\n    \"\"\"\n    Create a new instance from a Pandas Series object.\n\n    Args:\n        series (pd.Series): Pandas Series object to convert.\n\n    Returns:\n        (cls): New instance created from the Pandas Series object.\n    \"\"\"\n    return cls(\n        name=series.name,\n        values=series.values,\n        index=series.index.values,\n        index_name=series.index.name,\n    )\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.SeriesSerDe.to_series","title":"to_series  <code>classmethod</code>","text":"<pre><code>to_series(input: Series | dict | str)\n</code></pre> <p>Convert input to a Pandas Series object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Series | dict | str</code> <p>Input data to convert.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Pandas Series object from input data.</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>@classmethod\ndef to_series(cls, input: pd.Series | dict | str):\n    \"\"\"\n    Convert input to a Pandas Series object.\n\n    Args:\n        input (pd.Series | dict | str): Input data to convert.\n\n    Returns:\n        (pd.Series): Pandas Series object from input data.\n    \"\"\"\n    if isinstance(input, str):\n        print('str')\n        return cls.model_validate_json(input).as_series()\n    elif isinstance(input, dict):\n        print('dict')\n        return cls.from_dict(input)\n    elif isinstance(input, pd.Series):\n        print('series')\n        return input\n    else:\n        raise ValueError(input)\n</code></pre>"},{"location":"reference/process_manager/data_handlers/custom_serde_definitions/pandantic/#process_manager.data_handlers.custom_serde_definitions.pandantic.np_encoder","title":"np_encoder","text":"<pre><code>np_encoder(object)\n</code></pre> <p>JSON encoder function for numpy types.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Any</code> <p>Object to encode</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Encoded object</p> Source code in <code>src/process_manager/data_handlers/custom_serde_definitions/pandantic.py</code> <pre><code>def np_encoder(object):\n    \"\"\"\n    JSON encoder function for numpy types.\n\n    Args:\n        object (Any): Object to encode\n\n    Returns:\n        Any: Encoded object\n    \"\"\"\n    if isinstance(object, np.generic):\n        return object.item()\n    else:\n        return object\n</code></pre>"}]}